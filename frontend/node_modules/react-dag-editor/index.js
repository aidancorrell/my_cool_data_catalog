import { jsxs, jsx, Fragment } from 'react/jsx-runtime';
import * as React from 'react';
import { createContext, createRef, useRef, useContext, useLayoutEffect, useCallback, useEffect, useMemo, useState, createElement } from 'react';
import * as uuid from 'uuid';
import { v4 } from 'uuid';
import * as toposort from 'toposort';
import * as ReactDOM from 'react-dom';
import { unstable_batchedUpdates } from 'react-dom';
import DOMPurify from 'dompurify';
import { EventEmitter } from 'eventemitter3';
import { createUseStyles } from 'react-jss';
import { mergeStyleSets, mergeStyles } from '@fluentui/merge-styles';

const has = mask => state => Boolean(pick(mask)(state));
const add = mask => state => {
  const t = state || 0;

  if (Array.isArray(mask)) {
    return mask.reduce((c, m) => c | m, t);
  } else {
    return t | mask;
  }
};
const toggle = mask => state => {
  const t = state || 0;
  return t ^ mask;
};
const pick = mask => state => {
  const t = state || 0;
  return t & mask;
};
const remove = mask => state => {
  const t = state || 0;

  if (Array.isArray(mask)) {
    return mask.reduce((c, m) => c & ~m, t);
  } else {
    return t & ~mask;
  }
};
const replace = state => () => state;

var bitset = /*#__PURE__*/Object.freeze({
  __proto__: null,
  has: has,
  add: add,
  toggle: toggle,
  pick: pick,
  remove: remove,
  replace: replace
});

const EMPTY_STATUS = 0;
const SELECTED_STATUS = 0b0001;
const ACTIVATED_STATUS = 0b00000010;
var GraphEdgeStatus;

(function (GraphEdgeStatus) {
  GraphEdgeStatus[GraphEdgeStatus["Default"] = EMPTY_STATUS] = "Default";
  GraphEdgeStatus[GraphEdgeStatus["Selected"] = SELECTED_STATUS] = "Selected";
  GraphEdgeStatus[GraphEdgeStatus["Activated"] = ACTIVATED_STATUS] = "Activated";
  GraphEdgeStatus[GraphEdgeStatus["ConnectedToSelected"] = 4] = "ConnectedToSelected";
  GraphEdgeStatus[GraphEdgeStatus["UnconnectedToSelected"] = 8] = "UnconnectedToSelected";
  GraphEdgeStatus[GraphEdgeStatus["Editing"] = 16] = "Editing";
})(GraphEdgeStatus || (GraphEdgeStatus = {}));

var GraphNodeStatus;

(function (GraphNodeStatus) {
  GraphNodeStatus[GraphNodeStatus["Default"] = EMPTY_STATUS] = "Default";
  GraphNodeStatus[GraphNodeStatus["Selected"] = SELECTED_STATUS] = "Selected";
  GraphNodeStatus[GraphNodeStatus["Activated"] = ACTIVATED_STATUS] = "Activated";
  GraphNodeStatus[GraphNodeStatus["Editing"] = 4] = "Editing";
  GraphNodeStatus[GraphNodeStatus["ConnectedToSelected"] = 8] = "ConnectedToSelected";
  GraphNodeStatus[GraphNodeStatus["UnconnectedToSelected"] = 16] = "UnconnectedToSelected";
})(GraphNodeStatus || (GraphNodeStatus = {}));

var GraphPortStatus;

(function (GraphPortStatus) {
  GraphPortStatus[GraphPortStatus["Default"] = EMPTY_STATUS] = "Default";
  GraphPortStatus[GraphPortStatus["Selected"] = SELECTED_STATUS] = "Selected";
  GraphPortStatus[GraphPortStatus["Activated"] = ACTIVATED_STATUS] = "Activated";
  GraphPortStatus[GraphPortStatus["Connecting"] = 4] = "Connecting";
  GraphPortStatus[GraphPortStatus["ConnectingAsTarget"] = 8] = "ConnectingAsTarget";
})(GraphPortStatus || (GraphPortStatus = {}));

const updateStatus = updater => value => {
  var _a;

  const next = updater((_a = value.status) !== null && _a !== void 0 ? _a : 0);

  if (next === value.status) {
    return value;
  }

  return Object.assign(Object.assign({}, value), {
    status: next
  });
};
function isActivated(value) {
  return has(ACTIVATED_STATUS)(value.status);
}
function isNodeEditing(node) {
  return has(GraphNodeStatus.Editing)(node.status);
}
function isSelected(value) {
  return has(SELECTED_STATUS)(value.status);
}
function notSelected(value) {
  return !isSelected(value);
}
const resetConnectStatus = mask => prevStatus => {
  return (prevStatus || 0) & GraphNodeStatus.Activated | mask;
};

/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-ignore
const isDev = process.env.NODE_ENV !== "production";

/* eslint-disable no-console */

class Debug {
  static log(message) {
    if (isDev) {
      console.log(message);
    }
  }

  static warn(message) {
    if (isDev) {
      console.warn(message);
    }
  }

  static error(...args) {
    // tslint:disable-next-line: no-console
    console.error(...args);
  }

  static never(value, message) {
    throw new Error(message !== null && message !== void 0 ? message : `${value} is unexpected`);
  }

}

const getNodeConfig = (node, graphConfig) => {
  const nodeConfig = graphConfig.getNodeConfig(node);

  if (!nodeConfig) {
    Debug.warn(`invalid node ${JSON.stringify(node)}`);
    return undefined;
  }

  return nodeConfig;
};

/**
 * @param rectConfig
 * @param rect
 */

function getRectWidth(rectConfig, rect) {
  var _a;

  const minWidth = (_a = rectConfig === null || rectConfig === void 0 ? void 0 : rectConfig.getMinWidth(rect)) !== null && _a !== void 0 ? _a : 0;

  if (rect.width && rect.width >= minWidth) {
    return rect.width;
  }

  return minWidth;
}
/**
 * @param rectConfig
 * @param rect
 */

function getRectHeight(rectConfig, rect) {
  var _a;

  const minHeight = (_a = rectConfig === null || rectConfig === void 0 ? void 0 : rectConfig.getMinHeight(rect)) !== null && _a !== void 0 ? _a : 0;

  if (rect.height && rect.height >= minHeight) {
    return rect.height;
  }

  return minHeight;
}
/**
 * get node height and width by graphConfig
 *
 * @param node the node to get the size
 * @param graphConfig type IGraphConfig
 */

function getNodeSize(node, graphConfig) {
  const nodeConfig = getNodeConfig(node, graphConfig);
  const width = getRectWidth(nodeConfig, node);
  const height = getRectHeight(nodeConfig, node);
  return {
    height,
    width
  };
}
/**
 * @param group
 * @param nodes
 * @param graphConfig
 */

function getGroupRect(group, nodes, graphConfig) {
  var _a, _b, _c, _d, _e, _f, _g, _h;

  const childrenIds = new Set(group.nodeIds);
  const children = Array.from(nodes.values()).filter(node => childrenIds.has(node.id));
  const minX = Math.min(...children.map(node => node.x));
  const maxX = Math.max(...children.map(node => node.x + getNodeSize(node, graphConfig).width));
  const minY = Math.min(...children.map(node => node.y));
  const maxY = Math.max(...children.map(node => node.y + getNodeSize(node, graphConfig).height));
  const x = minX - ((_b = (_a = group.padding) === null || _a === void 0 ? void 0 : _a.left) !== null && _b !== void 0 ? _b : 0);
  const y = minY - ((_d = (_c = group.padding) === null || _c === void 0 ? void 0 : _c.top) !== null && _d !== void 0 ? _d : 0);
  const height = maxY - y + ((_f = (_e = group.padding) === null || _e === void 0 ? void 0 : _e.bottom) !== null && _f !== void 0 ? _f : 0);
  const width = maxX - x + ((_h = (_g = group.padding) === null || _g === void 0 ? void 0 : _g.left) !== null && _h !== void 0 ? _h : 0);
  return {
    x,
    y,
    width,
    height
  };
}

/**
 * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
 */
var MouseEventButton;

(function (MouseEventButton) {
  /**
   * usually the left button or the un-initialized state
   */
  MouseEventButton[MouseEventButton["Primary"] = 0] = "Primary";
  /**
   * usually the wheel button or the middle button (if present)
   */

  MouseEventButton[MouseEventButton["Auxiliary"] = 1] = "Auxiliary";
  /**
   * usually the right button
   */

  MouseEventButton[MouseEventButton["Secondary"] = 2] = "Secondary";
  /**
   * typically the Browser Back button
   */

  MouseEventButton[MouseEventButton["Fourth"] = 4] = "Fourth";
  /**
   * typically the Browser Forward button
   */

  MouseEventButton[MouseEventButton["Fifth"] = 5] = "Fifth";
})(MouseEventButton || (MouseEventButton = {}));

var MouseEventButtons;

(function (MouseEventButtons) {
  MouseEventButtons[MouseEventButtons["None"] = 0] = "None";
  MouseEventButtons[MouseEventButtons["Left"] = 1] = "Left";
  MouseEventButtons[MouseEventButtons["Right"] = 2] = "Right";
  MouseEventButtons[MouseEventButtons["Middle"] = 4] = "Middle";
})(MouseEventButtons || (MouseEventButtons = {}));

const DEFAULT_AUTO_ALIGN_THRESHOLD = 50;
const COPIED_NODE_SPACING = 50;
const NODE_MIN_VISIBLE_LENGTH = 5;
const NODE_MAX_VISIBLE_LENGTH = 500;
const defaultColors = {
  controlPointColor: "#333333",
  primaryColor: "#0078D4",
  defaultColor: "#CCCCCC",
  borderColor: "#B3B0AD",
  defaultBorderColor: "#FFFFFF",
  unConnectableBgColor: "#E1DFDD",
  defaultBackgroundColor: "#FFFFFF",
  portStroke: "#ccc",
  portFill: "#fff",
  connectedPortColor: "gray",
  nodeActivateFill: "#ffffff",
  nodeActivateStroke: "#0078D4",
  nodeFill: "#ffffff",
  nodeStroke: "#cccccc",
  contextMenuBackground: "#FFFFFF",
  contextMenuBorder: "#E1DFDD",
  contextMenuHoverBackground: "rgba(0, 120, 212, 0.05)",
  fontColor: "#000000",
  canvasBackground: "#EDEDED",
  minimapBackground: "#EDEDED",
  edgeColor: "#ccc",
  edgeColorSelected: "#015cda",
  minimapShadow: "#000000",
  outlineStyle: "none",
  focusOutlineColor: "#000000",
  dummyNodeStroke: "#015cda",
  inputFocusBorderAlt: "#0078d4",
  buttonBorder: "#797775",
  scrollbarColor: "#c8c8c8"
};

const RectComponent = props => {
  const {
    style,
    node,
    width,
    height,
    textY
  } = props;
  const comment = node.data && node.data.comment ? node.data.comment : "";
  const isEditing = isNodeEditing(node);
  return jsxs("g", {
    children: [jsx("rect", {
      width: width,
      height: height,
      x: node.x,
      y: node.y,
      style: style,
      rx: style.borderRadius
    }), jsx("text", Object.assign({
      x: node.x,
      y: textY,
      fontSize: 12
    }, {
      children: node.name
    })), node.data && node.data.comment && !isEditing && jsx("text", Object.assign({
      x: node.x,
      y: textY + 20,
      fontSize: 12,
      className: `comment-${node.id}`
    }, {
      children: node.data.comment
    })), isEditing && jsx("foreignObject", Object.assign({
      x: node.x,
      y: textY,
      height: height / 2.5,
      width: width - 5
    }, {
      children: jsx("input", {
        value: comment,
        placeholder: "Input your comment here"
      })
    }))]
  }, node.id);
};

const rect = {
  getMinHeight() {
    return 150;
  },

  getMinWidth() {
    return 150;
  },

  render(args) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const node = args.model;
    const width = getRectWidth(rect, node);
    const height = getRectHeight(rect, node);
    const style = has(GraphNodeStatus.Selected | GraphNodeStatus.Activated)(node.status) ? {
      fill: defaultColors.nodeActivateFill,
      stroke: defaultColors.nodeActivateStroke
    } : {
      fill: defaultColors.nodeFill,
      fillOpacity: 0.1,
      stroke: defaultColors.nodeStroke,
      borderRadius: "5"
    };
    const textY = node.y + height / 3;
    return jsx(RectComponent, {
      style: style,
      node: node,
      width: width,
      height: height,
      textY: textY
    });
  }

};

const getCurvePathD = (x1, x2, y1, y2) => {
  // The ports are even width in px. and paths are 2 px. wide. We therefore subtract 1 from the HalfWidth to have them appear centered -- center of the path lines up with center of the port.
  return `M${x1},${y1}C${x1},${y1 - getControlPointDistance(y1, y2)},${x2},${y2 + 5 + getControlPointDistance(y1, y2)},${x2},${y2 + 5}`;
};

const getControlPointDistance = (y1, y2) => {
  return Math.min(5 * 15, // 5 is port height
  Math.max(5 * 3, Math.abs((y1 - (y2 + 5)) / 2)));
};

const line = {
  render(args) {
    const edge = args.model;
    const style = {
      cursor: "crosshair",
      stroke: has(GraphEdgeStatus.Selected)(edge.status) ? defaultColors.edgeColorSelected : defaultColors.edgeColor,
      strokeWidth: "2"
    };
    return jsx("path", {
      d: getCurvePathD(args.x2, args.x1, args.y2, args.y1),
      fill: "none",
      style: style,
      id: `edge${edge.id}`
    }, edge.id);
  }

};

class DefaultPort {
  getStyle(port, _parentNode, _data, connectedAsSource, connectedAsTarget) {
    const stroke = defaultColors.portStroke;
    let fill = defaultColors.portFill;

    if (connectedAsSource || connectedAsTarget) {
      fill = defaultColors.connectedPortColor;
    }

    if (has(GraphPortStatus.Activated)(port.status)) {
      fill = defaultColors.primaryColor;
    }

    return {
      stroke,
      fill
    };
  }

  getIsConnectable() {
    return true;
  }

  render(args) {
    const {
      model: port,
      data,
      parentNode
    } = args;
    const connectedAsSource = data.isPortConnectedAsSource(parentNode.id, port.id);
    const connectedAsTarget = data.isPortConnectedAsTarget(parentNode.id, port.id);
    const style = this.getStyle(port, parentNode, data, connectedAsSource, connectedAsTarget);
    const {
      x,
      y
    } = args;
    const polygonPoints = `${x - 5} ${y}, ${x + 7} ${y}, ${x + 1} ${y + 8}`;
    return connectedAsTarget ? jsx("polygon", {
      points: polygonPoints,
      style: style
    }) : jsx("circle", {
      r: 5,
      cx: x,
      cy: y,
      style: style
    }, `${args.parentNode.id}-${args.model.id}`);
  }

}

const defaultPort = new DefaultPort();

class DefaultClipboard {
  constructor(storage) {
    this.storage = storage;
  }

  write(data) {
    this.storage.setItem("graph-clipboard", JSON.stringify({
      nodes: data.nodes.map(n => Object.assign(Object.assign({}, n), {
        data: {}
      })),
      edges: data.edges.map(e => Object.assign(Object.assign({}, e), {
        data: {}
      }))
    }));
  }

  read() {
    const str = this.storage.getItem("graph-clipboard");

    if (!str) {
      return null;
    }

    try {
      const data = JSON.parse(str);
      const nodeIdHash = new Map();
      return {
        nodes: data.nodes.map(n => {
          const newId = uuid.v4();
          nodeIdHash.set(n.id, newId);
          return Object.assign(Object.assign({}, n), {
            x: n.x + COPIED_NODE_SPACING,
            y: n.y + COPIED_NODE_SPACING,
            id: newId
          });
        }),
        edges: data.edges.map(e => Object.assign(Object.assign({}, e), {
          id: uuid.v4(),
          source: nodeIdHash.get(e.source) || "",
          target: nodeIdHash.get(e.target) || ""
        }))
      };
    } catch (error) {
      return null;
    }
  }

}

class DefaultStorage {
  get length() {
    return this.items.size;
  }

  constructor() {
    this.key = () => "DefaultLocalStorage";

    this.items = new Map();
  }

  clear() {
    this.items = new Map();
  }

  setItem(key, data) {
    this.items.set(key, data);
  }

  getItem(key) {
    if (!this.items.has(key)) {
      return null;
    }

    return this.items.get(key);
  }

  removeItem(key) {
    this.items.delete(key);
  }

}

function applyDefaultPortsPosition(list) {
  const inputPorts = list.filter(p => !p.isInputDisabled);
  const outputPorts = list.filter(p => p.isInputDisabled);
  const inputPortsCount = inputPorts.length;
  const outputPortsCount = outputPorts.length;
  const inputPortsInterval = 1 / (inputPortsCount + 1);
  const outputPortsInterval = 1 / (outputPortsCount + 1);
  const res = [];

  for (let i = 0; i < inputPortsCount; i += 1) {
    res.push(Object.assign(Object.assign({}, inputPorts[i]), {
      position: [(i + 1) * inputPortsInterval, 0]
    }));
  }

  for (let i = 0; i < outputPortsCount; i += 1) {
    const port = outputPorts[i];
    res.push(Object.assign(Object.assign({}, port), {
      position: [(i + 1) * outputPortsInterval, 1]
    }));
  }

  return res;
}

function applyHorizontalGraphPortsPosition(list) {
  const inputPorts = list.filter(p => !p.isInputDisabled);
  const outputPorts = list.filter(p => !p.isOutputDisabled);
  const inputPortsCount = inputPorts.length;
  const outputPortsCount = outputPorts.length;
  const inputPortsInterval = 1 / (inputPortsCount + 1);
  const outputPortsInterval = 1 / (outputPortsCount + 1);
  const res = [];

  for (let i = 0; i < inputPortsCount; i += 1) {
    res.push(Object.assign(Object.assign({}, inputPorts[i]), {
      position: [0, (i + 1) * inputPortsInterval]
    }));
  }

  for (let i = 0; i < outputPortsCount; i += 1) {
    res.push(Object.assign(Object.assign({}, outputPorts[i]), {
      position: [1, (i + 1) * outputPortsInterval]
    }));
  }

  return res;
}

class GraphConfigBuilder {
  constructor() {
    const storage = new DefaultStorage();
    const defaultClipboard = new DefaultClipboard(storage);
    this.draft = {
      getNodeConfig: () => rect,
      getEdgeConfig: () => line,
      getPortConfig: () => defaultPort,
      getGroupConfig: () => undefined,
      getClipboard: () => defaultClipboard
    };
  }

  static default() {
    return new GraphConfigBuilder();
  }

  static from(graphConfig) {
    return new GraphConfigBuilder().registerNode(graphConfig.getNodeConfig.bind(graphConfig)).registerEdge(graphConfig.getEdgeConfig.bind(graphConfig)).registerPort(graphConfig.getPortConfig.bind(graphConfig)).registerGroup(graphConfig.getGroupConfig.bind(graphConfig)).registerClipboard(graphConfig.getClipboard.bind(graphConfig));
  }

  registerNode(getConfig) {
    this.draft.getNodeConfig = getConfig;
    return this;
  }

  registerEdge(getConfig) {
    this.draft.getEdgeConfig = getConfig;
    return this;
  }

  registerPort(getConfig) {
    this.draft.getPortConfig = getConfig;
    return this;
  }

  registerGroup(getConfig) {
    this.draft.getGroupConfig = getConfig;
    return this;
  }

  registerClipboard(getClipboard) {
    this.draft.getClipboard = getClipboard;
    return this;
  }

  build() {
    return this.draft;
  }

}

const GraphConfigContext = /*#__PURE__*/createContext(GraphConfigBuilder.default().build());

var MenuType;

(function (MenuType) {
  MenuType["Node"] = "node";
  MenuType["Edge"] = "edge";
  MenuType["Port"] = "port";
  MenuType["Canvas"] = "canvas";
  MenuType["Multi"] = "multi";
})(MenuType || (MenuType = {}));

class ContextMenuConfig {
  constructor() {
    this.contextMenu = new Map();
  }

  registerContextMenu(props) {
    this.contextMenuProps = Object.assign({}, props);
  }

  registerMenu(element, menuType) {
    this.contextMenu.set(menuType, element);
  }

  getMenu(menuType) {
    if (this.contextMenuProps && this.contextMenu.has(menuType)) {
      const {
        className,
        styles
      } = this.contextMenuProps;
      const reactElement = /*#__PURE__*/React.createElement("div", {
        className,
        style: styles
      }, this.contextMenu.get(menuType));
      return reactElement;
    }

    return null;
  }

}
const ContextMenuConfigContext = /*#__PURE__*/React.createContext(new ContextMenuConfig());

const emptySelectBoxPosition = () => ({
  startX: 0,
  startY: 0,
  height: 0,
  width: 0
});
const SelectBox = props => {
  const {
    selectBoxPosition,
    style
  } = props;
  const selectBoxD = `m${selectBoxPosition.startX} ${selectBoxPosition.startY} v ${selectBoxPosition.height} h ${selectBoxPosition.width} v${-selectBoxPosition.height} h ${-selectBoxPosition.width}`;
  const pathStyle = style !== null && style !== void 0 ? style : {
    fill: "none",
    stroke: defaultColors.defaultColor
  };
  return jsx("path", {
    style: pathStyle,
    d: selectBoxD
  });
};

var GraphFeatures;

(function (GraphFeatures) {
  GraphFeatures["NodeDraggable"] = "nodeDraggable";
  GraphFeatures["NodeResizable"] = "nodeResizable";
  GraphFeatures["ClickNodeToSelect"] = "clickNodeToSelect";
  GraphFeatures["PanCanvas"] = "panCanvas";
  GraphFeatures["MultipleSelect"] = "multipleSelect";
  GraphFeatures["LassoSelect"] = "lassoSelect";
  GraphFeatures["Delete"] = "delete";
  GraphFeatures["AddNewNodes"] = "addNewNodes";
  GraphFeatures["AddNewEdges"] = "addNewEdges";
  GraphFeatures["AddNewPorts"] = "addNewPorts";
  GraphFeatures["AutoFit"] = "autoFit";
  GraphFeatures["CanvasHorizontalScrollable"] = "canvasHorizontalScrollable";
  GraphFeatures["CanvasVerticalScrollable"] = "canvasVerticalScrollable";
  GraphFeatures["NodeHoverView"] = "nodeHoverView";
  GraphFeatures["PortHoverView"] = "portHoverView";
  GraphFeatures["AddEdgesByKeyboard"] = "addEdgesByKeyboard";
  GraphFeatures["A11yFeatures"] = "a11YFeatures";
  GraphFeatures["EditNode"] = "editNode";
  GraphFeatures["AutoAlign"] = "autoAlign";
  GraphFeatures["UndoStack"] = "undoStack";
  GraphFeatures["CtrlKeyZoom"] = "ctrlKeyZoom";
  GraphFeatures["LimitBoundary"] = "limitBoundary";
  GraphFeatures["EditEdge"] = "editEdge";
  GraphFeatures["InvisibleScrollbar"] = "InvisibleScrollbar";
})(GraphFeatures || (GraphFeatures = {}));

const allFeatures = new Set([GraphFeatures.NodeDraggable, GraphFeatures.NodeResizable, GraphFeatures.ClickNodeToSelect, GraphFeatures.PanCanvas, GraphFeatures.MultipleSelect, GraphFeatures.LassoSelect, GraphFeatures.Delete, GraphFeatures.AddNewNodes, GraphFeatures.AddNewEdges, GraphFeatures.AddNewPorts, GraphFeatures.CanvasHorizontalScrollable, GraphFeatures.CanvasVerticalScrollable, GraphFeatures.NodeHoverView, GraphFeatures.PortHoverView, GraphFeatures.AddEdgesByKeyboard, GraphFeatures.A11yFeatures, GraphFeatures.AutoFit, GraphFeatures.EditNode, GraphFeatures.AutoAlign, GraphFeatures.UndoStack, GraphFeatures.CtrlKeyZoom, GraphFeatures.LimitBoundary, GraphFeatures.EditEdge]);
const defaultFeatures = new Set([GraphFeatures.NodeDraggable, GraphFeatures.NodeResizable, GraphFeatures.ClickNodeToSelect, GraphFeatures.PanCanvas, GraphFeatures.MultipleSelect, GraphFeatures.Delete, GraphFeatures.AddNewNodes, GraphFeatures.AddNewEdges, GraphFeatures.AddNewPorts, GraphFeatures.CanvasHorizontalScrollable, GraphFeatures.CanvasVerticalScrollable, GraphFeatures.NodeHoverView, GraphFeatures.PortHoverView, GraphFeatures.AddEdgesByKeyboard, GraphFeatures.A11yFeatures, GraphFeatures.EditNode, GraphFeatures.AutoAlign, GraphFeatures.UndoStack, GraphFeatures.CtrlKeyZoom, GraphFeatures.LimitBoundary]);
const dataReadonlyMode = new Set([GraphFeatures.NodeDraggable, GraphFeatures.NodeResizable, GraphFeatures.ClickNodeToSelect, GraphFeatures.PanCanvas, GraphFeatures.MultipleSelect, GraphFeatures.CanvasHorizontalScrollable, GraphFeatures.CanvasVerticalScrollable, GraphFeatures.NodeHoverView, GraphFeatures.PortHoverView, GraphFeatures.A11yFeatures, GraphFeatures.CtrlKeyZoom, GraphFeatures.LimitBoundary]);
const GanttChartFeatures = new Set([GraphFeatures.ClickNodeToSelect, GraphFeatures.CanvasHorizontalScrollable, GraphFeatures.CanvasVerticalScrollable, GraphFeatures.NodeHoverView, GraphFeatures.PortHoverView, GraphFeatures.A11yFeatures, GraphFeatures.LassoSelect, GraphFeatures.LimitBoundary]);
const previewMode = new Set([GraphFeatures.NodeHoverView, GraphFeatures.PortHoverView, GraphFeatures.AutoFit]);

const emptyDummyNodes = () => ({
  dx: 0,
  dy: 0,
  dWidth: 0,
  dHeight: 0,
  alignedDX: undefined,
  alignedDY: undefined,
  nodes: [],
  isVisible: false
});

const is$1 = Object.is;
class MapIterator {
  constructor(upstream, f) {
    this.upstream = upstream;
    this.f = f;
  }

  [Symbol.iterator]() {
    return this;
  }

  next() {
    const next = this.upstream.next();

    if (next.done) {
      return next;
    }

    return {
      done: false,
      value: this.f(next.value)
    };
  }

}

/* eslint-disable no-param-reassign */
var NodeType$1;

(function (NodeType) {
  NodeType[NodeType["Bitmap"] = 0] = "Bitmap";
  NodeType[NodeType["Collision"] = 1] = "Collision";
})(NodeType$1 || (NodeType$1 = {}));

const HASH_CODE_LENGTH = 30;
const BIT_PARTITION_SIZE = 5;
const FULL_MASK = 0x3fffffff;
/**
 * @param mask
 */

function bitPosFrom(mask) {
  return 1 << mask;
}
/**
 * @param bitmap
 * @param mask
 * @param bitPos
 */

function indexFrom(bitmap, mask, bitPos) {
  return bitmap === FULL_MASK ? mask : bitCount(bitmap & bitPos - 1);
}
/**
 * @param hash
 * @param shift
 */

function maskFrom(hash, shift) {
  return hash >>> shift & 0b11111;
}
/**
 * https://jsperf.com/hamming-weight/19
 *
 * @param x uint32
 */

function bitCount(x) {
  x |= 0;
  x -= x >>> 1 & 0x55555555; // put count of each 2 bits into those 2 bits

  x = (x & 0x33333333) + (x >>> 2 & 0x33333333); // put count of each 4 bits into those 4 bits

  x = x + (x >>> 4) & 0x0f0f0f0f; // put count of each 8 bits into those 8 bits

  x += x >>> 8; // put count of each 16 bits into their lowest 8 bits

  x += x >>> 16; // put count of each 32 bits into their lowest 8 bits

  return x & 0x7f;
} // tslint:enable:no-parameter-reassignment comment-format

class BitmapIndexedNode {
  get valueCount() {
    return this.values.length;
  }

  get nodeCount() {
    return this.children.length;
  }

  constructor(owner, dataMap, nodeMap, keys, values, children, hashes, size) {
    this.type = NodeType$1.Bitmap;
    this.owner = owner;
    this.dataMap = dataMap;
    this.nodeMap = nodeMap;
    this.keys = keys;
    this.values = values;
    this.children = children;
    this.hashes = hashes;
    this.size = size;
  }

  static empty(owner) {
    return new BitmapIndexedNode(owner, 0, 0, [], [], [], [], 0);
  }

  getKey(index) {
    return this.keys[index];
  }

  getValue(index) {
    return this.values[index];
  }

  getHash(index) {
    return this.hashes[index];
  }

  getNode(index) {
    return this.children[index];
  }

  contains(key, keyHash, shift) {
    const mask = maskFrom(keyHash, shift);
    const bitPos = bitPosFrom(mask);
    const {
      dataMap,
      nodeMap
    } = this;

    if ((dataMap & bitPos) !== 0) {
      const index = indexFrom(dataMap, mask, bitPos);
      const key0 = this.getKey(index);
      return is$1(key0, key);
    } else if ((nodeMap & bitPos) !== 0) {
      const index = indexFrom(nodeMap, mask, bitPos);
      return this.getNode(index).contains(key, keyHash, shift + BIT_PARTITION_SIZE);
    }

    return false;
  }

  get(key, keyHash, shift) {
    const mask = maskFrom(keyHash, shift);
    const bitPos = bitPosFrom(mask);
    const {
      dataMap,
      nodeMap
    } = this;

    if ((dataMap & bitPos) !== 0) {
      const index = indexFrom(dataMap, mask, bitPos);
      const key0 = this.getKey(index);
      return is$1(key0, key) ? this.getValue(index) : undefined;
    } else if ((nodeMap & bitPos) !== 0) {
      const index = indexFrom(nodeMap, mask, bitPos);
      return this.getNode(index).get(key, keyHash, shift + BIT_PARTITION_SIZE);
    }

    return undefined;
  }

  insert(owner, key, value, hash, shift) {
    const mask = maskFrom(hash, shift);
    const bitPos = bitPosFrom(mask);
    const {
      dataMap,
      nodeMap
    } = this;

    if ((dataMap & bitPos) !== 0) {
      const index = indexFrom(dataMap, mask, bitPos);
      const key0 = this.getKey(index);
      const value0 = this.getValue(index);
      const key0Hash = this.getHash(index);

      if (key0Hash === hash && is$1(key0, key)) {
        return is$1(value0, value) ? this : this.setValue(owner, value, index);
      } else {
        const subNodeNew = mergeTwoKeyValPairs(owner, key0, value0, key0Hash, key, value, hash, shift + BIT_PARTITION_SIZE);
        return this.migrateInlineToNode(owner, bitPos, subNodeNew);
      }
    } else if ((nodeMap & bitPos) !== 0) {
      const index = indexFrom(nodeMap, mask, bitPos);
      const subNode = this.getNode(index);
      const subNodeNew = subNode.insert(owner, key, value, hash, shift + BIT_PARTITION_SIZE);
      return this.setNode(owner, 1, subNodeNew, bitPos);
    }

    return this.insertValue(owner, bitPos, key, hash, value);
  }

  update(owner, key, updater, hash, shift) {
    const mask = maskFrom(hash, shift);
    const bitPos = bitPosFrom(mask);
    const {
      dataMap,
      nodeMap
    } = this;

    if ((dataMap & bitPos) !== 0) {
      const index = indexFrom(dataMap, mask, bitPos);
      const key0 = this.getKey(index);
      const key0Hash = this.getHash(index);

      if (key0Hash === hash && is$1(key0, key)) {
        const value0 = this.getValue(index);
        const value = updater(value0);
        return is$1(value0, value) ? this : this.setValue(owner, value, index);
      }
    } else if ((nodeMap & bitPos) !== 0) {
      const index = indexFrom(nodeMap, mask, bitPos);
      const subNode = this.getNode(index);
      const subNodeNew = subNode.update(owner, key, updater, hash, shift + BIT_PARTITION_SIZE);
      return subNodeNew === subNode ? this : this.setNode(owner, 0, subNodeNew, bitPos);
    }

    return this;
  }

  remove(owner, key, keyHash, shift) {
    const mask = maskFrom(keyHash, shift);
    const bitPos = bitPosFrom(mask);

    if ((this.dataMap & bitPos) !== 0) {
      const index = indexFrom(this.dataMap, mask, bitPos);
      const key0 = this.getKey(index);

      if (is$1(key0, key)) {
        return this.removeValue(owner, bitPos);
      }

      return undefined;
    } else if ((this.nodeMap & bitPos) !== 0) {
      const index = indexFrom(this.nodeMap, mask, bitPos);
      const subNode = this.getNode(index);
      const remove = subNode.remove(owner, key, keyHash, shift + BIT_PARTITION_SIZE);

      if (remove === undefined) {
        return undefined;
      }

      const [subNodeNew, removedValue] = remove;
      const subNodeNewSize = subNodeNew.size;

      if (subNodeNewSize === 1) {
        if (this.size === subNode.size) {
          return [new BitmapIndexedNode(owner, bitPos, 0, [subNodeNew.getKey(0)], [subNodeNew.getValue(0)], [], [subNodeNew.getHash(0)], 1), removedValue];
        }

        return [this.migrateNodeToInline(owner, bitPos, subNodeNew), removedValue];
      }

      return [this.setNode(owner, -1, subNodeNew, bitPos), removedValue];
    }

    return undefined;
  }

  toOwned(owner) {
    return this.owner === owner ? this : new BitmapIndexedNode(owner, this.dataMap, this.nodeMap, this.keys.slice(), this.values.slice(), this.children.slice(), this.hashes.slice(), this.size);
  }

  iter() {
    return new BitmapIndexedNodeIterator(this);
  }

  map(owner, f) {
    const valueCount = this.valueCount;
    const keys = [];
    const values = [];
    const children = [];
    let same = true;

    for (let i = 0; i < valueCount; i += 1) {
      const key = this.getKey(i);
      const value0 = this.getValue(i);
      const value = f(value0, key);
      same = same && is$1(value0, value);
      keys.push(key);
      values.push(value);
    }

    for (let i = 0; i < this.children.length; i += 1) {
      const node0 = this.getNode(i);
      const node = node0.map(owner, f);
      same = same && node === node0;
      children.push(node);
    }

    return same ? this : new BitmapIndexedNode(owner, this.dataMap, this.nodeMap, keys, values, children, this.hashes, this.size);
  }

  forEach(f) {
    for (let i = 0; i < this.values.length; i += 1) {
      const key = this.getKey(i);
      const value = this.getValue(i);
      f(value, key);
    }

    for (let i = 0; i < this.children.length; i += 1) {
      const child = this.getNode(i);
      child.forEach(f);
    }
  }

  find(predicate) {
    for (let i = 0; i < this.values.length; i += 1) {
      const value = this.getValue(i);

      if (predicate(value)) {
        return value;
      }
    }

    for (let i = 0; i < this.children.length; i += 1) {
      const child = this.getNode(i);
      const found = child.find(predicate);

      if (found) {
        return found;
      }
    }

    return undefined;
  }

  dataIndex(bitPos) {
    return bitCount(this.dataMap & bitPos - 1);
  }

  nodeIndex(bitPos) {
    return bitCount(this.nodeMap & bitPos - 1);
  }

  setValue(owner, value, index) {
    const next = this.toOwned(owner);
    next.values[index] = value;
    return next;
  }

  insertValue(owner, bitPos, key, originalHash, value) {
    const index = this.dataIndex(bitPos);
    const next = this.toOwned(owner);
    next.size += 1;
    next.dataMap |= bitPos;
    next.keys.splice(index, 0, key);
    next.values.splice(index, 0, value);
    next.hashes.splice(index, 0, originalHash);
    return next;
  }

  migrateInlineToNode(owner, bitPos, child) {
    const indexOld = this.dataIndex(bitPos);
    const indexNew = this.nodeIndex(bitPos);
    const next = this.toOwned(owner);
    next.dataMap ^= bitPos;
    next.nodeMap |= bitPos;
    next.keys.splice(indexOld, 1);
    next.values.splice(indexOld, 1);
    next.children.splice(indexNew, 0, child);
    next.hashes.splice(indexOld, 1);
    next.size += 1;
    return next;
  }

  migrateNodeToInline(owner, bitPos, node) {
    const indexOld = this.nodeIndex(bitPos);
    const indexNew = this.dataIndex(bitPos);
    const key = node.getKey(0);
    const value = node.getValue(0);
    const hash = node.getHash(0);
    const next = this.toOwned(owner);
    next.dataMap = next.dataMap | bitPos;
    next.nodeMap = next.nodeMap ^ bitPos;
    next.children.splice(indexOld, 1);
    next.keys.splice(indexNew, 0, key);
    next.values.splice(indexNew, 0, value);
    next.size -= 1;
    next.hashes.splice(indexNew, 0, hash);
    return next;
  }

  setNode(owner, sizeDelta, newNode, bitPos) {
    const index = this.nodeIndex(bitPos);
    const next = this.toOwned(owner);
    next.children[index] = newNode;
    next.size = next.size + sizeDelta;
    return next;
  }

  removeValue(owner, bitPos) {
    const index = this.dataIndex(bitPos);
    const value = this.getValue(index);
    const next = this.toOwned(owner);
    next.dataMap ^= bitPos;
    next.keys.splice(index, 1);
    next.values.splice(index, 1);
    next.hashes.splice(index, 1);
    next.size -= 1;
    return [next, value];
  }

}
/**
 * @param owner
 * @param key0
 * @param value0
 * @param keyHash0
 * @param key1
 * @param value1
 * @param keyHash1
 * @param shift
 */

function mergeTwoKeyValPairs(owner, key0, value0, keyHash0, key1, value1, keyHash1, shift) {
  if (shift >= HASH_CODE_LENGTH) {
    return new HashCollisionNode(owner, keyHash0, [key0, key1], [value0, value1]);
  } else {
    const mask0 = maskFrom(keyHash0, shift);
    const mask1 = maskFrom(keyHash1, shift);

    if (mask0 !== mask1) {
      const dataMap = bitPosFrom(mask0) | bitPosFrom(mask1);

      if (mask0 < mask1) {
        return new BitmapIndexedNode(owner, dataMap, 0, [key0, key1], [value0, value1], [], [keyHash0, keyHash1], 2);
      }

      return new BitmapIndexedNode(owner, dataMap, 0, [key1, key0], [value1, value0], [], [keyHash1, keyHash0], 2);
    } else {
      const nodeMap = bitPosFrom(mask0);
      const node = mergeTwoKeyValPairs(owner, key0, value0, keyHash0, key1, value1, keyHash1, shift + BIT_PARTITION_SIZE);
      return new BitmapIndexedNode(owner, 0, nodeMap, [], [], [node], [], node.size);
    }
  }
}

class HashCollisionNode {
  get size() {
    return this.keys.length;
  }

  constructor(owner, hash, keys, values) {
    this.type = NodeType$1.Collision;
    this.owner = owner;
    this.hash = hash;
    this.keys = keys;
    this.values = values;
  }

  toOwned(owner) {
    return this.owner === owner ? this : new HashCollisionNode(owner, this.hash, this.keys.slice(), this.values.slice());
  }

  contains(key) {
    return this.keys.includes(key);
  }

  get(key) {
    const index = this.keys.findIndex(it => is$1(it, key));
    return index >= 0 ? this.values[index] : undefined;
  }

  insert(owner, key, value) {
    const index = this.keys.findIndex(it => is$1(it, key));

    if (index >= 0) {
      const value0 = this.values[index];

      if (is$1(value0, value)) {
        return this;
      }

      const next = this.toOwned(owner);
      next.values[index] = value;
      return next;
    } else {
      const next = this.toOwned(owner);
      next.keys.push(key);
      next.values.push(value);
      return next;
    }
  }

  update(owner, key, updater) {
    const index = this.keys.findIndex(it => is$1(it, key));

    if (index >= 0) {
      const value0 = this.values[index];
      const value = updater(value0);

      if (is$1(value0, value)) {
        return this;
      }

      const next = this.toOwned(owner);
      next.values[index] = value;
      return next;
    }

    return this;
  }

  remove(owner, key) {
    const index = this.keys.findIndex(it => is$1(it, key));

    if (index === -1) {
      return undefined;
    }

    const value = this.getValue(index);
    return [new HashCollisionNode(owner, this.hash, this.keys.filter((_, i) => i !== index), this.values.filter((_, i) => i !== index)), value];
  }

  getKey(index) {
    return this.keys[index];
  }

  getValue(index) {
    return this.values[index];
  }

  getHash() {
    return this.hash;
  }

  iter() {
    return new HashCollisionNodeIterator(this);
  }

  map(owner, f) {
    const len = this.size;
    const values = [];
    let update = false;

    for (let i = 0; i < len; i += 1) {
      const key = this.getKey(i);
      const value0 = this.getValue(i);
      const value = f(value0, key);
      values.push(value);
      update = is$1(value0, value);
    }

    return update ? new HashCollisionNode(owner, this.hash, this.keys, values) : this;
  }

  forEach(f) {
    const len = this.size;

    for (let i = 0; i < len; i += 1) {
      const key = this.getKey(i);
      const value0 = this.getValue(i);
      f(value0, key);
    }
  }

  find(predicate) {
    return this.values.find(predicate);
  }

}
class BitmapIndexedNodeIterator {
  constructor(node) {
    this.index = 0;
    this.delegate = null;
    this.done = false;
    this.node = node;
    this.valueCount = node.valueCount;
    this.nodeCount = node.nodeCount;
    this.size = this.valueCount + this.nodeCount;
  }

  [Symbol.iterator]() {
    return this.clone();
  }

  next() {
    if (this.done) {
      return {
        done: true,
        value: undefined
      };
    }

    if (this.index < this.valueCount) {
      const key = this.node.getKey(this.index);
      const value = this.node.getValue(this.index);
      this.index += 1;
      return {
        done: false,
        value: [key, value]
      };
    }

    if (this.index < this.size) {
      if (this.delegate === null) {
        this.delegate = this.node.getNode(this.index - this.valueCount).iter();
      }

      const next = this.delegate.next();

      if (next.done) {
        this.index += 1;
        this.delegate = null;
        return this.next();
      }

      return next;
    }

    this.done = true;
    return {
      done: true,
      value: undefined
    };
  }

  clone() {
    const iter = new BitmapIndexedNodeIterator(this.node);
    iter.index = this.index;
    iter.delegate = this.delegate;
    iter.done = this.done;
    return iter;
  }

}
class HashCollisionNodeIterator {
  constructor(node) {
    this.index = 0;
    this.node = node;
  }

  [Symbol.iterator]() {
    return this.clone();
  }

  next() {
    if (this.index >= this.node.size) {
      return {
        done: true,
        value: undefined
      };
    }

    const key = this.node.getKey(this.index);
    const value = this.node.getValue(this.index);
    this.index += 1;
    return {
      done: false,
      value: [key, value]
    };
  }

  clone() {
    const iter = new HashCollisionNodeIterator(this.node);
    iter.index = this.index;
    return iter;
  }

}

/* eslint-disable no-plusplus */

/**
 * keep the hash function the same as immutable.js
 *
 * @param o
 */
function hashing(o) {
  if (o === null) {
    return 0x42108422;
  }

  switch (typeof o) {
    case "boolean":
      // The hash values for built-in constants are a 1 value for each 5-byte
      // shift region expect for the first, which encodes the value. This
      // reduces the odds of a hash collision for these common values.
      return o ? 0x32108421 : 0x32108420;

    case "number":
      return hashNumber(o);

    case "string":
      return hashString(o);

    case "object":
    case "function":
    case "symbol":
      throw new Error("Using object, function and symbol as hash map key is not supported");

    case "undefined":
      return 0x32108423;

    default:
      return hashString(String(o));
  }
} // http://jsperf.com/hashing-strings

/**
 * @param str
 */

function hashString(str) {
  // This is the hash from JVM
  // The hash code for a string is computed as
  // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
  // where s[i] is the ith character of the string and n is the length of
  // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
  // (exclusive) by dropping high bits.
  let hashed = 0;

  for (let ii = 0; ii < str.length; ii++) {
    hashed = hashed * 31 + str.charCodeAt(ii) | 0;
  }

  return smi(hashed);
}
/**
 * @param n
 */


function hashNumber(n) {
  if (!isFinite(n)) {
    return 0;
  }

  let hash = n | 0;

  if (hash !== n) {
    hash ^= n * 0xffffffff;
  }

  while (n > 0xffffffff) {
    // eslint-disable-next-line no-param-reassign
    n /= 0xffffffff;
    hash ^= n;
  }

  return smi(hash);
}
/**
 * retain 30 bits of number
 *
 * @param value
 */


function smi(value) {
  return value & 0x3fffffff;
}

class Uid {
  constructor() {
    this.id = 0;
  }

  take() {
    this.id += 1;
    return this.id;
  }

  peek() {
    return this.id + 1;
  }

}

/* eslint-disable max-classes-per-file */
const uid$1 = new Uid();
class HashMap {
  get size() {
    return this.root.size;
  }
  /**
   * @param root
   * @internal
   */


  constructor(root) {
    this.id = uid$1.take();
    this.root = root;
  }

  static empty() {
    return HashMapBuilder.empty().finish();
  }

  static from(iterable) {
    return HashMapBuilder.from(iterable).finish();
  }

  get(key) {
    const h = hashing(key);
    return this.root.get(key, h, 0);
  }

  has(key) {
    const h = hashing(key);
    return this.root.contains(key, h, 0);
  }

  set(key, value) {
    return this.withRoot(this.root.insert(uid$1.peek(), key, value, hashing(key), 0));
  }

  update(key, updater) {
    return this.withRoot(this.root.update(uid$1.peek(), key, updater, hashing(key), 0));
  }

  delete(key) {
    const h = hashing(key);
    const id = uid$1.peek();
    const remove = this.root.remove(id, key, h, 0);
    return remove === undefined ? this : new HashMap(remove[0]);
  }

  clone() {
    return new HashMap(this.root);
  }

  [Symbol.iterator]() {
    return this.entries();
  }

  entries() {
    return this.root.iter();
  }

  values() {
    return new MapIterator(this.entries(), ([, v]) => v);
  }

  mutate() {
    return new HashMapBuilder(this.root);
  }

  map(f) {
    return new HashMap(this.root.map(uid$1.peek(), f));
  }

  filter(predicate) {
    const map = this.mutate();
    this.forEach((value, key) => {
      if (!predicate(value, key)) {
        map.delete(key);
      }
    });
    return map.finish();
  }

  forEach(f) {
    this.root.forEach(f);
  }

  find(predicate) {
    return this.root.find(predicate);
  }

  withRoot(newRoot) {
    return newRoot === this.root ? this : new HashMap(newRoot);
  }

}
class HashMapBuilder {
  /**
   * @param root
   * @internal
   */
  constructor(root) {
    this.id = uid$1.take();
    this.root = root;
  }

  static empty() {
    const id = uid$1.peek();
    const root = BitmapIndexedNode.empty(id);
    return new HashMapBuilder(root);
  }

  static from(iterable) {
    if (Array.isArray(iterable)) {
      return HashMapBuilder.fromArray(iterable);
    }

    const iter = iterable[Symbol.iterator]();
    const builder = HashMapBuilder.empty();
    let next = iter.next();

    while (!next.done) {
      const [key, value] = next.value;
      builder.set(key, value);
      next = iter.next();
    }

    return builder;
  }

  static fromArray(list) {
    const builder = HashMapBuilder.empty(); // eslint-disable-next-line @typescript-eslint/prefer-for-of

    for (let i = 0; i < list.length; i += 1) {
      const [key, value] = list[i];
      builder.set(key, value);
    }

    return builder;
  }

  get(key) {
    const h = hashing(key);
    return this.root.get(key, h, 0);
  }

  has(key) {
    const h = hashing(key);
    return this.root.contains(key, h, 0);
  }

  set(key, value) {
    this.root = this.root.insert(this.id, key, value, hashing(key), 0);
    return this;
  }

  update(key, updater) {
    const h = hashing(key);
    this.root = this.root.update(this.id, key, updater, h, 0);
    return this;
  }

  delete(key) {
    const h = hashing(key);
    const remove = this.root.remove(this.id, key, h, 0);

    if (remove !== undefined) {
      this.root = remove[0];
    }

    return this;
  }

  finish() {
    return new HashMap(this.root);
  }

}

var NodeType;

(function (NodeType) {
  NodeType[NodeType["Internal"] = 0] = "Internal";
  NodeType[NodeType["Leaf"] = 1] = "Leaf";
})(NodeType || (NodeType = {}));

const MAX_SIZE = 31;
const MIN_SIZE = 15;
const HALF_NODE_SPLIT = 7;
/**
 * @param list
 * @param key
 */

function binaryFind(list, key) {
  let start = 0;
  let end = list.length; // eslint-disable-next-line no-constant-condition

  while (true) {
    if (start + 1 === end) {
      return list[start] >= key ? start : end;
    }

    const mid = start + end >>> 1;

    if (list[mid] === key) {
      return mid;
    }

    if (key < list[mid]) {
      end = mid;
    } else {
      start = mid;
    }
  }
}
class InternalNode {
  get selfSize() {
    return this.keys.length;
  }

  constructor(owner, keys, values, children, size) {
    this.type = NodeType.Internal;
    this.owner = owner;
    this.keys = keys;
    this.values = values;
    this.children = children;
    this.size = size;
  }

  iter() {
    return new BTreeIterator(this);
  }

  toOwned(owner) {
    return this.owner === owner ? this : new InternalNode(owner, this.keys.slice(), this.values.slice(), this.children.slice(), this.size);
  }

  getKey(index) {
    return this.keys[index];
  }

  getValue(index) {
    return this.values[index];
  }

  getChild(index) {
    return this.children[index];
  }

  get(key) {
    const size = this.selfSize;
    const index = binaryFind(this.keys, key);

    if (index !== size) {
      const key0 = this.getKey(index);

      if (key0 === key) {
        return this.getValue(index);
      }
    }

    return this.getChild(index).get(key);
  }

  contains(key) {
    const size = this.selfSize;
    const index = binaryFind(this.keys, key);

    if (index !== size) {
      const key0 = this.getKey(index);

      if (key0 === key) {
        return true;
      }
    }

    return this.getChild(index).contains(key);
  }

  insert(owner, key, value) {
    const size = this.selfSize;
    const index = binaryFind(this.keys, key);
    const key0 = this.getKey(index);
    const value0 = this.getValue(index);

    if (key0 === key) {
      if (is$1(value0, value)) {
        return [this];
      }

      const next = this.toOwned(owner);
      next.values[index] = value;
      return [next];
    } else {
      const child0 = this.getChild(index);
      const insert = child0.insert(owner, key, value);

      if (insert.length === 1) {
        const child = insert[0];

        if (child === child0) {
          return [this];
        }

        const next = this.toOwned(owner);
        next.children[index] = child;
        return [next];
      } else if (size === MAX_SIZE) {
        return this.updateWithSplit(owner, insert[0], insert[1], insert[2], insert[3], index);
      } else {
        const next = this.toOwned(owner);
        next.keys.splice(index, 0, insert[2]);
        next.values.splice(index, 0, insert[3]);
        next.children.splice(index, 1, insert[0], insert[1]);
        next.size += 1;
        return [next];
      }
    }
  }

  update(owner, key, updater) {
    const index = binaryFind(this.keys, key);
    const key0 = this.getKey(index);
    const value0 = this.getValue(index);

    if (key0 === key) {
      const value = updater(value0);

      if (is$1(value0, value)) {
        return this;
      }

      const next = this.toOwned(owner);
      next.values[index] = value;
      return next;
    } else {
      const child0 = this.getChild(index);
      const child = child0.update(owner, key, updater);

      if (child === child0) {
        return this;
      }

      const next = this.toOwned(owner);
      next.children[index] = child;
      return next;
    }
  }

  remove(owner, key) {
    const index = binaryFind(this.keys, key);
    const size = this.selfSize;
    const child0 = this.getChild(index);
    const originalSize = child0.size;
    const key0 = this.getKey(index);

    if (key0 === key) {
      const [removedKey, value, child] = child0.removeMostRight(owner);
      const next = this.toOwned(owner);
      next.size -= 1;
      next.keys[index] = removedKey;
      next.values[index] = value;
      next.children[index] = child;
      return next.balanceChild(owner, child, removedKey, value, index);
    } else {
      const child = child0.remove(owner, key);

      if (child.size === originalSize) {
        return this;
      }

      const next = this.toOwned(owner);
      next.size -= 1;
      next.children[index] = child;

      if (child.selfSize >= MIN_SIZE) {
        return next;
      }

      if (index === size) {
        next.balanceTail(child);
        return next;
      }

      const value0 = this.getValue(index);
      return next.balanceChild(owner, child, key0, value0, index);
    }
  }

  removeMostRight(owner) {
    const size = this.selfSize;
    const [key, value, child] = this.getChild(size).removeMostRight(owner);
    const next = this.toOwned(owner);
    next.size -= 1;
    next.children[size] = child;

    if (child.selfSize < MIN_SIZE) {
      next.balanceTail(child);
    }

    return [key, value, next];
  }

  map(owner, f) {
    const values = [];
    const children = [];
    let same = true;

    for (let i = 0; i < this.keys.length; i += 1) {
      const key = this.getKey(i);
      const value0 = this.getValue(i);
      const value = f(value0, key);
      values.push(value);
      same = same && is$1(value0, value);
    }

    for (let i = 0; i < this.children.length; i += 1) {
      const child0 = this.getChild(i);
      const child = child0.map(owner, f);
      children.push(child);
      same = same && child0 === child;
    }

    return same ? this : new InternalNode(owner, this.keys, values, children, this.size);
  }

  forEach(f) {
    for (let i = 0; i < this.keys.length; i += 1) {
      const key = this.getKey(i);
      const value = this.getValue(i);
      f(value, key);
    }

    for (let i = 0; i < this.children.length; i += 1) {
      const child = this.getChild(i);
      child.forEach(f);
    }
  }

  find(predicate) {
    for (let i = 0; i < this.keys.length; i += 1) {
      const value = this.getValue(i);

      if (predicate(value)) {
        return value;
      }
    }

    for (let i = 0; i < this.children.length; i += 1) {
      const child = this.getChild(i);
      const found = child.find(predicate);

      if (found) {
        return found;
      }
    }

    return undefined;
  }

  balanceChild(owner, child, key0, value0, index) {
    if (index === 0) {
      this.balanceHead(child);
      return this;
    }

    const isChildInternal = child.type === NodeType.Internal;
    const left0 = this.getChild(index - 1);
    const right0 = this.getChild(index + 1);

    if (left0.selfSize > MIN_SIZE) {
      this.rotateRight(child, left0, index, isChildInternal);
    } else if (right0.selfSize > MIN_SIZE) {
      this.rotateLeft(child, right0, index, isChildInternal);
    } else {
      const left = left0.toOwned(owner);
      const right = right0.toOwned(owner);
      const key = child.getKey(HALF_NODE_SPLIT);
      const value = child.getValue(HALF_NODE_SPLIT);
      left.keys.push(this.getKey(index - 1));
      left.values.push(this.getValue(index - 1));
      left.keys.push(...child.keys.slice(0, HALF_NODE_SPLIT));
      left.values.push(...child.values.slice(0, HALF_NODE_SPLIT));
      right.keys.unshift(key0);
      right.values.unshift(value0);
      right.keys.unshift(...child.keys.slice(HALF_NODE_SPLIT + 1, MIN_SIZE));
      right.values.unshift(...child.values.slice(HALF_NODE_SPLIT + 1, MIN_SIZE));
      this.keys.splice(index - 1, 2, key);
      this.values.splice(index - 1, 2, value);
      this.children.splice(index - 1, 3, left, right);

      if (isChildInternal) {
        left.children.push(...child.children.slice(0, HALF_NODE_SPLIT + 1));
        right.children.unshift(...child.children.slice(HALF_NODE_SPLIT + 1, MIN_SIZE + 1));
        left.updateSize();
        right.updateSize();
      }
    }

    return this;
  }

  rotateLeft(child, right0, index, isChildInternal) {
    const right = right0.toOwned(this.owner);
    const newKey = right.keys.shift();
    const newValue = right.values.shift();
    const key0 = this.getKey(index);
    const value0 = this.getValue(index);
    child.keys.push(key0);
    child.values.push(value0);
    this.keys[index] = newKey;
    this.values[index] = newValue;
    this.children[index + 1] = right;

    if (isChildInternal) {
      const grandChild = right.children.shift();
      child.children.push(grandChild);
      const delta = grandChild.size + 1;
      child.size += delta;
      right.size -= delta;
    }
  }

  rotateRight(child, left0, index, isChildInternal) {
    const left = left0.toOwned(this.owner);
    const newKey = left.keys.pop();
    const newValue = left.values.pop();
    const key0 = this.getKey(index - 1);
    const value0 = this.getValue(index - 1);
    child.keys.unshift(key0);
    child.values.unshift(value0);
    this.keys[index - 1] = newKey;
    this.values[index - 1] = newValue;
    this.children[index - 1] = left;

    if (isChildInternal) {
      const grandChild = left.children.pop();
      child.children.unshift(grandChild);
      const delta = grandChild.size + 1;
      child.size += delta;
      left.size -= delta;
    }
  }

  balanceTail(child) {
    const index = this.selfSize;
    const left0 = this.getChild(index - 1);
    const isChildInternal = child.type === NodeType.Internal;

    if (left0.selfSize === MIN_SIZE) {
      child.keys.unshift(this.getKey(index - 1));
      child.values.unshift(this.getValue(index - 1));
      child.keys.unshift(...left0.keys);
      child.values.unshift(...left0.values);
      this.keys.splice(index - 1, 1);
      this.values.splice(index - 1, 1);
      this.children.splice(index - 1, 1);

      if (isChildInternal) {
        child.children.unshift(...left0.children); // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion

        child.size += left0.size + 1;
      }
    } else {
      this.rotateRight(child, left0, index, isChildInternal);
    }
  }

  balanceHead(child) {
    const right0 = this.getChild(1);
    const isChildInternal = child.type === NodeType.Internal;

    if (right0.selfSize === MIN_SIZE) {
      child.keys.push(this.getKey(0));
      child.values.push(this.getValue(0));
      child.keys.push(...right0.keys);
      child.values.push(...right0.values);
      this.keys.splice(0, 1);
      this.values.splice(0, 1);
      this.children.splice(1, 1);

      if (isChildInternal) {
        child.children.push(...right0.children); // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion

        child.size += right0.size + 1;
      }
    } else {
      this.rotateLeft(child, right0, 0, isChildInternal);
    }
  }

  updateWithSplit(owner, child1, child2, key, value, index) {
    const next1 = this.toOwned(owner);
    next1.keys.splice(index, 0, key);
    next1.values.splice(index, 0, value);
    next1.children.splice(index, 1, child1, child2);
    const next2 = new InternalNode(owner, next1.keys.splice(16, 16), next1.values.splice(16, 16), next1.children.splice(16, 17), 0);
    const nextKey = next1.keys.pop();
    const nextValue = next1.values.pop();
    next1.updateSize();
    next2.updateSize();
    return [next1, next2, nextKey, nextValue];
  }

  updateSize() {
    let sum = this.selfSize;
    const len = this.children.length;

    for (let i = 0; i < len; i += 1) {
      sum += this.children[i].size;
    }

    this.size = sum;
  }

}
class LeafNode {
  get size() {
    return this.keys.length;
  }

  get selfSize() {
    return this.size;
  }

  constructor(owner, keys, values) {
    this.type = NodeType.Leaf;
    this.owner = owner;
    this.keys = keys;
    this.values = values;
  }

  toOwned(owner) {
    return this.owner === owner ? this : new LeafNode(owner, this.keys.slice(), this.values.slice());
  }

  getKey(index) {
    return this.keys[index];
  }

  getValue(index) {
    return this.values[index];
  }

  get(key) {
    const size = this.selfSize;
    const index = binaryFind(this.keys, key);

    if (index !== size) {
      const key0 = this.getKey(index);
      return key0 === key ? this.getValue(index) : undefined;
    }

    return undefined;
  }

  contains(key) {
    const size = this.selfSize;
    const index = binaryFind(this.keys, key);

    if (index !== size) {
      const key0 = this.getKey(index);
      return key0 === key;
    }

    return false;
  }

  insert(owner, key, value) {
    const size = this.selfSize;
    const index = binaryFind(this.keys, key);
    const key0 = index === size ? undefined : this.getKey(index);

    if (key0 === key) {
      const value0 = this.getValue(index);

      if (is$1(value, value0)) {
        return [this];
      }

      const next = this.toOwned(owner);
      next.values[index] = value;
      return [next];
    } else {
      if (size === MAX_SIZE) {
        return this.updateWithSplit(owner, key, value, index);
      }

      const next = this.toOwned(owner);
      next.keys.splice(index, 0, key);
      next.values.splice(index, 0, value);
      return [next];
    }
  }

  update(owner, key, updater) {
    const size = this.selfSize;
    const index = binaryFind(this.keys, key);
    const key0 = index === size ? undefined : this.getKey(index);

    if (key0 === key) {
      const value0 = this.getValue(index);
      const value = updater(value0);

      if (is$1(value, value0)) {
        return this;
      }

      const next = this.toOwned(owner);
      next.values[index] = value;
      return next;
    }

    return this;
  }

  remove(owner, key) {
    const index = binaryFind(this.keys, key);
    const size = this.selfSize;

    if (index === size) {
      return this;
    }

    return this.removeIndex(owner, index);
  }

  removeMostRight(owner) {
    const index = this.selfSize - 1;
    const key = this.getKey(index);
    const value = this.getValue(index);
    const next = this.removeIndex(owner, index);
    return [key, value, next];
  }

  map(owner, f) {
    const values = [];
    let same = true;

    for (let i = 0; i < this.keys.length; i += 1) {
      const key = this.getKey(i);
      const value0 = this.getValue(i);
      const value = f(value0, key);
      values.push(value);
      same = same && is$1(value0, value);
    }

    return same ? this : new LeafNode(owner, this.keys, values);
  }

  forEach(f) {
    for (let i = 0; i < this.keys.length; i += 1) {
      const key = this.getKey(i);
      const value = this.getValue(i);
      f(value, key);
    }
  }

  find(predicate) {
    return this.values.find(predicate);
  }

  updateWithSplit(owner, key, value, index) {
    const next1 = this.toOwned(owner);
    next1.keys.splice(index, 0, key);
    next1.values.splice(index, 0, value);
    const next2 = new LeafNode(owner, next1.keys.splice(16, 16), next1.values.splice(16, 16));
    const nextKey = next1.keys.pop();
    const nextValue = next1.values.pop();
    return [next1, next2, nextKey, nextValue];
  }

  removeIndex(owner, index) {
    const next = this.toOwned(owner);
    next.keys.splice(index, 1);
    next.values.splice(index, 1);
    return next;
  }

}
/**
 * @param owner
 */

function emptyRoot(owner) {
  return new LeafNode(owner, [], []);
}
/**
 * @param owner
 * @param root
 * @param key
 * @param value
 */

function rootInsert(owner, root, key, value) {
  if (root.selfSize === 0) {
    return new LeafNode(owner, [key], [value]);
  }

  const insert = root.insert(owner, key, value);

  if (insert.length === 1) {
    return insert[0];
  }

  const [next1, next2, newKey, newValue] = insert;
  return new InternalNode(owner, [newKey], [newValue], [next1, next2], next1.size + next2.size + 1);
}
/**
 * @param owner
 * @param root
 * @param key
 */

function rootRemove(owner, root, key) {
  const newRoot = root.remove(owner, key);

  if (newRoot.type === NodeType.Internal && newRoot.selfSize === 0) {
    return newRoot.getChild(0);
  }

  return newRoot;
}
class BTreeIterator {
  constructor(node) {
    this.delegate = null;
    this.index = 0;
    this.done = false;
    this.node = node;
    this.setDelegate(this.index);
  }

  [Symbol.iterator]() {
    return this.clone();
  }

  next() {
    if (this.delegate === null) {
      return this.yieldValue();
    }

    const next = this.delegate.next();

    if (!next.done) {
      return {
        done: false,
        value: next.value
      };
    }

    const y = this.yieldValue();

    if (this.index <= this.node.selfSize) {
      this.setDelegate(this.index);
    } else {
      this.done = true;
      this.delegate = null;
    }

    return y;
  }

  clone() {
    const iter = new BTreeIterator(this.node);
    iter.delegate = this.delegate;
    iter.index = this.index;
    iter.done = this.done;
    return iter;
  }

  setDelegate(index) {
    if (this.node.type !== NodeType.Internal) {
      return;
    }

    const child = this.node.getChild(index);
    this.delegate = new BTreeIterator(child);
  }

  yieldValue() {
    if (!this.done && this.index < this.node.selfSize) {
      const key = this.node.getKey(this.index);
      const value = this.node.getValue(this.index);
      this.index += 1;
      return {
        done: false,
        value: [key, value]
      };
    }

    this.done = true;
    return {
      done: true,
      value: undefined
    };
  }

}

/* eslint-disable max-classes-per-file */
new Uid();

/* eslint-disable max-classes-per-file */
const uid = new Uid();
/**
 * preserve insertion order
 */

class OrderedMap {
  get size() {
    return this.hashRoot.size;
  }
  /**
   * @param itemId
   * @param hashRoot
   * @param sortedRoot
   * @param itemId
   * @param hashRoot
   * @param sortedRoot
   * @param itemId
   * @param hashRoot
   * @param sortedRoot
   * @internal
   */


  constructor(itemId, hashRoot, sortedRoot) {
    this.id = uid.take();
    this.itemId = itemId;
    this.hashRoot = hashRoot;
    this.sortedRoot = sortedRoot;
  }

  static empty() {
    return OrderedMapBuilder.empty().finish();
  }

  static from(iterable) {
    return OrderedMapBuilder.from(iterable).finish();
  }

  delete(key) {
    const tempId = uid.peek();
    const h = hashing(key);
    const remove = this.hashRoot.remove(tempId, key, h, 0);

    if (remove === undefined) {
      return this;
    }

    const [hashRoot, valueId] = remove;
    const sortedRoot = this.sortedRoot.remove(tempId, valueId);
    return new OrderedMap(this.itemId, hashRoot, sortedRoot);
  }

  get(key) {
    const h = hashing(key);
    const id = this.hashRoot.get(key, h, 0);

    if (id === undefined) {
      return undefined;
    }

    const got = this.sortedRoot.get(id);
    return got === null || got === void 0 ? void 0 : got[1];
  }

  has(key) {
    const h = hashing(key);
    return this.hashRoot.contains(key, h, 0);
  }

  set(key, value) {
    const temp = uid.peek();
    let itemId = this.hashRoot.get(key, hashing(key), 0);
    let hashRoot = this.hashRoot;

    if (!itemId) {
      itemId = this.itemId + 1;
      hashRoot = this.hashRoot.insert(temp, key, itemId, hashing(key), 0);
    }

    const sortedRoot = rootInsert(temp, this.sortedRoot, itemId, [key, value]);
    return this.withRoot(this.itemId + 1, hashRoot, sortedRoot);
  }

  update(key, updater) {
    const itemId = this.hashRoot.get(key, hashing(key), 0);

    if (!itemId) {
      return this;
    }

    const sortedRoot = this.sortedRoot.update(uid.peek(), itemId, prev => {
      const [prevKey, prevValue] = prev;
      const value = updater(prevValue);
      return is$1(value, prevValue) ? prev : [prevKey, value];
    });
    return this.withRoot(this.itemId, this.hashRoot, sortedRoot);
  }

  [Symbol.iterator]() {
    return this.entries();
  }

  clone() {
    return new OrderedMap(this.itemId, this.hashRoot, this.sortedRoot);
  }

  entries() {
    return new OrderedMapIterator(new BTreeIterator(this.sortedRoot));
  }

  values() {
    return new MapIterator(this.entries(), ([, v]) => v);
  }

  mutate() {
    return new OrderedMapBuilder(this.itemId, this.hashRoot, this.sortedRoot);
  }

  map(f) {
    const id = uid.peek();

    const g = prev => {
      const [key, value0] = prev;
      const value = f(value0, key);
      return is$1(value0, value) ? prev : [key, value];
    };

    const sortedRoot = this.sortedRoot.map(id, g);
    return new OrderedMap(this.itemId, this.hashRoot, sortedRoot);
  }

  forEach(f) {
    this.sortedRoot.forEach(([key, value]) => {
      f(value, key);
    });
  }

  find(predicate) {
    const found = this.sortedRoot.find(([, value]) => predicate(value));
    return found ? found[1] : undefined;
  }

  first() {
    const next = this.entries().next();

    if (next.done) {
      return undefined;
    }

    return next.value[1];
  }

  filter(predicate) {
    const map = this.mutate();
    this.forEach((value, key) => {
      if (!predicate(value, key)) {
        map.delete(key);
      }
    });
    return map.finish();
  }

  withRoot(itemId, hashRoot, sortedRoot) {
    return hashRoot === this.hashRoot && sortedRoot === this.sortedRoot ? this : new OrderedMap(itemId, hashRoot, sortedRoot);
  }

}
class OrderedMapIterator {
  /**
   * @param delegate
   * @internal
   */
  constructor(delegate) {
    this.delegate = delegate;
  }

  [Symbol.iterator]() {
    return this.clone();
  }

  next() {
    const next = this.delegate.next();

    if (next.done) {
      return {
        done: true,
        value: undefined
      };
    }

    return {
      done: false,
      value: next.value[1]
    };
  }

  clone() {
    return new OrderedMapIterator(this.delegate.clone());
  }

}
class OrderedMapBuilder {
  constructor(itemId, hashRoot, sortedRoot) {
    this.id = uid.take();
    this.itemId = itemId;
    this.hashRoot = hashRoot;
    this.sortedRoot = sortedRoot;
  }

  static empty() {
    const tempId = uid.peek();
    const hashRoot = BitmapIndexedNode.empty(tempId);
    const sortedRoot = emptyRoot(tempId);
    return new OrderedMapBuilder(0, hashRoot, sortedRoot);
  }

  static from(iterable) {
    if (Array.isArray(iterable)) {
      return OrderedMapBuilder.fromArray(iterable);
    }

    const builder = OrderedMapBuilder.empty();
    const iterator = iterable[Symbol.iterator]();
    let next = iterator.next();

    while (!next.done) {
      const [key, value] = next.value;
      builder.set(key, value);
      next = iterator.next();
    }

    return builder;
  }

  static fromArray(list) {
    const builder = OrderedMapBuilder.empty(); // eslint-disable-next-line @typescript-eslint/prefer-for-of

    for (let i = 0; i < list.length; i += 1) {
      const [key, value] = list[i];
      builder.set(key, value);
    }

    return builder;
  }

  delete(key) {
    const h = hashing(key);
    const remove = this.hashRoot.remove(this.id, key, h, 0);

    if (remove === undefined) {
      return this;
    }

    const id = remove[1];
    this.hashRoot = remove[0];
    this.sortedRoot = rootRemove(this.id, this.sortedRoot, id);
    return this;
  }

  get(key) {
    var _a;

    const h = hashing(key);
    const id = this.hashRoot.get(key, h, 0);

    if (id === undefined) {
      return undefined;
    }

    return (_a = this.sortedRoot.get(id)) === null || _a === void 0 ? void 0 : _a[1];
  }

  has(key) {
    const h = hashing(key);
    return this.hashRoot.contains(key, h, 0);
  }

  set(key, value) {
    let itemId = this.hashRoot.get(key, hashing(key), 0);

    if (itemId === undefined) {
      itemId = this.itemId + 1;
      this.itemId += 1;
      this.hashRoot = this.hashRoot.insert(this.id, key, itemId, hashing(key), 0);
    }

    this.sortedRoot = rootInsert(this.id, this.sortedRoot, itemId, [key, value]);
    return this;
  }

  update(key, updater) {
    const itemId = this.hashRoot.get(key, hashing(key), 0);

    if (!itemId) {
      return this;
    }

    this.sortedRoot = this.sortedRoot.update(this.id, itemId, prev => {
      const [prevKey, prevValue] = prev;
      const value = updater(prevValue);
      return is$1(value, prevValue) ? prev : [prevKey, value];
    });
    return this;
  }

  finish() {
    return new OrderedMap(this.itemId, this.hashRoot, this.sortedRoot);
  }

}

const getPortPosition = (node, port, nodeConfig) => {
  const width = getRectWidth(nodeConfig, node);
  const height = getRectHeight(nodeConfig, node);
  const xOffset = port.position ? port.position[0] * width : width * 0.5;
  const x = node.x + xOffset;
  const yOffset = port.position ? port.position[1] * height : height;
  const y = node.y + yOffset;
  return {
    x,
    y
  };
};
const getPortPositionByPortId = (node, portId, graphConfig) => {
  const nodeConfig = getNodeConfig(node, graphConfig);

  if (!nodeConfig) {
    return undefined;
  }

  const ports = node.ports || [];
  const port = ports.find(p => p.id === portId);

  if (!port) {
    Debug.warn(`invalid port id ${JSON.stringify(port)}`);
    return undefined;
  }

  return getPortPosition(node, port, nodeConfig);
};

const identical = data => data;

const isMobile = () => {
  const toMatch = [/Android/i, /webOS/i, /iPhone/i, /iPad/i, /iPod/i, /BlackBerry/i, /Windows Phone/i];
  return toMatch.some(toMatchItem => {
    return navigator.userAgent.match(toMatchItem);
  });
};
var BrowserType;

(function (BrowserType) {
  BrowserType["Unknown"] = "Unknown";
  BrowserType["Edge"] = "Edge";
  BrowserType["EdgeChromium"] = "EdgeChromium";
  BrowserType["Opera"] = "Opera";
  BrowserType["Chrome"] = "Chrome";
  BrowserType["IE"] = "IE";
  BrowserType["Firefox"] = "Firefox";
  BrowserType["Safari"] = "Safari";
  BrowserType["Electron"] = "Electron";
})(BrowserType || (BrowserType = {}));

const getBrowser = () => {
  const agent = navigator.userAgent.toLowerCase();

  if (agent.indexOf("electron") > -1) {
    return BrowserType.Electron; // UserAgent of electron is weird.
  }

  switch (true) {
    case agent.indexOf("edge") > -1:
      return BrowserType.Edge;

    case agent.indexOf("edg") > -1:
      return BrowserType.EdgeChromium;

    case agent.indexOf("opr") > -1 && !!window.opr:
      return BrowserType.Opera;

    case agent.indexOf("chrome") > -1 && !!window.chrome:
      return BrowserType.Chrome;

    case agent.indexOf("trident") > -1:
      return BrowserType.IE;

    case agent.indexOf("firefox") > -1:
      return BrowserType.Firefox;

    case agent.indexOf("safari") > -1:
      return BrowserType.Safari;

    default:
      return BrowserType.Unknown;
  }
};
const isSupported = () => {
  if (isMobile()) {
    return false;
  }

  const browser = getBrowser();
  const supported = [BrowserType.Chrome, BrowserType.EdgeChromium, BrowserType.Firefox, BrowserType.Safari, BrowserType.Electron];
  return supported.indexOf(browser) > -1;
};
const isMacOs = navigator.userAgent.includes("Macintosh");

const metaControl = e => isMacOs ? e.metaKey : e.ctrlKey;
const checkIsMultiSelect = e => e.shiftKey || metaControl(e);

/**
 * get transformed point
 * @param x
 * @param y
 * @param transformMatrix
 */
const transformPoint = (x, y, transformMatrix) => {
  return {
    x: transformMatrix[0] * x + transformMatrix[2] * y + transformMatrix[4],
    y: transformMatrix[1] * x + transformMatrix[3] * y + transformMatrix[5]
  };
};
/**
 * reverse of transformPoint
 * @param x
 * @param y
 * @param transformMatrix
 */

const reverseTransformPoint = (x, y, transformMatrix) => {
  const [t0, t1, t2, t3, t4, t5] = transformMatrix;
  return {
    x: ((x - t4) * t3 - (y - t5) * t2) / (t0 * t3 - t1 * t2),
    y: ((x - t4) * t1 - (y - t5) * t0) / (t1 * t2 - t0 * t3)
  };
};
const getPointDeltaByClientDelta = (x, y, transformMatrix) => {
  const [a, b, c, d] = transformMatrix;
  const realDx = d * x / (a * d - b * c) + c * y / (b * c - a * d);
  const realDy = b * x / (b * c - a * d) + a * y / (a * d - b * c);
  return {
    x: realDx,
    y: realDy
  };
};
const getClientDeltaByPointDelta = (x, y, transformMatrix) => {
  if (!transformMatrix) {
    return {
      x,
      y
    };
  }

  const [a, b, c, d] = transformMatrix;
  return transformPoint(x, y, [a, b, c, d, 0, 0]);
};
const getRealPointFromClientPoint = (clientX, clientY, viewport) => {
  const {
    rect
  } = viewport;
  const x = clientX - rect.left;
  const y = clientY - rect.top;
  return reverseTransformPoint(x, y, viewport.transformMatrix);
};
const getClientPointFromRealPoint = (realX, realY, viewport) => {
  const {
    x,
    y
  } = transformPoint(realX, realY, viewport.transformMatrix);
  const {
    rect
  } = viewport;
  return {
    x: x + rect.left,
    y: y + rect.top
  };
};
/**
 * get client point relative to container
 */

const getContainerClientPoint = (realX, realY, viewport) => {
  const client = getClientPointFromRealPoint(realX, realY, viewport);
  const {
    rect
  } = viewport;
  return {
    x: client.x - rect.left,
    y: client.y - rect.top
  };
};

/**
 * shallow copy to mark edge dirty, in order to trigger a re-render
 *
 * @param edges
 * @param id
 * @param edges
 * @param id
 */

function markEdgeDirty(edges, id) {
  edges.update(id, edge => edge.shallow());
}
const getNearestConnectablePort = params => {
  const {
    parentNode: node,
    clientX,
    clientY,
    graphConfig,
    viewport
  } = params;
  let minDistance = Infinity;
  let nearestPort;

  if (!node.ports) {
    return undefined;
  }

  const point = getRealPointFromClientPoint(clientX, clientY, viewport);
  node.ports.forEach(port => {
    if (isConnectable(graphConfig, Object.assign(Object.assign({}, params), {
      model: port
    }))) {
      const portPos = getPortPositionByPortId(node, port.id, graphConfig);

      if (!portPos) {
        return;
      }

      const diffX = point.x - portPos.x;
      const diffY = point.y - portPos.y;
      const distance = diffX * diffX + diffY * diffY;

      if (distance < minDistance) {
        minDistance = distance;
        nearestPort = port;
      }
    }
  });
  return nearestPort;
};
const isConnectable = (graphConfig, params) => {
  const portConfig = graphConfig.getPortConfig(params.model);
  return portConfig ? portConfig.getIsConnectable(params) : false;
};
/**
 * @param node
 */

function resetNodePortsState(node) {
  return node.updatePorts(updateStatus(replace(GraphPortStatus.Default)));
}
const filterSelectedItems = data => {
  const nodes = new Map();
  const edges = [];
  data.nodes.forEach(({
    inner
  }) => {
    if (isSelected(inner)) {
      nodes.set(inner.id, inner);
    }
  });
  data.edges.forEach(({
    inner
  }) => {
    if (isSelected(inner) || nodes.has(inner.source) && nodes.has(inner.target)) {
      edges.push(inner);
    }
  });
  return {
    nodes: Array.from(nodes.values()),
    edges
  };
};
const getNeighborPorts = (data, nodeId, portId) => {
  const neighbors = [];
  const edgesBySource = data.getEdgesBySource(nodeId, portId);
  const edgesByTarget = data.getEdgesByTarget(nodeId, portId);
  edgesBySource === null || edgesBySource === void 0 ? void 0 : edgesBySource.forEach(edgeId => {
    const edge = data.edges.get(edgeId);

    if (edge) {
      neighbors.push({
        nodeId: edge.target,
        portId: edge.targetPortId
      });
    }
  });
  edgesByTarget === null || edgesByTarget === void 0 ? void 0 : edgesByTarget.forEach(edgeId => {
    const edge = data.edges.get(edgeId);

    if (edge) {
      neighbors.push({
        nodeId: edge.source,
        portId: edge.sourcePortId
      });
    }
  });
  return neighbors;
};
const unSelectAllEntity = () => {
  return data => data.mapNodes(n => n.update(curNode => {
    var _a;

    const nextNode = Object.assign(Object.assign({}, curNode), {
      ports: (_a = curNode.ports) === null || _a === void 0 ? void 0 : _a.map(updateStatus(replace(GraphPortStatus.Default)))
    });
    return updateStatus(replace(GraphNodeStatus.Default))(nextNode);
  })).mapEdges(e => e.update(updateStatus(replace(GraphEdgeStatus.Default))));
};
const nodeSelection = (e, target) => {
  if (isNodeEditing(target)) {
    return identical;
  }

  const isMultiSelect = checkIsMultiSelect(e);

  if (isSelected(target) && !isMultiSelect) {
    return identical;
  }

  return data => {
    const predicate = isMultiSelect ? node => {
      if (node.id !== target.id) {
        return isSelected(node);
      } else if (e.button === MouseEventButton.Secondary) {
        return true;
      } else {
        // use target.state here which is node's original state before onNodeMouseDown
        return !isSelected(target);
      }
    } : node => node.id === target.id;
    return data.selectNodes(predicate, target.id);
  };
};
const getNodeAutomationId = node => {
  var _a;

  return `node-container-${(_a = node.name) !== null && _a !== void 0 ? _a : "unnamed"}-${node.id}`;
};
const getPortAutomationId = (port, parentNode) => {
  return `port-${parentNode.name}-${parentNode.id}-${port.name}-${port.id}`;
};
const getNodeUid = (graphId, node) => {
  return `node:${graphId}:${node.id}`;
};
const getPortUid = (graphId, node, port) => {
  return `port:${graphId}:${node.id}:${port.id}`;
};
const getEdgeUid = (graphId, edge) => {
  return `edge:${graphId}:${edge.id}`;
};

/* eslint-disable @typescript-eslint/ban-types */
/**
 * @param obj
 */

function preventSpread(obj) {
  Object.defineProperty(obj, "__preventSpread", {
    enumerable: true,
    configurable: false,

    get() {
      /**
       * silent warning if caused by browser extension, eg. react devtool
       * if this is caused by browser extension, document.currentScript is null
       */
      if (document.currentScript) {
        Debug.error(`${obj.constructor.name} is a class, which should not be used in the spread syntax or argument of Object.assign`);
      }

      return undefined;
    }

  });
}

class EdgeModel {
  get id() {
    return this.inner.id;
  }

  get automationId() {
    return this.inner.automationId;
  }

  get source() {
    return this.inner.source;
  }

  get target() {
    return this.inner.target;
  }

  get sourcePortId() {
    return this.inner.sourcePortId;
  }

  get targetPortId() {
    return this.inner.targetPortId;
  }

  get status() {
    return this.inner.status;
  }

  get data() {
    return this.inner.data;
  }

  constructor(edge) {
    this.inner = edge;
    preventSpread(this);
  }

  static fromJSON(inner) {
    return new EdgeModel(inner);
  }

  updateStatus(f) {
    return this.update(updateStatus(f));
  }

  update(f) {
    const edge = f(this.inner);
    return edge === this.inner ? this : new EdgeModel(edge);
  }
  /**
   * shallow copy the model
   * example usage: mark the edge is dirty and need a re-render
   *
   * @returns shallowed edge model
   */


  shallow() {
    return new EdgeModel(this.inner);
  }

  toJSON() {
    return this.inner;
  }

}

// accessing Object's static property is very slow in safari
const is = Object.is;

function mapCow(list, f) {
  const values = [];
  let same = true;

  for (let i = 0; i < list.length; i += 1) {
    const value0 = list[i];
    const value = f(value0, i);
    same = same && is(value0, value);
    values.push(value);
  }

  return same ? list : values;
}

class NodeModel {
  get id() {
    return this.inner.id;
  }

  get status() {
    return this.inner.status;
  }

  get ports() {
    return this.inner.ports;
  }

  get ariaLabel() {
    return this.inner.ariaLabel;
  }

  get name() {
    return this.inner.name;
  }

  get x() {
    return this.inner.x;
  }

  get y() {
    return this.inner.y;
  }

  get automationId() {
    return this.inner.automationId;
  }

  get isInSearchResults() {
    return this.inner.isInSearchResults;
  }

  get isCurrentSearchResult() {
    return this.inner.isCurrentSearchResult;
  }

  get data() {
    return this.inner.data;
  }

  get height() {
    return this.inner.height;
  }

  get width() {
    return this.inner.width;
  }

  get layer() {
    var _a;

    return (_a = this.inner.layer) !== null && _a !== void 0 ? _a : 0;
  }

  constructor(node, portPositionCache, prev, next) {
    this.inner = node;
    this.portPositionCache = portPositionCache;
    this.prev = prev;
    this.next = next;
    preventSpread(this);
  }

  static fromJSON(node, prev, next) {
    return new NodeModel(node, new Map(), prev, next);
  }

  getPort(id) {
    var _a;

    return (_a = this.ports) === null || _a === void 0 ? void 0 : _a.find(port => port.id === id);
  }

  link({
    prev,
    next
  }) {
    if (prev === this.prev && next === this.next) {
      return this;
    }

    return new NodeModel(this.inner, this.portPositionCache, prev !== null && prev !== void 0 ? prev : this.prev, next !== null && next !== void 0 ? next : this.next);
  }

  updateStatus(f) {
    return this.update(updateStatus(f));
  }

  update(f) {
    const node = f(this.inner);
    return node === this.inner ? this : new NodeModel(node, new Map(), this.prev, this.next);
  }

  updateData(f) {
    if (!this.data) {
      return this;
    }

    return this.update(inner => {
      const data = f(inner.data);

      if (data === inner.data) {
        return inner;
      }

      return Object.assign(Object.assign({}, inner), {
        data
      });
    });
  }

  getPortPosition(portId, graphConfig) {
    let point = this.portPositionCache.get(portId);

    if (!point) {
      point = getPortPositionByPortId(this.inner, portId, graphConfig);
      this.portPositionCache.set(portId, point);
    }

    return point;
  }

  hasPort(id) {
    var _a;

    return Boolean((_a = this.inner.ports) === null || _a === void 0 ? void 0 : _a.find(port => port.id === id));
  }
  /**
   * @internal
   */


  updatePositionAndSize(dummy) {
    const {
      x,
      y,
      width,
      height
    } = dummy;
    const node = Object.assign(Object.assign({}, this.inner), {
      x,
      y,
      width: width !== null && width !== void 0 ? width : this.inner.width,
      height: height !== null && height !== void 0 ? height : this.inner.height
    });
    return new NodeModel(node, new Map(), this.prev, this.next);
  }

  updatePorts(f) {
    if (!this.inner.ports) {
      return this;
    }

    const ports = mapCow(this.inner.ports, f);
    const node = this.inner.ports === ports ? this.inner : Object.assign(Object.assign({}, this.inner), {
      ports
    });
    return node === this.inner ? this : new NodeModel(node, new Map(), this.prev, this.next);
  }

  invalidCache() {
    return new NodeModel(this.inner, new Map(), this.prev, this.next);
  }

  toJSON() {
    return this.inner;
  }

}

/**
 * Things preferred to be implemented as methods here:
 * * widely shared functions, eg. `updateNode`
 * * including multiple operations that must happen atomically
 * * improve performance by internal mutability
 */

class GraphModel {
  constructor(init) {
    this.nodes = init.nodes;
    this.edges = init.edges;
    this.groups = init.groups;
    this.head = init.head;
    this.tail = init.tail;
    this.edgesBySource = init.edgesBySource;
    this.edgesByTarget = init.edgesByTarget;
    this.selectedNodes = init.selectedNodes;
    preventSpread(this);
  }

  static empty() {
    return new GraphModel({
      nodes: OrderedMap.empty(),
      edges: HashMap.empty(),
      groups: [],
      head: undefined,
      tail: undefined,
      edgesBySource: HashMap.empty(),
      edgesByTarget: HashMap.empty(),
      selectedNodes: new Set()
    });
  }

  static fromJSON(init) {
    var _a;

    const nodes = OrderedMap.empty().mutate();
    const edges = HashMap.empty().mutate();
    let head;
    let tail;

    if (init.nodes.length === 0) {
      head = undefined;
      tail = undefined;
    } else if (init.nodes.length === 1) {
      const node = init.nodes[0];
      nodes.set(node.id, NodeModel.fromJSON(node, undefined, undefined));
      head = node.id;
      tail = node.id;
    } else {
      const first = init.nodes[0];
      const second = init.nodes[1];
      const last = init.nodes[init.nodes.length - 1];
      head = first.id;
      tail = last.id;
      nodes.set(first.id, NodeModel.fromJSON(first, undefined, second.id));
      let prev = init.nodes[0];

      if (init.nodes.length > 2) {
        for (let i = 1; i < init.nodes.length - 1; i += 1) {
          const node = init.nodes[i];
          const next = init.nodes[i + 1];
          nodes.set(node.id, NodeModel.fromJSON(node, prev.id, next.id));
          prev = node;
        }
      }

      nodes.set(last.id, NodeModel.fromJSON(last, prev.id, undefined));
    }

    const edgesBySource = HashMapBuilder.empty();
    const edgesByTarget = HashMapBuilder.empty();

    for (const edge of init.edges) {
      edges.set(edge.id, EdgeModel.fromJSON(edge));
      setEdgeByPortMutable(edgesBySource, edge.id, edge.source, edge.sourcePortId);
      setEdgeByPortMutable(edgesByTarget, edge.id, edge.target, edge.targetPortId);
    }

    return new GraphModel({
      nodes: nodes.finish(),
      edges: edges.finish(),
      groups: (_a = init.groups) !== null && _a !== void 0 ? _a : [],
      head,
      tail,
      edgesBySource: edgesBySource.finish(),
      edgesByTarget: edgesByTarget.finish(),
      selectedNodes: new Set()
    });
  }

  getNavigationFirstNode() {
    if (this.head === undefined) {
      return undefined;
    }

    return this.nodes.get(this.head);
  }

  updateNode(id, f) {
    var _a, _b;

    const nodes = this.nodes.update(id, node => node.update(f));

    if (nodes === this.nodes) {
      return this;
    }

    const edges = this.edges.mutate();
    (_a = this.edgesBySource.get(id)) === null || _a === void 0 ? void 0 : _a.forEach(edgeIds => {
      edgeIds.forEach(edgeId => {
        markEdgeDirty(edges, edgeId);
      });
    });
    (_b = this.edgesByTarget.get(id)) === null || _b === void 0 ? void 0 : _b.forEach(edgeIds => {
      edgeIds.forEach(edgeId => {
        markEdgeDirty(edges, edgeId);
      });
    });
    return this.merge({
      nodes,
      edges: edges.finish()
    });
  }

  updateNodeData(id, f) {
    return this.merge({
      nodes: this.nodes.update(id, node => node.updateData(f))
    });
  }

  updatePort(nodeId, portId, f) {
    const nodes = this.nodes.update(nodeId, node => node.updatePorts(port => port.id === portId ? f(port) : port));
    return this.merge({
      nodes
    });
  }

  insertNode(node) {
    const nodes = this.nodes.mutate().set(node.id, NodeModel.fromJSON(node, this.tail, undefined));

    if (this.tail && !this.nodes.has(node.id)) {
      nodes.update(this.tail, tail => tail.link({
        next: node.id
      }));
    }

    return this.merge({
      nodes: nodes.finish(),
      head: this.nodes.size === 0 ? node.id : this.head,
      tail: node.id
    });
  }

  deleteItems(predicate) {
    var _a;

    const deleted = new Set();
    const nodes = this.nodes.mutate();
    let first = this.head === undefined ? undefined : this.nodes.get(this.head);
    let node = first;
    let prev;
    const edgesBySource = this.edgesBySource.mutate();
    const edgesByTarget = this.edgesByTarget.mutate();

    while (node !== undefined) {
      const next = node.next ? this.nodes.get(node.next) : undefined;

      if (!((_a = predicate.node) === null || _a === void 0 ? void 0 : _a.call(predicate, node.inner))) {
        nodes.delete(node.id);
        edgesBySource.delete(node.id);
        edgesByTarget.delete(node.id);
        deleted.add(node.id);

        if (prev) {
          nodes.update(prev.id, prevNode => prevNode.link({
            next: node === null || node === void 0 ? void 0 : node.next
          }));
        }

        if (next) {
          nodes.update(next.id, nextNode => nextNode.link({
            prev: prev === null || prev === void 0 ? void 0 : prev.id
          }));
        }

        if (node === first) {
          first = next;
        }
      } else {
        nodes.update(node.id, current => current.link({
          prev: prev === null || prev === void 0 ? void 0 : prev.id
        }).update(n => {
          if (has(GraphNodeStatus.Editing)(n.status)) {
            return n;
          }

          return Object.assign(Object.assign({}, n), {
            status: GraphNodeStatus.Default
          });
        }));
        prev = node;
      }

      node = next;
    }

    const edges = this.edges.mutate();
    this.edges.forEach(edge => {
      var _a, _b;

      if (!deleted.has(edge.source) && !deleted.has(edge.target) && ((_b = (_a = predicate.edge) === null || _a === void 0 ? void 0 : _a.call(predicate, edge)) !== null && _b !== void 0 ? _b : true)) {
        edges.update(edge.id, e => e.update(updateStatus(replace(GraphEdgeStatus.Default))));
      } else {
        edges.delete(edge.id);
        deleteEdgeByPort(edgesBySource, edge.id, edge.source, edge.sourcePortId);
        deleteEdgeByPort(edgesByTarget, edge.id, edge.target, edge.targetPortId);
      }
    });
    return this.merge({
      nodes: nodes.finish(),
      edges: edges.finish(),
      head: first === null || first === void 0 ? void 0 : first.id,
      tail: prev === null || prev === void 0 ? void 0 : prev.id,
      edgesBySource: edgesBySource.finish(),
      edgesByTarget: edgesByTarget.finish()
    });
  }

  insertEdge(edge) {
    if (this.isEdgeExist(edge.source, edge.sourcePortId, edge.target, edge.targetPortId) || !this.nodes.has(edge.source) || !this.nodes.has(edge.target)) {
      return this;
    }

    const edgesBySource = setEdgeByPort(this.edgesBySource, edge.id, edge.source, edge.sourcePortId);
    const edgesByTarget = setEdgeByPort(this.edgesByTarget, edge.id, edge.target, edge.targetPortId);
    return this.merge({
      nodes: this.nodes.update(edge.source, node => node.invalidCache()).update(edge.target, node => node.invalidCache()),
      edges: this.edges.set(edge.id, EdgeModel.fromJSON(edge)).map(e => e.updateStatus(replace(GraphEdgeStatus.Default))),
      edgesBySource,
      edgesByTarget
    });
  }

  updateEdge(id, f) {
    return this.merge({
      edges: this.edges.update(id, e => e.update(f))
    });
  }

  deleteEdge(id) {
    const edge = this.edges.get(id);

    if (!edge) {
      return this;
    }

    return this.merge({
      edges: this.edges.delete(id),
      edgesBySource: deleteEdgeByPort(this.edgesBySource, edge.id, edge.source, edge.sourcePortId),
      edgesByTarget: deleteEdgeByPort(this.edgesByTarget, edge.id, edge.target, edge.targetPortId)
    });
  }
  /**
   * @internal
   */


  updateNodesPositionAndSize(dummies) {
    const updates = new Set();
    const nodes = this.nodes.mutate();
    const edges = this.edges.mutate();
    dummies.forEach(dummy => {
      var _a, _b;

      updates.add(dummy.id);
      nodes.update(dummy.id, node => node.updatePositionAndSize(dummy));
      (_a = this.edgesBySource.get(dummy.id)) === null || _a === void 0 ? void 0 : _a.forEach(ids => {
        ids.forEach(id => {
          markEdgeDirty(edges, id);
        });
      });
      (_b = this.edgesByTarget.get(dummy.id)) === null || _b === void 0 ? void 0 : _b.forEach(ids => {
        ids.forEach(id => {
          markEdgeDirty(edges, id);
        });
      });
    });
    return this.merge({
      nodes: nodes.finish(),
      edges: edges.finish()
    });
  }

  mapNodes(f) {
    return this.merge({
      nodes: this.nodes.map(f)
    });
  }

  mapEdges(f) {
    return this.merge({
      edges: this.edges.map(f)
    });
  }

  selectNodes(predicate, topNode) {
    const selected = new Set();
    const nodes = this.nodes.map(node => {
      const isNodeSelected = predicate(node.inner);

      if (isNodeSelected) {
        selected.add(node.id);
      }

      return node.updatePorts(updateStatus(replace(GraphPortStatus.Default))).updateStatus(resetConnectStatus(isNodeSelected ? GraphNodeStatus.Selected : GraphNodeStatus.UnconnectedToSelected));
    }).mutate();

    if (selected.size === 0) {
      this.nodes.forEach(n => nodes.update(n.id, it => it.updateStatus(replace(GraphNodeStatus.Default))));
    } else if (topNode) {
      const n = nodes.get(topNode);

      if (n) {
        nodes.delete(topNode);
        nodes.set(n.id, n);
      }
    }

    const setConnected = id => {
      nodes.update(id, node => node.updateStatus(replace(isSelected(node) ? GraphNodeStatus.Selected : GraphNodeStatus.ConnectedToSelected)));
    };

    const edges = selected.size ? this.edges.map(edge => {
      let state = GraphEdgeStatus.UnconnectedToSelected;

      if (selected.has(edge.source)) {
        setConnected(edge.target);
        state = GraphEdgeStatus.ConnectedToSelected;
      }

      if (selected.has(edge.target)) {
        setConnected(edge.source);
        state = GraphEdgeStatus.ConnectedToSelected;
      }

      return edge.updateStatus(replace(state));
    }) : this.edges.map(edge => edge.updateStatus(replace(GraphEdgeStatus.Default)));
    return this.merge({
      nodes: nodes.finish(),
      edges,
      selectedNodes: selected
    });
  }

  getEdgesBySource(nodeId, portId) {
    var _a;

    return (_a = this.edgesBySource.get(nodeId)) === null || _a === void 0 ? void 0 : _a.get(portId);
  }

  getEdgesByTarget(nodeId, portId) {
    var _a;

    return (_a = this.edgesByTarget.get(nodeId)) === null || _a === void 0 ? void 0 : _a.get(portId);
  }

  isPortConnectedAsSource(nodeId, portId) {
    var _a, _b;

    return ((_b = (_a = this.getEdgesBySource(nodeId, portId)) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0) > 0;
  }

  isPortConnectedAsTarget(nodeId, portId) {
    var _a, _b;

    return ((_b = (_a = this.getEdgesByTarget(nodeId, portId)) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0) > 0;
  }

  shallow() {
    return this.merge({});
  }

  toJSON() {
    const nodes = [];
    let current = this.head && this.nodes.get(this.head);

    while (current) {
      nodes.push(current.inner);
      current = current.next && this.nodes.get(current.next);
    }

    const edges = Array.from(this.edges.values()).map(it => it.inner);
    return {
      nodes,
      edges
    };
  }

  isEdgeExist(source, sourcePortId, target, targetPortId) {
    const sources = this.getEdgesBySource(source, sourcePortId);
    const targets = this.getEdgesByTarget(target, targetPortId);

    if (!sources || !targets) {
      return false;
    }

    let exist = false;
    sources.forEach(id => {
      if (targets.has(id)) {
        exist = true;
      }
    });
    return exist;
  }

  merge(partial) {
    var _a, _b, _c, _d, _e, _f, _g, _h;

    return new GraphModel({
      nodes: (_a = partial.nodes) !== null && _a !== void 0 ? _a : this.nodes,
      edges: (_b = partial.edges) !== null && _b !== void 0 ? _b : this.edges,
      groups: (_c = partial.groups) !== null && _c !== void 0 ? _c : this.groups,
      head: (_d = partial.head) !== null && _d !== void 0 ? _d : this.head,
      tail: (_e = partial.tail) !== null && _e !== void 0 ? _e : this.tail,
      edgesBySource: (_f = partial.edgesBySource) !== null && _f !== void 0 ? _f : this.edgesBySource,
      edgesByTarget: (_g = partial.edgesByTarget) !== null && _g !== void 0 ? _g : this.edgesByTarget,
      selectedNodes: (_h = partial.selectedNodes) !== null && _h !== void 0 ? _h : this.selectedNodes
    });
  }

}
/**
 * @param edgesByPort
 * @param edgeId
 * @param nodeId
 * @param portId
 */

function setEdgeByPort(edgesByPort, edgeId, nodeId, portId) {
  return edgesByPort.has(nodeId) ? edgesByPort.update(nodeId, map => {
    const edges = map.get(portId);
    return new Map(map).set(portId, (edges ? new Set(edges) : new Set()).add(edgeId));
  }) : edgesByPort.set(nodeId, new Map([[portId, new Set([edgeId])]]));
}
/**
 * @param edgesByPort
 * @param edgeId
 * @param nodeId
 * @param portId
 */


function setEdgeByPortMutable(edgesByPort, edgeId, nodeId, portId) {
  if (edgesByPort.has(nodeId)) {
    edgesByPort.update(nodeId, map => {
      let set = map.get(portId);

      if (!set) {
        set = new Set();
        map.set(portId, set);
      }

      set.add(edgeId);
      return map;
    });
  } else {
    edgesByPort.set(nodeId, new Map([[portId, new Set([edgeId])]]));
  }
}
/**
 * @param edgesByPort
 * @param edgeId
 * @param nodeId
 * @param portId
 */


function deleteEdgeByPort(edgesByPort, edgeId, nodeId, portId) {
  if (!edgesByPort.has(nodeId)) {
    return edgesByPort;
  }

  return edgesByPort.update(nodeId, edgeByPortsMap => {
    const edgeIds = edgeByPortsMap.get(portId);

    if (!edgeIds) {
      return edgeByPortsMap;
    }

    const set = new Set(edgeIds);
    set.delete(edgeId);
    return new Map(edgeByPortsMap).set(portId, set);
  });
}

var CanvasMouseMode;

(function (CanvasMouseMode) {
  CanvasMouseMode["Pan"] = "Pan";
  CanvasMouseMode["Select"] = "Select";
})(CanvasMouseMode || (CanvasMouseMode = {}));

var GraphBehavior;

(function (GraphBehavior) {
  GraphBehavior["Default"] = "default";
  GraphBehavior["Dragging"] = "dragging";
  GraphBehavior["Panning"] = "panning";
  GraphBehavior["MultiSelect"] = "multiSelect";
  GraphBehavior["Connecting"] = "connecting";
  GraphBehavior["AddingNode"] = "addingNode";
})(GraphBehavior || (GraphBehavior = {}));

/**
 * @param a
 * @param b
 */
function arrayEquals(a, b) {
  if (a.length !== b.length) {
    return false;
  } // eslint-disable-next-line no-plusplus


  for (let i = 0; i < a.length; i++) {
    if (!Object.is(a[i], b[i])) {
      return false;
    }
  }

  return true;
}

/**
 * @param min
 * @param max
 * @param value
 */
function clamp(min, max, value) {
  if (min > value) {
    return min;
  }

  if (max < value) {
    return max;
  }

  return value;
}

/**
 * @param v
 */
function isDef(v) {
  return v !== undefined && v !== null;
}

const debounce = (callback, timeout, options) => {
  const {
    instance,
    maxWait
  } = options || {};
  let timer = 0;
  let firstInvokeTime;
  return (...args) => {
    window.clearTimeout(timer);

    if (isDef(maxWait)) {
      const now = Date.now();

      if (!isDef(firstInvokeTime)) {
        firstInvokeTime = now;
      } else {
        if (now - firstInvokeTime >= maxWait) {
          firstInvokeTime = undefined;
          invokeCallback(args);
          return;
        }
      }
    }

    timer = window.setTimeout(() => {
      invokeCallback(args);
    }, timeout);
  };
  /**
   * @param args
   */

  function invokeCallback(args) {
    callback.apply(instance, args);
  }
};

const diffGraphEdge = (preData, data) => {
  const isAdded = data.edges.length > preData.edges.length;
  const larger = isAdded ? data : preData;
  const smaller = isAdded ? preData : data;
  const edgeIdSet = new Set();
  smaller.edges.forEach(n => edgeIdSet.add(n.id));
  const edges = larger.edges.filter(n => !edgeIdSet.has(n.id));
  return {
    isAdded,
    edges
  };
};

const diffGraphNode = (preData, data) => {
  const isAdded = data.nodes.length > preData.nodes.length;
  const larger = isAdded ? data : preData;
  const smaller = isAdded ? preData : data;
  const nodeIdSet = new Set();
  smaller.nodes.forEach(n => nodeIdSet.add(n.id));
  const nodes = larger.nodes.filter(n => !nodeIdSet.has(n.id));
  return {
    isAdded,
    nodes
  };
};

/**
 * one action can just add ports or remove ports,
 * can not add some ports meanwhile remove some ports
 */
const diffGraphPort = (preData, data) => {
  const prePortIdSet = new Set();
  const preNodes = new Map();
  const portIdSet = new Set();
  const nodes = new Map();
  const CONNECT = "--CONNECT--";
  preData.nodes.forEach(n => {
    preNodes.set(n.id, n);

    if (n.ports) {
      n.ports.forEach(p => prePortIdSet.add(`${n.id}${CONNECT}${p.id}`));
    }
  });
  data.nodes.forEach(n => {
    nodes.set(n.id, n);

    if (n.ports) {
      n.ports.forEach(p => portIdSet.add(`${n.id}${CONNECT}${p.id}`));
    }
  });
  const isAdded = portIdSet.size > prePortIdSet.size;
  const small = isAdded ? prePortIdSet : portIdSet;
  const large = isAdded ? portIdSet : prePortIdSet;
  const largeNodes = isAdded ? nodes : preNodes;
  const map = new Map();
  large.forEach(id => {
    var _a;

    if (!small.has(id)) {
      const [nodeId, portId] = id.split(CONNECT);
      const node = largeNodes.get(nodeId);

      if (node && node.ports) {
        if (!map.get(nodeId)) {
          map.set(nodeId, {
            node,
            ports: []
          });
        }

        const [port] = node.ports.filter(p => p.id === portId);
        (_a = map.get(nodeId)) === null || _a === void 0 ? void 0 : _a.ports.push(port);
      }
    }
  });
  const diffPorts = Array.from(map.values());
  return {
    isAdded,
    diffPorts
  };
};

const emptyArrayInstance = [];
/**
 *
 */

function constantEmptyArray() {
  return emptyArrayInstance;
}

function isEdgeEvent(event) {
  return event.type.startsWith("onEdge");
}
function isNodeEvent(event) {
  return event.type.startsWith("onNode");
}
function isPortEvent(event) {
  return event.type.startsWith("onPort");
}
function isCanvasEvent(event) {
  return event.type.startsWith("onCanvas");
}

/**
 * Critical path method
 */
let maxCost;
class Task {
  constructor(name, cost, dependencies) {
    // the earliest start
    this.earlyStart = 0; // the latest start

    this.latestStart = 0; // the latest finish

    this.latestFinish = 0; // the cost of the task along the critical path

    this.criticalCost = 0; // the tasks on which this task is dependant

    this.dependencies = new Set();
    this.name = name;
    this.cost = cost;
    dependencies === null || dependencies === void 0 ? void 0 : dependencies.forEach(t => {
      this.dependencies.add(t);
    });
    this.earlyFinish = -1;
  }

  isDependent(t) {
    if (this.dependencies.has(t)) {
      return true;
    }

    return Array.from(this.dependencies).some(dep => dep.isDependent(t));
  }

}
const criticalPath = tasks => {
  const completed = new Set();
  const remaining = new Set(tasks); // while there are tasks whose critical cost isn't calculated.

  while (remaining.size !== 0) {
    let progress = false; // find a new task to calculate

    remaining.forEach(task => {
      if (containAll(completed, task.dependencies)) {
        let critical = 0;
        task.dependencies.forEach(t => {
          if (t.criticalCost > critical) {
            critical = t.criticalCost;
          }
        });
        task.criticalCost = critical + task.cost;
        completed.add(task);
        remaining.delete(task);
        progress = true;
      }
    });

    if (!progress) {
      throw new Error("Cyclic dependency, algorithm stopped!");
    }
  }

  getMaxCost(tasks);
  calculateEarly(tasks); // get the tasks

  const ret = Array.from(completed);
  ret.sort((o1, o2) => {
    const i = o2.criticalCost - o1.criticalCost;

    if (i !== 0) {
      return i;
    }

    if (o1.isDependent(o2)) {
      return -1;
    }

    if (o2.isDependent(o1)) {
      return 1;
    }

    return 0;
  });
  return ret[0];
};

const setEarly = task => {
  const completionTime = task.earlyFinish;
  task.dependencies.forEach(t => {
    if (completionTime >= t.earlyStart) {
      t.earlyStart = completionTime;
      t.earlyFinish = completionTime + t.cost;
    }

    setEarly(t);
  });
};

const setLatest = task => {
  task.latestStart = maxCost - task.criticalCost;
  task.latestFinish = task.latestStart + task.cost;
};

const calculateEarly = tasks => {
  tasks.forEach(t => {
    t.earlyStart = 0;
    t.earlyFinish = t.cost;
    setEarly(t);
  });
};

const getMaxCost = tasks => {
  let max = -1;
  tasks.forEach(t => {
    if (t.criticalCost > max) {
      max = t.criticalCost;
    }
  });
  maxCost = max;
  tasks.forEach(t => {
    setLatest(t);
  });
};

const containAll = (AllItems, items) => {
  return Array.from(items).every(item => AllItems.has(item));
};

const getTopoSortingNodes = canvasData => {
  const {
    edges,
    nodes
  } = canvasData;

  if (!nodes.length) {
    return [];
  }

  if (!edges.length) {
    return [...nodes];
  }

  const edgesForTopo = edges.map(edge => [edge.source, edge.target]);
  const nodesForTopo = nodes.map(node => node.id);
  const orderOfNodeIds = toposort.array(nodesForTopo, edgesForTopo);
  const newNodes = [];
  orderOfNodeIds.forEach(id => {
    const node = nodes.find(it => it.id === id);

    if (node) {
      newNodes.push(node);
    }
  });
  return newNodes;
};

const getCriticalPath = (canvasData, durations, isNodesSorted) => {
  const {
    edges
  } = canvasData;
  const nodesSorted = isNodesSorted ? [...canvasData.nodes] : getTopoSortingNodes(canvasData);
  const allTasks = new Set();
  const curAllTasksMap = new Map();
  nodesSorted.reverse().forEach(node => {
    allTasks === null || allTasks === void 0 ? void 0 : allTasks.forEach(t => {
      if (!curAllTasksMap.has(t.name)) {
        curAllTasksMap.set(t.name, t);
      }
    });
    const task = new Task(node.id, durations.get(node.id) || 0, getSuccessors(node.id, edges, curAllTasksMap));
    allTasks.add(task);
  });
  const path = criticalPath(allTasks);
  const result = new Map();
  markCriticalPath(path, result, true);
  return result;
};
const markCriticalPath = (path, ret, isCritical = true, parentTask) => {
  var _a; // set as critical, only if it's parent task is in the critical path


  if (isCritical && (!parentTask || ((_a = ret.get(parentTask.name)) === null || _a === void 0 ? void 0 : _a.isCritical))) {
    ret.set(path.name, {
      task: path,
      isCritical
    });
  } else if (!ret.has(path.name)) {
    ret.set(path.name, {
      task: path,
      isCritical: false
    });
  }

  const {
    dependencies
  } = path;

  if (dependencies.size) {
    const criticalCostTask = getMaxCriticalCostTask(path.dependencies);
    markCriticalPath(criticalCostTask, ret, true, path);
    dependencies.forEach(t => {
      if (criticalCostTask.name !== t.name) {
        markCriticalPath(t, ret, false, path);
      }
    });
  }
}; // get max "criticalCost" task among the dependencies

const getMaxCriticalCostTask = tasks => {
  let max = -Infinity;
  let criticalTask = tasks.values().next().value;
  tasks.forEach(t => {
    if (t.criticalCost > max) {
      max = t.criticalCost;
      criticalTask = t;
    }
  });
  return criticalTask;
}; // get successor dependencies


const getSuccessors = (nodeId, edges, allTasksMap) => {
  const successors = new Set();
  edges.forEach(e => {
    if (nodeId === e.source) {
      const task = allTasksMap.get(e.target);

      if (task) {
        successors.add(task);
      }
    }
  });
  return successors;
};

const checkRectIntersect = (rectA, rectB) => {
  const isALeftOfB = rectA.maxX < rectB.minX;
  const isARightOfB = rectA.minX > rectB.maxX;
  const isABelowB = rectA.minY > rectB.maxY;
  const isAAboveB = rectA.maxY < rectB.minY;
  return !(isALeftOfB || isARightOfB || isABelowB || isAAboveB);
};
const isPointInRect = (rect, point) => {
  const {
    minX,
    minY,
    maxX,
    maxY
  } = rect;
  const {
    x,
    y
  } = point;
  return x > minX && x < maxX && y > minY && y < maxY;
};

const square = x => Math.pow(x, 2);

const distance = (x1, y1, x2, y2) => {
  return Math.sqrt(square(x2 - x1) + square(y2 - y1));
};
const getLinearFunction = (x1, y1, x2, y2) => {
  if (x1 === x2) {
    return () => Number.MAX_SAFE_INTEGER;
  }

  return x => (y2 - y1) / (x2 - x1) * x + (y1 * x2 - y2 * x1) / (x2 - x1);
};
/**
 * (y1 - y2) * x + (x2 - x1) * y + (x1 * y2 - x2 * y1) = 0
 * a = y1 - y2
 * b = -(x2 - x1) = x1 - x2
 * c = -(x1 * y2 - x2 * y1) = x2 * y1 - x1 * y2
 *
 * a * x - b * y = c
 * x = (b * y + c) / a
 * y = (a * x - c) / b
 */

class LinearEquation {
  constructor(x1, y1, x2, y2) {
    this.a = y1 - y2;
    this.b = x1 - x2;
    this.c = x2 * y1 - x1 * y2;
  }

  getX(y) {
    if (this.a === 0) {
      return undefined;
    }

    return (this.b * y + this.c) / this.a;
  }

  getY(x) {
    if (this.b === 0) {
      return undefined;
    }

    return (this.a * x - this.c) / this.b;
  }

}

/* eslint-disable @typescript-eslint/no-non-null-assertion */

const shallowEqual = (a, b) => {
  if (!a) {
    return false;
  }

  if (a.length !== b.length) {
    return false;
  }

  for (let i = 0; i < a.length; i += 1) {
    if (!is(a[i], b[i])) {
      return false;
    }
  }

  return true;
};

function memoize(f, selector) {
  let prev;
  let value;
  return (...args) => {
    const selectedArgs = selector ? Array.isArray(selector) ? selector : selector.apply(undefined, args) : args;

    if (shallowEqual(prev, selectedArgs)) {
      return value;
    }

    prev = selectedArgs;
    value = f.apply(undefined, args);
    return value;
  };
}

var Direction;

(function (Direction) {
  Direction[Direction["X"] = 0] = "X";
  Direction[Direction["Y"] = 1] = "Y";
  /**
   * zoom to fit in the X and Y directions, maybe the scaleX and the scaleY will different
   */

  Direction[Direction["XY"] = 2] = "XY";
})(Direction || (Direction = {}));

const isViewportComplete = viewport => {
  return !!viewport.rect;
};
const isViewportEmpty = viewport => {
  if (!isViewportComplete(viewport)) {
    return true;
  }

  return !viewport.rect.width || !viewport.rect.height;
};
const getNodeRect = (node, graphConfig) => {
  const {
    x,
    y
  } = node;
  const {
    width,
    height
  } = getNodeSize(node, graphConfig);
  return {
    x,
    y,
    width,
    height
  };
};
const isNodeVisible = (node, viewport, graphConfig) => {
  return isRectVisible(getNodeRect(node, graphConfig), viewport);
};
const isRectVisible = (shapeRect, viewport) => {
  const {
    x,
    y,
    width,
    height
  } = shapeRect;
  return isPointVisible({
    x,
    y
  }, viewport) || isPointVisible({
    x: x + width,
    y
  }, viewport) || isPointVisible({
    x: x + width,
    y: y + height
  }, viewport) || isPointVisible({
    x,
    y: y + height
  }, viewport);
};
const isPointVisible = (point, viewport) => {
  const {
    x,
    y
  } = getContainerClientPoint(point.x, point.y, viewport);
  const {
    height,
    width
  } = viewport.rect;
  return x > 0 && x < width && y > 0 && y < height;
};
const getVisibleNodes = (nodes, viewport, graphConfig) => {
  const result = [];
  nodes.forEach(n => {
    if (isNodeVisible(n, viewport, graphConfig)) {
      result.push(n.inner);
    }
  });
  return result;
}; // Get rendered nodes count

const getRenderedNodes = (nodes, viewport) => {
  const result = [];
  const renderedArea = getRenderedArea(viewport);
  nodes.forEach(n => {
    if (isNodeInRenderedArea(n, renderedArea)) {
      result.push(n.inner);
    }
  });
  return result;
};

const isNodeInRenderedArea = (node, renderedArea) => {
  return isPointInRect(renderedArea, node);
}; // Get rendered edges count


const getRenderedEdges = (edges, nodes, graphConfig, viewport) => {
  const result = [];
  const renderedArea = getRenderedArea(viewport);
  edges.forEach(e => {
    const edgeCoordinate = getEdgeSourceTargetCoordinate(e, nodes, graphConfig);

    if (edgeCoordinate.source && edgeCoordinate.target && isEdgeInRenderedArea(edgeCoordinate.source, edgeCoordinate.target, renderedArea)) {
      result.push(e.inner);
    }
  });
  return result;
};

const isEdgeInRenderedArea = (source, target, renderedArea) => {
  const isSourceVisible = isPointInRect(renderedArea, source);
  const isTargetVisible = isPointInRect(renderedArea, target);
  return isSourceVisible || isTargetVisible;
};

const getVisibleArea = viewport => {
  if (!isViewportComplete(viewport)) {
    return {
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0
    };
  }

  const {
    rect,
    transformMatrix
  } = viewport;
  const minX = 0;
  const minY = 0;
  const maxX = rect.width;
  const maxY = rect.height;
  const min = reverseTransformPoint(minX, minY, transformMatrix);
  const max = reverseTransformPoint(maxX, maxY, transformMatrix);
  return {
    minX: min.x,
    minY: min.y,
    maxX: max.x,
    maxY: max.y
  };
};
const getRenderedArea = viewport => {
  if (!isViewportComplete(viewport)) {
    return {
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0
    };
  }

  const {
    rect,
    transformMatrix
  } = viewport;
  const minX = 0;
  const minY = 0;
  const maxX = rect.width;
  const maxY = rect.height;
  const min = reverseTransformPoint(minX - rect.width, minY - rect.height, transformMatrix);
  const max = reverseTransformPoint(maxX + rect.width, maxY + rect.height, transformMatrix);
  return {
    minX: min.x,
    minY: min.y,
    maxX: max.x,
    maxY: max.y
  };
};
const getEdgeSourceTargetCoordinate = (edge, nodes, graphConfig) => {
  var _a, _b;

  return {
    source: (_a = nodes.get(edge.source)) === null || _a === void 0 ? void 0 : _a.getPortPosition(edge.sourcePortId, graphConfig),
    target: (_b = nodes.get(edge.target)) === null || _b === void 0 ? void 0 : _b.getPortPosition(edge.targetPortId, graphConfig)
  };
};

const normalizeSpacing = spacing => {
  if (!spacing) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  if (typeof spacing === "number") {
    return {
      top: spacing,
      right: spacing,
      bottom: spacing,
      left: spacing
    };
  }

  return Object.assign({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, spacing);
};
/**
 * zoom to [scale]
 */


const zoomTo = ({
  scale,
  anchor,
  direction,
  limitScale
}) => {
  return prevState => {
    const scaleX = limitScale(scale) / prevState.transformMatrix[0];
    const scaleY = limitScale(scale) / prevState.transformMatrix[3];
    const {
      x,
      y
    } = anchor;
    const dx = x * (1 - scaleX);
    const dy = y * (1 - scaleY);
    let transformMatrix;

    switch (direction) {
      case Direction.X:
        transformMatrix = [scale, 0, 0, prevState.transformMatrix[3], prevState.transformMatrix[4] * scaleX + dx, prevState.transformMatrix[5]];
        break;

      case Direction.Y:
        transformMatrix = [prevState.transformMatrix[0], 0, 0, scale, prevState.transformMatrix[4], prevState.transformMatrix[5] * scaleY + dy];
        break;

      case Direction.XY:
      default:
        transformMatrix = [scale, 0, 0, scale, prevState.transformMatrix[4] * scaleX + dx, prevState.transformMatrix[5] * scaleY + dy];
    }

    return Object.assign(Object.assign({}, prevState), {
      transformMatrix
    });
  };
};
const zoom = ({
  scale,
  anchor,
  direction,
  limitScale
}) => {
  if (scale === 1) {
    return identical;
  }

  return prevState => {
    let transformMatrix;

    switch (direction) {
      case Direction.X:
        return zoomTo({
          anchor,
          direction,
          limitScale,
          scale: prevState.transformMatrix[0] * scale
        })(prevState);

      case Direction.Y:
        return zoomTo({
          anchor,
          direction,
          limitScale,
          scale: prevState.transformMatrix[3] * scale
        })(prevState);

      case Direction.XY:
      default:
        {
          const resultX = limitScale(prevState.transformMatrix[0] * scale);
          const resultY = limitScale(prevState.transformMatrix[3] * scale);
          const scaleX = resultX / prevState.transformMatrix[0];
          const scaleY = resultY / prevState.transformMatrix[3];
          const {
            x,
            y
          } = anchor;
          const dx = x * (1 - scaleX);
          const dy = y * (1 - scaleY);
          transformMatrix = [resultX, 0, 0, resultY, prevState.transformMatrix[4] * scaleX + dx, prevState.transformMatrix[5] * scaleY + dy];
        }
    }

    return Object.assign(Object.assign({}, prevState), {
      transformMatrix
    });
  };
};
const pan = (dx, dy) => {
  if (dx === 0 && dy === 0) {
    return identical;
  }

  return prevState => {
    return Object.assign(Object.assign({}, prevState), {
      transformMatrix: [prevState.transformMatrix[0], prevState.transformMatrix[1], prevState.transformMatrix[2], prevState.transformMatrix[3], prevState.transformMatrix[4] + dx, prevState.transformMatrix[5] + dy]
    });
  };
};
const minimapPan = (dx, dy) => {
  if (dx === 0 && dy === 0) {
    return identical;
  }

  return prevState => {
    const [a, b, c, d] = prevState.transformMatrix;
    return Object.assign(Object.assign({}, prevState), {
      transformMatrix: [a, b, c, d, prevState.transformMatrix[4] + a * dx + b * dy, prevState.transformMatrix[5] + c * dx + d * dy]
    });
  };
};
const getContentArea$1 = (data, graphConfig, nodeIds) => {
  let minNodeWidth = Infinity;
  let minNodeHeight = Infinity;
  let minNodeX = Infinity;
  let minNodeY = Infinity;
  let maxNodeX = -Infinity;
  let maxNodeY = -Infinity;

  const forEachNode = fn => data.nodes.forEach(fn);

  const forEachByIds = fn => nodeIds === null || nodeIds === void 0 ? void 0 : nodeIds.forEach(id => {
    const node = data.nodes.get(id);

    if (node) {
      fn(node);
    }
  });

  const forEach = nodeIds === undefined ? forEachNode : forEachByIds;
  forEach(node => {
    const {
      width: nodeWidth,
      height: nodeHeight
    } = getNodeSize(node, graphConfig);

    if (node.x < minNodeX) {
      minNodeX = node.x;
    }

    if (node.y < minNodeY) {
      minNodeY = node.y;
    }

    if (node.x + nodeWidth > maxNodeX) {
      maxNodeX = node.x + nodeWidth;
    }

    if (node.y + nodeHeight > maxNodeY) {
      maxNodeY = node.y + nodeHeight;
    }

    if (nodeWidth < minNodeWidth) {
      minNodeWidth = nodeWidth;
    }

    if (nodeHeight < minNodeHeight) {
      minNodeHeight = nodeHeight;
    }
  });
  return {
    minNodeWidth,
    minNodeHeight,
    minNodeX,
    minNodeY,
    maxNodeX,
    maxNodeY
  };
};

const normalizeNodeVisibleMinMax = ({
  nodeMinVisibleSize,
  nodeMaxVisibleSize
}) => {
  let {
    width: nodeMinVisibleWidth,
    height: nodeMinVisibleHeight
  } = nodeMinVisibleSize;
  let {
    width: nodeMaxVisibleWidth,
    height: nodeMaxVisibleHeight
  } = nodeMaxVisibleSize;

  if (nodeMinVisibleWidth > nodeMaxVisibleWidth) {
    const temp = nodeMinVisibleWidth;
    nodeMinVisibleWidth = nodeMaxVisibleWidth;
    nodeMaxVisibleWidth = temp;
  }

  if (nodeMinVisibleHeight > nodeMaxVisibleHeight) {
    const temp = nodeMinVisibleHeight;
    nodeMinVisibleHeight = nodeMaxVisibleHeight;
    nodeMaxVisibleHeight = temp;
  }

  return {
    nodeMinVisibleWidth,
    nodeMinVisibleHeight,
    nodeMaxVisibleWidth,
    nodeMaxVisibleHeight
  };
};

const getScaleRange = (params, {
  width: minNodeWidth,
  height: minNodeHeight
}) => {
  const {
    nodeMinVisibleWidth,
    nodeMinVisibleHeight,
    nodeMaxVisibleWidth,
    nodeMaxVisibleHeight
  } = normalizeNodeVisibleMinMax(params);
  let minScaleX = 0;
  let minScaleY = 0;
  let maxScaleX = Infinity;
  let maxScaleY = Infinity;

  if (minNodeWidth) {
    minScaleX = nodeMinVisibleWidth / minNodeWidth;
    maxScaleX = nodeMaxVisibleWidth / minNodeWidth;
  }

  if (minNodeHeight) {
    minScaleY = nodeMinVisibleHeight / minNodeHeight;
    maxScaleY = nodeMaxVisibleHeight / minNodeHeight;
  }

  return {
    minScaleX,
    minScaleY,
    maxScaleX,
    maxScaleY
  };
};
const getZoomFitMatrix = args => {
  const {
    data,
    graphConfig,
    disablePan,
    direction,
    rect
  } = args;
  const {
    nodes
  } = data; // istanbul ignore next

  if (nodes.size === 0) {
    return [1, 0, 0, 1, 0, 0];
  }

  const {
    minNodeWidth,
    minNodeHeight,
    minNodeX,
    minNodeY,
    maxNodeX,
    maxNodeY
  } = getContentArea$1(data, graphConfig);
  const {
    minScaleX,
    minScaleY,
    maxScaleX,
    maxScaleY
  } = getScaleRange(args, {
    width: minNodeWidth,
    height: minNodeHeight
  });
  const spacing = normalizeSpacing(args.spacing);
  const {
    width,
    height
  } = rect;
  const scaleX = width / (maxNodeX - minNodeX + spacing.left + spacing.right);
  const scaleY = height / (maxNodeY - minNodeY + spacing.top + spacing.bottom);
  const scaleCommon = direction === Direction.Y ? Math.min(Math.max(minScaleX, minScaleY, scaleY), maxScaleX, maxScaleY) : Math.min(Math.max(minScaleX, minScaleY, Math.min(scaleX, scaleY)), maxScaleY, maxScaleY);
  const newScaleX = direction === Direction.XY ? Math.min(Math.max(minScaleX, scaleX), maxScaleX) : scaleCommon;
  const newScaleY = direction === Direction.XY ? Math.min(Math.max(minScaleY, scaleY), maxScaleY) : scaleCommon;

  if (disablePan) {
    return [newScaleX, 0, 0, newScaleY, 0, 0];
  }

  const dx = -newScaleX * (minNodeX - spacing.left);
  const dy = -newScaleY * (minNodeY - spacing.top);
  const visibleNodes = getVisibleNodes(data.nodes, {
    rect,
    transformMatrix: [newScaleX, 0, 0, newScaleY, dx, dy]
  }, graphConfig);

  if (visibleNodes.length > 0) {
    return [newScaleX, 0, 0, newScaleY, dx, dy];
  } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion


  let focusNode = data.nodes.first();

  if (focusNode) {
    data.nodes.forEach(node => {
      if (focusNode.y > node.y) {
        focusNode = node;
      }
    });
  }

  return [newScaleX, 0, 0, newScaleY, -newScaleX * (focusNode.x - spacing.left), -newScaleY * (focusNode.y - spacing.top)];
};
const focusArea = (minX, minY, maxX, maxY, viewport) => {
  const width = maxX - minX;
  const height = maxY - minY;
  const scale = Math.min(viewport.rect.width / width, viewport.rect.height / height);
  const dx = -scale * (minX + width / 2) + viewport.rect.width / 2;
  const dy = -scale * (minY + height / 2) + viewport.rect.height / 2;
  return Object.assign(Object.assign({}, viewport), {
    transformMatrix: [scale, 0, 0, scale, dx, dy]
  });
};
const getContainer = svgRef => {
  var _a;

  return (_a = svgRef.current) === null || _a === void 0 ? void 0 : _a.closest(".react-dag-editor-container");
};
/**
 * @param rectRef
 */

function getContainerCenter(rectRef) {
  const rect = rectRef.current;

  if (!rect) {
    return undefined;
  }

  const x = rect.width / 2;
  const y = rect.height / 2;
  return {
    x,
    y
  };
}
/**
 * @param rect
 * @param e
 */

function getRelativePoint(rect, e) {
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  return {
    x,
    y
  };
} // scroll the (x,y) to the center of the viewport, or to the specific position if provide

const scrollIntoView = (x, y, rect, alwaysScroll, position) => {
  // istanbul ignore next
  if (!rect) {
    return identical;
  }

  const {
    width,
    height
  } = rect;
  const shouldScroll = x < 0 || x > width || y < 0 || y > height;

  if (!shouldScroll && !alwaysScroll) {
    return identical;
  }

  return prevState => {
    const dx = position ? position.x - x : width / 2 - x;
    const dy = position ? position.y - y : height / 2 - y;
    return Object.assign(Object.assign({}, prevState), {
      transformMatrix: [prevState.transformMatrix[0], prevState.transformMatrix[1], prevState.transformMatrix[2], prevState.transformMatrix[3], prevState.transformMatrix[4] + dx, prevState.transformMatrix[5] + dy]
    });
  };
};
const getScaleLimit = (data, settings) => {
  const {
    minNodeWidth,
    minNodeHeight
  } = getContentArea$1(data, settings.graphConfig);
  const {
    minScaleX,
    minScaleY
  } = getScaleRange(settings, {
    width: minNodeWidth,
    height: minNodeHeight
  });
  return Math.max(minScaleX, minScaleY);
};

const getContentArea = memoize(getContentArea$1);
const getOffsetLimit = ({
  data,
  graphConfig,
  rect,
  transformMatrix,
  canvasBoundaryPadding,
  groupPadding
}) => {
  var _a, _b, _c, _d;

  const contentArea = getContentArea(data, graphConfig);
  const nodeMin = getClientDeltaByPointDelta(contentArea.minNodeX - ((groupPadding === null || groupPadding === void 0 ? void 0 : groupPadding.left) || 0), contentArea.minNodeY - ((groupPadding === null || groupPadding === void 0 ? void 0 : groupPadding.top) || 0), transformMatrix);
  nodeMin.x -= (_a = canvasBoundaryPadding === null || canvasBoundaryPadding === void 0 ? void 0 : canvasBoundaryPadding.left) !== null && _a !== void 0 ? _a : 0;
  nodeMin.y -= (_b = canvasBoundaryPadding === null || canvasBoundaryPadding === void 0 ? void 0 : canvasBoundaryPadding.top) !== null && _b !== void 0 ? _b : 0;
  const nodeMax = getClientDeltaByPointDelta(contentArea.maxNodeX + ((groupPadding === null || groupPadding === void 0 ? void 0 : groupPadding.right) || 0), contentArea.maxNodeY + ((groupPadding === null || groupPadding === void 0 ? void 0 : groupPadding.bottom) || 0), transformMatrix);
  nodeMax.x += (_c = canvasBoundaryPadding === null || canvasBoundaryPadding === void 0 ? void 0 : canvasBoundaryPadding.right) !== null && _c !== void 0 ? _c : 0;
  nodeMax.y += (_d = canvasBoundaryPadding === null || canvasBoundaryPadding === void 0 ? void 0 : canvasBoundaryPadding.bottom) !== null && _d !== void 0 ? _d : 0;
  let minX = -nodeMin.x || 0;
  let minY = -nodeMin.y || 0;
  let maxX = rect.width - nodeMax.x || 0;
  let maxY = rect.height - nodeMax.y || 0;

  if (maxX < minX) {
    const temp = maxX;
    maxX = minX;
    minX = temp;
  }

  if (maxY < minY) {
    const temp = maxY;
    maxY = minY;
    minY = temp;
  }

  return {
    minX,
    minY,
    maxX,
    maxY
  };
};

const pushHistory = (history, data, mapPresent = identical) => {
  return {
    present: data,
    past: {
      next: history.past,
      value: mapPresent(history.present)
    },
    future: null
  };
};
const undo = history => {
  if (!history.past) {
    return history;
  }

  return {
    present: history.past.value,
    past: history.past.next,
    future: {
      next: history.future,
      value: history.present
    }
  };
};
const redo = history => {
  if (!history.future) {
    return history;
  }

  return {
    present: history.future.value,
    past: {
      next: history.past,
      value: history.present
    },
    future: history.future.next
  };
};
const resetUndoStack = data => {
  return {
    present: data,
    future: null,
    past: null
  };
};
const canUndo = history => history.past !== null;
const canRedo = history => history.future !== null;

const isWithinThreshold = (dx, dy, threshold) => {
  return Math.abs(dx) < threshold && Math.abs(dy) < threshold;
};
const isWithinRect = (p0, p, w, h) => {
  const {
    x: x0,
    y: y0
  } = p0;
  const {
    x,
    y
  } = p;

  if (x0 < x && x0 + w > x && y0 < y && y0 + h > y) {
    return true;
  }

  return false;
};

function stopPropagation(e) {
  e.stopPropagation();
}

/**
 * @param valueOrCallback
 * @param c
 */
function resolveValueOrCallback(valueOrCallback, c) {
  if (typeof valueOrCallback === "function") {
    return valueOrCallback(c);
  }

  return valueOrCallback;
}

const EMPTY_TRANSFORM_MATRIX = [1, 0, 0, 1, 0, 0];
const EMPTY_VIEW_PORT = {
  rect: undefined,
  transformMatrix: EMPTY_TRANSFORM_MATRIX
};
const EMPTY_GAP = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
const DEFAULT_NODE_MIN_VISIBLE_SIZE = {
  width: NODE_MIN_VISIBLE_LENGTH,
  height: NODE_MIN_VISIBLE_LENGTH
};
const DEFAULT_NODE_MAX_VISIBLE_SIZE = {
  width: NODE_MAX_VISIBLE_LENGTH,
  height: NODE_MAX_VISIBLE_LENGTH
};
const DEFAULT_GRAPH_SETTINGS = {
  features: defaultFeatures,
  graphConfig: GraphConfigBuilder.default().build(),
  canvasBoundaryPadding: EMPTY_GAP,
  nodeMinVisibleSize: DEFAULT_NODE_MIN_VISIBLE_SIZE,
  nodeMaxVisibleSize: DEFAULT_NODE_MAX_VISIBLE_SIZE
};
const EMPTY_GRAPH_STATE = createGraphState({});
function createGraphState(params) {
  const {
    data,
    transformMatrix,
    settings
  } = params;
  return {
    settings: Object.assign(Object.assign({}, DEFAULT_GRAPH_SETTINGS), settings),
    data: resetUndoStack(data !== null && data !== void 0 ? data : GraphModel.empty()),
    viewport: {
      rect: undefined,
      transformMatrix: transformMatrix !== null && transformMatrix !== void 0 ? transformMatrix : EMPTY_TRANSFORM_MATRIX
    },
    behavior: GraphBehavior.Default,
    dummyNodes: emptyDummyNodes(),
    alignmentLines: [],
    activeKeys: new Set(),
    selectBoxPosition: emptySelectBoxPosition(),
    connectState: undefined
  };
}

const ViewportContext = /*#__PURE__*/createContext(EMPTY_VIEW_PORT);

/**
 *
 */

function warnGraphStateContext() {
  Debug.warn("Missing GraphStateContext, GraphStateContext must be used as child of GraphStateStore");
}

const defaultGraphStateContext = {
  get state() {
    warnGraphStateContext();
    return EMPTY_GRAPH_STATE;
  },

  dispatch: () => {
    warnGraphStateContext();
  }
};
const EMPTY_CONNECT_STATE = {
  sourceNode: undefined,
  sourcePort: undefined,
  targetNode: undefined,
  targetPort: undefined,
  movingPoint: {
    x: 0,
    y: 0
  }
};
/**
 * use separate context for now to improve performance
 * until https://github.com/reactjs/rfcs/pull/119 or something equivalent
 */

const GraphValueContext = /*#__PURE__*/React.createContext(new Proxy(GraphModel.empty(), {
  get: (target, prop) => {
    // eslint-disable-next-line no-console
    console.warn("Default graph data value is being used. Please check if you forget rendering Graph component");
    return Reflect.get(target, prop);
  }
}));
const GraphStateContext = /*#__PURE__*/React.createContext(defaultGraphStateContext);
const setData = (state, data) => Object.assign(Object.assign({}, state), {
  data: Object.assign(Object.assign({}, state.data), {
    present: data
  })
});
const updateData = (state, f) => Object.assign(Object.assign({}, state), {
  data: Object.assign(Object.assign({}, state.data), {
    present: f(state.data.present)
  })
});

const SlotsContext = /*#__PURE__*/createContext({});

class EventChannel {
  constructor() {
    this.listenersRef = /*#__PURE__*/createRef();
    this.externalHandlerRef = /*#__PURE__*/createRef();
    this.queue = [];
    this.working = false;
  }

  trigger(event) {
    if (this.working) {
      this.queue.push(event);
    } else {
      this.working = true;
      unstable_batchedUpdates(() => {
        this.callHandlers(event); // eslint-disable-next-line @typescript-eslint/prefer-for-of

        for (let i = 0; i < this.queue.length; i += 1) {
          const e = this.queue[i];
          this.callHandlers(e);
        }

        this.queue = [];
      });
      this.working = false;
    }
  }

  batch(events) {
    if (this.working) {
      this.queue.push(...events);
    } else {
      const first = events[0];

      if (!first) {
        return;
      }

      this.queue.push(...events.slice(1));
      this.trigger(first);
    }
  }

  callHandlers(e) {
    var _a, _b, _c, _d;

    (_b = (_a = this.listenersRef).current) === null || _b === void 0 ? void 0 : _b.call(_a, e);

    if (!e.intercepted) {
      (_d = (_c = this.externalHandlerRef).current) === null || _d === void 0 ? void 0 : _d.call(_c, e);
    }
  }

}

/**
 * event handlers must get/set GraphBehavior immediately
 * to determine how to treat event objects (eg. preventDefault)
 * but dispatch/setState can be asynchronous
 * thus GraphBehavior is mirrored here
 */

class GraphController {
  constructor(state, dispatch) {
    /**
     * since we don't have a detailed specification for touch handling
     * temporarily store the pointerId here for most single point events
     */
    this.pointerId = null;
    /**
     * simulate canvas click event once
     */

    this.canvasClickOnce = false;
    this.nodeClickOnce = null;
    this.eventChannel = new EventChannel();
    this.behavior = GraphBehavior.Default;

    this.dispatch = (action, callback) => {
      this.dispatchDelegate(action, callback);
    };

    this.state = state;
    this.UNSAFE_latestState = state;
    this.dispatchDelegate = dispatch;
  }

  setMouseClientPosition(pos) {
    this.mouseClientPoint = pos;
  }

  unsetMouseClientPosition() {
    this.mouseClientPoint = undefined;
  }

  getMouseClientPosition() {
    return this.mouseClientPoint;
  }

  getEnabledFeatures() {
    return this.state.settings.features;
  }

  getBehavior() {
    return this.behavior;
  }

  setBehavior(value) {
    this.behavior = value;
  }

  getData() {
    return this.state.data.present;
  }

  getGlobalEventTarget() {
    var _a, _b;

    return (_b = (_a = this.getGlobalEventTargetDelegate) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : window;
  }

}

/**
 * useConst providers a guaranteed singleton
 * useMemo may be invalidated by React
 * https://reactjs.org/docs/hooks-faq.html#how-to-memoize-calculations
 * @param init
 */

function useConst(init) {
  const ref = useRef();

  if (ref.current === undefined) {
    ref.current = init();
  }

  return ref.current;
}

const noop = () => {// noop
};

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false
    };
  }

  static getDerivedStateFromError(error) {
    return {
      hasError: true,
      error
    };
  }

  componentDidCatch(error, errorInfo) {
    // eslint-disable-next-line no-console
    console.error(error);
    this.setState({
      error,
      errorInfo
    });
  }

  render() {
    var _a, _b;

    if (!this.state.hasError) {
      return this.props.children;
    }

    if (this.props.renderOnError) {
      return (_a = this.props.renderOnError(this.state.error, this.state.errorInfo, this.props.children)) !== null && _a !== void 0 ? _a : null;
    }

    const componentStackLines = this.state.errorInfo ? (_b = this.state.errorInfo.componentStack) === null || _b === void 0 ? void 0 : _b.split("\n") : [];
    return jsxs("div", Object.assign({
      style: {
        color: "red"
      }
    }, {
      children: [jsx("h1", {
        children: "Something went wrong."
      }), jsx("p", {
        children: `Error: ${this.state.error}`
      }), jsx("p", {
        children: `ErrorInfo: ${JSON.stringify(this.state.errorInfo)}`
      }), jsx("h2", {
        children: "Component Stack"
      }), (componentStackLines !== null && componentStackLines !== void 0 ? componentStackLines : []).map((line, index) => jsx("p", {
        children: line
      }, index))]
    }));
  }

}

const EMPTY_CONNECT_CONTEXT = {
  sourceNode: undefined,
  sourcePort: undefined,
  targetNode: undefined,
  targetPort: undefined
};
const ConnectingStateContext = /*#__PURE__*/createContext(EMPTY_CONNECT_CONTEXT);
ConnectingStateContext.displayName = "ConnectingStateContext";

const ConnectingState = ({
  children,
  data,
  connectState
}) => {
  let sourceNode;
  let sourcePort;
  let targetNode;
  let targetPort;

  if (connectState) {
    sourceNode = data.nodes.get(connectState.sourceNode);
    sourcePort = sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.getPort(connectState.sourcePort);
    targetNode = connectState.targetNode ? data.nodes.get(connectState.targetNode) : undefined;
    targetPort = connectState.targetPort ? targetNode === null || targetNode === void 0 ? void 0 : targetNode.getPort(connectState.targetPort) : undefined;
  }

  const context = React.useMemo(() => ({
    sourceNode,
    sourcePort,
    targetNode,
    targetPort
  }), [sourceNode, sourcePort, targetNode, targetPort]);
  return jsx(ConnectingStateContext.Provider, Object.assign({
    value: context
  }, {
    children: children
  }));
};
ConnectingState.displayName = "ConnectingState";

const AlignmentLinesContext = /*#__PURE__*/createContext([]);

const GraphControllerContext = /*#__PURE__*/createContext(new GraphController(EMPTY_GRAPH_STATE, noop));

function GraphStateStore(props) {
  const {
    graphController,
    state,
    dispatch,
    children
  } = props;
  const contextValue = React.useMemo(() => ({
    state: state,
    dispatch
  }), [state, dispatch]);
  return jsx(GraphConfigContext.Provider, Object.assign({
    value: state.settings.graphConfig
  }, {
    children: jsx(GraphControllerContext.Provider, Object.assign({
      value: graphController
    }, {
      children: jsx(ConnectingState, Object.assign({
        data: state.data.present,
        connectState: state.connectState
      }, {
        children: jsx(GraphStateContext.Provider, Object.assign({
          value: contextValue
        }, {
          children: jsx(ViewportContext.Provider, Object.assign({
            value: state.viewport
          }, {
            children: jsx(GraphValueContext.Provider, Object.assign({
              value: state.data.present
            }, {
              children: jsx(AlignmentLinesContext.Provider, Object.assign({
                value: state.alignmentLines
              }, {
                children: children
              }))
            }))
          }))
        }))
      }))
    }))
  }));
}

/**
 * ReactDagEditor top level container component
 *
 * @param props
 */

const ReactDagEditor = props => {
  var _a;

  React.useEffect(() => {
    if (props.handleWarning) {
      Debug.warn = props.handleWarning;
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  const handleError = (_a = props.handleError) === null || _a === void 0 ? void 0 : _a.bind(null);
  const {
    state,
    dispatch,
    getGlobalEventTarget
  } = props;
  const graphController = useConst(() => new GraphController(state, dispatch));
  graphController.UNSAFE_latestState = state;
  React.useLayoutEffect(() => {
    graphController.state = state;
    graphController.dispatchDelegate = dispatch;
    graphController.getGlobalEventTargetDelegate = getGlobalEventTarget;
  }, [dispatch, getGlobalEventTarget, graphController, state]);
  React.useEffect(() => {
    return () => {
      graphController.dispatchDelegate = noop;
    };
  }, [graphController]);
  return jsx(ErrorBoundary, Object.assign({
    renderOnError: handleError
  }, {
    children: jsx(SlotsContext.Provider, Object.assign({
      value: props
    }, {
      children: jsx(GraphStateStore, Object.assign({
        state: state,
        dispatch: dispatch,
        graphController: graphController
      }, {
        children: jsx(ContextMenuConfigContext.Provider, Object.assign({
          value: useConst(() => new ContextMenuConfig())
        }, {
          children: jsx("div", Object.assign({
            style: props.style,
            className: props.className
          }, {
            children: props.children
          }))
        }))
      }))
    }))
  }));
};

const useContextMenuConfigContext = () => {
  return React.useContext(ContextMenuConfigContext);
};

var GraphNodeEvent;

(function (GraphNodeEvent) {
  GraphNodeEvent["Click"] = "[Node]Click";
  GraphNodeEvent["DoubleClick"] = "[Node]DoubleClick";
  GraphNodeEvent["MouseDown"] = "[Node]MouseDown";
  GraphNodeEvent["MouseUp"] = "[Node]MouseUp";
  GraphNodeEvent["MouseEnter"] = "[Node]MouseEnter";
  GraphNodeEvent["MouseLeave"] = "[Node]MouseLeave";
  GraphNodeEvent["MouseOver"] = "[Node]MouseOver";
  GraphNodeEvent["MouseOut"] = "[Node]MouseOut";
  GraphNodeEvent["MouseMove"] = "[Node]MouseMove";
  GraphNodeEvent["ContextMenu"] = "[Node]ContextMenu";
  GraphNodeEvent["Drag"] = "[Node]Drag";
  GraphNodeEvent["DragStart"] = "[Node]DragStart";
  GraphNodeEvent["DragEnd"] = "[Node]DragEnd";
  GraphNodeEvent["PointerDown"] = "[Node]PointerDown";
  GraphNodeEvent["PointerEnter"] = "[Node]PointerEnter";
  GraphNodeEvent["PointerMove"] = "[Node]PointerMove";
  GraphNodeEvent["PointerLeave"] = "[Node]PointerLeave";
  GraphNodeEvent["PointerUp"] = "[Node]PointerUp";
  GraphNodeEvent["Resizing"] = "[Node]Resizing";
  GraphNodeEvent["ResizingStart"] = "[Node]ResizingStart";
  GraphNodeEvent["ResizingEnd"] = "[Node]ResizingEnd";
  GraphNodeEvent["KeyDown"] = "[Node]KeyDown";
  GraphNodeEvent["Select"] = "[Node]Select";
  GraphNodeEvent["SelectAll"] = "[Node]SelectAll";
  GraphNodeEvent["Centralize"] = "[Node]Centralize";
  GraphNodeEvent["Locate"] = "[Node]Locate";
  GraphNodeEvent["Add"] = "[Node]Add";
})(GraphNodeEvent || (GraphNodeEvent = {}));

var GraphEdgeEvent;

(function (GraphEdgeEvent) {
  GraphEdgeEvent["Click"] = "[Edge]Click";
  GraphEdgeEvent["DoubleClick"] = "[Edge]DoubleClick";
  GraphEdgeEvent["MouseEnter"] = "[Edge]MouseEnter";
  GraphEdgeEvent["MouseLeave"] = "[Edge]MouseLeave";
  GraphEdgeEvent["MouseOver"] = "[Edge]MouseOver";
  GraphEdgeEvent["MouseOut"] = "[Edge]MouseOut";
  GraphEdgeEvent["MouseMove"] = "[Edge]MouseMove";
  GraphEdgeEvent["MouseDown"] = "[Edge]MouseDown";
  GraphEdgeEvent["MouseUp"] = "[Edge]MouseUp";
  GraphEdgeEvent["ContextMenu"] = "[Edge]ContextMenu";
  GraphEdgeEvent["ConnectStart"] = "[Edge]ConnectStart";
  GraphEdgeEvent["ConnectMove"] = "[Edge]ConnectMove";
  GraphEdgeEvent["ConnectEnd"] = "[Edge]ConnectEnd";
  GraphEdgeEvent["ConnectNavigate"] = "[Edge]ConnectNavigate";
  GraphEdgeEvent["Add"] = "[Edge]Add";
})(GraphEdgeEvent || (GraphEdgeEvent = {}));

var GraphPortEvent;

(function (GraphPortEvent) {
  GraphPortEvent["Click"] = "[Port]Click";
  GraphPortEvent["DoubleClick"] = "[Port]DoubleClick";
  GraphPortEvent["MouseDown"] = "[Port]MouseDown";
  GraphPortEvent["PointerDown"] = "[Port]PointerDown";
  GraphPortEvent["PointerUp"] = "[Port]PointerUp";
  GraphPortEvent["PointerEnter"] = "[Port]PointerEnter";
  GraphPortEvent["PointerLeave"] = "[Port]PointerLeave";
  GraphPortEvent["MouseUp"] = "[Port]MouseUp";
  GraphPortEvent["MouseEnter"] = "[Port]MouseEnter";
  GraphPortEvent["MouseLeave"] = "[Port]MouseLeave";
  GraphPortEvent["MouseOver"] = "[Port]MouseOver";
  GraphPortEvent["MouseOut"] = "[Port]MouseOut";
  GraphPortEvent["MouseMove"] = "[Port]MouseMove";
  GraphPortEvent["ContextMenu"] = "[Port]ContextMenu";
  GraphPortEvent["KeyDown"] = "[Port]KeyDown";
  GraphPortEvent["Focus"] = "[Port]Focus";
  GraphPortEvent["Blur"] = "[Port]Blur";
})(GraphPortEvent || (GraphPortEvent = {}));

var GraphCanvasEvent;

(function (GraphCanvasEvent) {
  GraphCanvasEvent["Click"] = "[Canvas]Click";
  GraphCanvasEvent["DoubleClick"] = "[Canvas]DoubleClick";
  GraphCanvasEvent["MouseDown"] = "[Canvas]MouseDown";
  GraphCanvasEvent["MouseUp"] = "[Canvas]MouseUp";
  GraphCanvasEvent["MouseEnter"] = "[Canvas]MouseEnter";
  GraphCanvasEvent["MouseLeave"] = "[Canvas]MouseLeave";
  GraphCanvasEvent["MouseOver"] = "[Canvas]MouseOver";
  GraphCanvasEvent["MouseOut"] = "[Canvas]MouseOut";
  GraphCanvasEvent["MouseMove"] = "[Canvas]MouseMove";
  GraphCanvasEvent["ContextMenu"] = "[Canvas]ContextMenu";
  GraphCanvasEvent["DragStart"] = "[Canvas]DragStart";
  GraphCanvasEvent["Drag"] = "[Canvas]Drag";
  GraphCanvasEvent["DragEnd"] = "[Canvas]DragEnd";
  GraphCanvasEvent["Pan"] = "[Canvas]Pan";
  GraphCanvasEvent["Focus"] = "[Canvas]Focus";
  GraphCanvasEvent["Blur"] = "[Canvas]Blur";
  GraphCanvasEvent["Zoom"] = "[Canvas]Zoom";
  GraphCanvasEvent["Pinch"] = "[Canvas]Pinch";
  GraphCanvasEvent["KeyDown"] = "[Canvas]KeyDown";
  GraphCanvasEvent["KeyUp"] = "[Canvas]KeyUp";
  GraphCanvasEvent["SelectStart"] = "[Canvas]SelectStart";
  GraphCanvasEvent["SelectMove"] = "[Canvas]SelectMove";
  GraphCanvasEvent["SelectEnd"] = "[Canvas]SelectEnd";
  GraphCanvasEvent["UpdateNodeSelectionBySelectBox"] = "[Canvas]UpdateNodeSelectionBySelectBox";
  GraphCanvasEvent["MouseWheelScroll"] = "[Canvas]MouseWheelScroll";
  GraphCanvasEvent["DraggingNodeFromItemPanel"] = "[Canvas]DraggingNodeFromItemPanel";
  GraphCanvasEvent["DraggingNodeFromItemPanelStart"] = "[Canvas]DraggingNodeFromItemPanelStart";
  GraphCanvasEvent["DraggingNodeFromItemPanelEnd"] = "[Canvas]DraggingNodeFromItemPanelEnd";
  GraphCanvasEvent["ViewportResize"] = "[Canvas]ViewportResize";
  GraphCanvasEvent["Navigate"] = "[Canvas]Navigate";
  GraphCanvasEvent["VirtualizationRecalculated"] = "[Canvas]VirtualizationRecalculated";
  GraphCanvasEvent["ResetSelection"] = "[Canvas]ResetSelection";
  GraphCanvasEvent["Copy"] = "[Canvas]Copy";
  GraphCanvasEvent["Paste"] = "[Canvas]Paste";
  GraphCanvasEvent["Delete"] = "[Canvas]Delete";
  GraphCanvasEvent["Undo"] = "[Canvas]Undo";
  GraphCanvasEvent["Redo"] = "[Canvas]Redo";
  GraphCanvasEvent["ScrollIntoView"] = "[Canvas]ScrollIntoView";
  GraphCanvasEvent["ResetUndoStack"] = "[Canvas]ResetUndoStack";
  GraphCanvasEvent["ResetViewport"] = "[Canvas]ResetViewport";
  GraphCanvasEvent["ZoomTo"] = "[Canvas]ZoomTo";
  GraphCanvasEvent["ZoomToFit"] = "[Canvas]ZoomToFit";
  GraphCanvasEvent["SetData"] = "[Canvas]SetData";
  GraphCanvasEvent["UpdateData"] = "[Canvas]UpdateData";
  GraphCanvasEvent["ScrollTo"] = "[Canvas]ScrollTo";
  GraphCanvasEvent["UpdateSettings"] = "[Canvas]UpdateSettings";
})(GraphCanvasEvent || (GraphCanvasEvent = {}));

var GraphScrollBarEvent;

(function (GraphScrollBarEvent) {
  GraphScrollBarEvent["ScrollStart"] = "[ScrollBar]ScrollStart";
  GraphScrollBarEvent["Scroll"] = "[ScrollBar]Scroll";
  GraphScrollBarEvent["ScrollEnd"] = "[ScrollBar]ScrollEnd";
})(GraphScrollBarEvent || (GraphScrollBarEvent = {}));

var GraphMinimapEvent;

(function (GraphMinimapEvent) {
  GraphMinimapEvent["PanStart"] = "[Minimap]PanStart";
  GraphMinimapEvent["Pan"] = "[Minimap]Pan";
  GraphMinimapEvent["PanEnd"] = "[Minimap]PanEnd";
  GraphMinimapEvent["Click"] = "[Minimap]Click";
})(GraphMinimapEvent || (GraphMinimapEvent = {}));

var GraphContextMenuEvent;

(function (GraphContextMenuEvent) {
  GraphContextMenuEvent["Open"] = "[ContextMenu]Open";
  GraphContextMenuEvent["Close"] = "[ContextMenu]Close";
})(GraphContextMenuEvent || (GraphContextMenuEvent = {}));

/**
 * convert WheelEvent delta to pixels by deltaMode
 * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent
 * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line
 */
/**
 * get browser scroll line height by iframe
 *
 * @returns line height in px
 */

function getScrollLineHeight() {
  try {
    const iframe = document.createElement("iframe");
    iframe.src = "#";
    document.body.appendChild(iframe);
    const {
      contentDocument
    } = iframe;

    if (!contentDocument) {
      throw new Error("Fail to create iframe");
    } // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore


    contentDocument.documentElement.innerHTML = DOMPurify.sanitize("<span>a</span>", {
      RETURN_TRUSTED_TYPE: true
    });
    const span = contentDocument.body.firstElementChild;
    const height = span.offsetHeight;
    document.body.removeChild(iframe);
    return height;
  } catch (e) {
    Debug.error("failed to calculate scroll line height", e);
    return 16;
  }
}

const scrollLineHeight = getScrollLineHeight();
const normalizeWheelDelta = typeof WheelEvent === "function" ? (deltaMode, delta) => {
  switch (deltaMode) {
    case WheelEvent.DOM_DELTA_PIXEL:
      return delta;

    case WheelEvent.DOM_DELTA_LINE:
      return delta * scrollLineHeight;

    case WheelEvent.DOM_DELTA_PAGE:
      return delta * window.innerHeight;

    default:
      return delta;
  }
} : (_deltaMode, delta) => delta;

const EMPTY_RECT = {
  height: 0,
  width: 0,
  x: 0,
  y: 0,
  bottom: 0,
  left: 0,
  right: 0,
  top: 0,

  toJSON() {
    return this;
  }

};
const VirtualizationContext = /*#__PURE__*/createContext({
  viewport: {
    rect: EMPTY_RECT,
    transformMatrix: EMPTY_TRANSFORM_MATRIX
  },
  renderedArea: {
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0
  },
  visibleArea: {
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0
  },
  renderedNodes: new Set(),
  renderedEdges: new Set(),
  timestamp: 0
});

function useGraphConfig() {
  return useContext(GraphConfigContext);
}
function useGraphController() {
  return useContext(GraphControllerContext);
}
function useViewport() {
  return useContext(ViewportContext);
}
function useAlignmentLines() {
  return useContext(AlignmentLinesContext);
}
function useConnectingState() {
  return useContext(ConnectingStateContext);
}
function useVirtualization() {
  return useContext(VirtualizationContext);
}

let shouldRespondWheel = false;
const useWheelHandler = args => {
  const {
    containerRef,
    svgRef,
    rectRef,
    zoomSensitivity,
    scrollSensitivity,
    isHorizontalScrollDisabled,
    isVerticalScrollDisabled,
    isCtrlKeyZoomEnable,
    eventChannel,
    graphConfig,
    dispatch
  } = args;
  const graphController = useGraphController();
  const globalEventTarget = graphController.getGlobalEventTarget();
  useLayoutEffect(() => {
    const svg = svgRef.current;
    const container = containerRef.current;

    if (!svg || !container) {
      return noop;
    }

    const onWheel = e => {
      const rect = rectRef.current;

      if (!rect) {
        return;
      }

      if (!shouldRespondWheel) {
        return;
      }

      e.preventDefault();

      if (e.ctrlKey && isCtrlKeyZoomEnable) {
        const deltaY = normalizeWheelDelta(e.deltaMode, e.deltaY);
        const scale = (deltaY > 0 ? -zoomSensitivity : zoomSensitivity) + 1;
        eventChannel.trigger({
          type: GraphCanvasEvent.Zoom,
          rawEvent: e,
          scale,
          anchor: getRelativePoint(rect, e)
        });
        return;
      }

      const dx = isHorizontalScrollDisabled ? 0 : -normalizeWheelDelta(e.deltaMode, e.shiftKey ? e.deltaY : e.deltaX) * scrollSensitivity;
      const dy = isVerticalScrollDisabled || e.shiftKey ? 0 : -normalizeWheelDelta(e.deltaMode, e.deltaY) * scrollSensitivity;
      eventChannel.trigger({
        type: GraphCanvasEvent.MouseWheelScroll,
        dx,
        dy,
        rawEvent: e
      });
    };

    const mouseEnterHandler = () => {
      shouldRespondWheel = true;
    };

    container.addEventListener("mouseenter", mouseEnterHandler);

    const mouseLeaveHandler = () => {
      shouldRespondWheel = false;
    };

    container.addEventListener("mouseleave", mouseLeaveHandler);
    globalEventTarget.addEventListener("wheel", onWheel, {
      passive: false
    });
    return () => {
      globalEventTarget.removeEventListener("wheel", onWheel);
      container.removeEventListener("mouseenter", mouseEnterHandler);
      container.removeEventListener("mouseleave", mouseLeaveHandler);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [svgRef, rectRef, zoomSensitivity, scrollSensitivity, dispatch, isHorizontalScrollDisabled, isVerticalScrollDisabled, graphConfig, eventChannel, isCtrlKeyZoomEnable]);
};

function nextFrame(callback) {
  // double requestAnimationFrame guarantee next frame
  // https://bugs.chromium.org/p/chromium/issues/detail?id=675795
  requestAnimationFrame(() => {
    requestAnimationFrame(callback);
  });
}

const LIMIT = 20;

const isRectChanged = (a, b) => {
  if (a === b) {
    return false;
  }

  if (!a || !b) {
    return true;
  }

  return a.top !== b.top || a.left !== b.left || a.width !== b.width || a.height !== b.height;
};

const useUpdateViewportCallback = (rectRef, svgRef, eventChannel) => useCallback((force = false) => {
  var _a;

  const viewportRect = (_a = svgRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();

  if (force || isRectChanged(rectRef.current, viewportRect)) {
    rectRef.current = viewportRect;
    eventChannel.trigger({
      type: GraphCanvasEvent.ViewportResize,
      viewportRect
    });
  }
}, [eventChannel, rectRef, svgRef]);
const useContainerRect = (state, svgRef, containerRef, updateViewport) => {
  useLayoutEffect(() => {
    if (!state.viewport.rect) {
      updateViewport(true);
    }
  });
  useEffect(() => {
    const container = containerRef.current;

    if (!container) {
      return noop;
    }

    const onResize = debounce(() =>
    /**
     * > This error means that ResizeObserver was not able
     * > to deliver all observations within a single animation frame.
     * > It is benign (your site will not break).  Aleksandar Totic Apr 15 at 3:14
     * https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
     */
    nextFrame(() => {
      updateViewport();
    }), LIMIT);

    if (typeof ResizeObserver !== "undefined") {
      const resizeObserver = new ResizeObserver(onResize);
      resizeObserver.observe(container);
      return () => {
        resizeObserver.unobserve(container);
        resizeObserver.disconnect();
      };
    }

    window.addEventListener("resize", onResize);
    return () => {
      window.removeEventListener("resize", onResize);
    };
  }, [containerRef, updateViewport]);
  useEffect(() => {
    const listener = debounce(e => {
      const svg = svgRef.current;

      if (!svg || !(e.target instanceof Element) || !e.target.contains(svg)) {
        return;
      }

      updateViewport();
    }, LIMIT);
    const options = {
      capture: true,
      passive: true
    };
    document.body.addEventListener("scroll", listener, options);
    return () => {
      document.body.removeEventListener("scroll", listener, options);
    };
  }, [svgRef, updateViewport]);
};

function makeScheduledCallback(callback, schedule, cancel) {
  let scheduled = false;
  let currentArgs;
  let task;

  const scheduledCallback = (...args) => {
    currentArgs = args;

    if (!scheduled) {
      scheduled = true;
      task = schedule(() => {
        scheduled = false;
        unstable_batchedUpdates(() => {
          callback.apply(null, currentArgs);
        });
      });
    }
  };

  scheduledCallback.cancel = () => {
    cancel(task);
  };

  return scheduledCallback;
}

const animationFramed = callback => makeScheduledCallback(callback, requestAnimationFrame, cancelAnimationFrame);
const throttle = (callback, limit) => makeScheduledCallback(callback, cb => setTimeout(cb, limit), clearTimeout);

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * @param callback
 * @param limit
 * @param deps
 */

function useThrottle(callback, limit, deps) {
  /**
   * wrap the throttle in useMemo,
   * or throttle generate a new function every time components rerender,
   * which cause throttle acts like a "setTimeout"
   */
  // eslint-disable-next-line react-hooks/exhaustive-deps
  return useMemo(() => throttle(callback, limit), deps);
}

const useRenderedArea = (viewport, isVirtualizationEnabled) => {
  return useMemo(() => {
    return isVirtualizationEnabled ? getRenderedArea(viewport) : {
      minX: -Number.MAX_SAFE_INTEGER,
      minY: -Number.MAX_SAFE_INTEGER,
      maxX: Number.MAX_SAFE_INTEGER,
      maxY: Number.MAX_SAFE_INTEGER
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [viewport, isVirtualizationEnabled]);
};

const getMinimapRect = svgRef => {
  var _a, _b;

  return (_b = (_a = svgRef.current) === null || _a === void 0 ? void 0 : _a.closest(".minimap-container")) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
};
const useMinimapRect = svgRef => {
  const [rect, setRect] = useState(undefined);
  useLayoutEffect(() => {
    setRect(getMinimapRect(svgRef));
  }, [svgRef]);
  useEffect(() => {
    const onResize = throttle(() => {
      setRect(getMinimapRect(svgRef));
    }, 20);
    window.addEventListener("resize", onResize);
    return () => {
      window.removeEventListener("resize", onResize);
    };
  }, [svgRef]);
  return rect;
};

class DragController {
  constructor(eventProvider, getPositionFromEvent) {
    this.onMove = noop;
    this.onEnd = noop;
    this.lastEvent = null;
    this.startX = 0;
    this.startY = 0;
    this.prevClientX = 0;
    this.prevClientY = 0;

    this.onMouseUp = e => {
      this.lastEvent = e;
      this.doOnMouseUp(e);
      this.lastEvent = null;
    };

    this.onMouseMove = e => {
      this.lastEvent = e;
      e.preventDefault();
      this.mouseMove(e);
    };

    this.eventProvider = eventProvider;
    this.getPositionFromEvent = getPositionFromEvent;
    this.mouseMove = animationFramed(e => {
      this.doOnMouseMove(e);
    });
  }

  start(e) {
    this.lastEvent = e;
    const {
      x,
      y
    } = this.getPositionFromEvent(e);
    this.startX = x;
    this.startY = y;
    this.prevClientX = x;
    this.prevClientY = y;
    this.eventProvider.on("move", this.onMouseMove);
    this.eventProvider.on("end", this.onMouseUp);
  }

  stop() {
    this.mouseMove.cancel();
    this.eventProvider.off("move", this.onMouseMove);
    this.eventProvider.off("end", this.onMouseUp);
  }

  getDelta(x, y) {
    const clientDX = x - this.prevClientX;
    const clientDY = y - this.prevClientY;
    this.prevClientX = x;
    this.prevClientY = y;
    return {
      x: clientDX,
      y: clientDY
    };
  }

  getTotalDelta(e) {
    const x = e.clientX - this.startX;
    const y = e.clientY - this.startY;
    return {
      x,
      y
    };
  }

  doOnMouseMove(e) {
    const {
      x,
      y
    } = this.getPositionFromEvent(e);
    const {
      x: dx,
      y: dy
    } = this.getDelta(x, y);
    const {
      x: totalDX,
      y: totalDY
    } = this.getTotalDelta(e);
    this.onMove({
      clientX: x,
      clientY: y,
      dx,
      dy,
      totalDX,
      totalDY,
      e
    });
  }

  doOnMouseUp(e) {
    e.preventDefault();
    const {
      x: totalDX,
      y: totalDY
    } = this.getTotalDelta(e);
    this.onEnd({
      totalDX,
      totalDY,
      e
    });
    this.stop();
  }

}
function defaultGetPositionFromEvent(e) {
  return {
    x: e.clientX,
    y: e.clientY
  };
}

class DragNodeController extends DragController {
  constructor(globalMoveEventProvider, getPositionFromEvent, rectRef) {
    super(globalMoveEventProvider, getPositionFromEvent);
    this.rectRef = rectRef;
  }

  doOnMouseMove(e) {
    super.doOnMouseMove(e);
    const rect = this.rectRef.current;

    if (!rect || !this.lastEvent) {
      return;
    }

    if (e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) {
      this.mouseMove(this.lastEvent);
    }
  }

}

class TouchController {
  constructor(handlers) {
    this.eventHandlers = {
      onPointerDown: (e, ...args) => {
        if (e.pointerType !== "touch") {
          return;
        }

        e.preventDefault();
        this.pointers = new Map(this.pointers);
        this.pointers.set(e.pointerId, e.nativeEvent);
        this.updateHandler(e.nativeEvent, ...args);
      },
      onPointerMove: (e, ...args) => {
        if (e.pointerType !== "touch") {
          return;
        }

        e.preventDefault();
        this.pointers.set(e.pointerId, e.nativeEvent);
        this.onMove(e.nativeEvent, ...args);
      },
      onPointerUp: (e, ...args) => {
        if (e.pointerType !== "touch") {
          return;
        }

        e.preventDefault();
        this.pointers = new Map(this.pointers);
        this.pointers.delete(e.pointerId);
        this.updateHandler(e.nativeEvent, ...args);
      }
    };
    this.pointers = new Map();
    this.onMove = animationFramed((e, ...args) => {
      var _a;

      (_a = this.currentHandler) === null || _a === void 0 ? void 0 : _a.onMove(this.pointers, e, ...args);
    });
    this.handlers = handlers;
  }

  updateHandler(e, ...args) {
    var _a, _b;

    const handler = this.handlers.get(this.pointers.size);

    if (handler !== this.currentHandler) {
      (_a = this.currentHandler) === null || _a === void 0 ? void 0 : _a.onEnd(e, ...args);
      this.currentHandler = handler;
      (_b = this.currentHandler) === null || _b === void 0 ? void 0 : _b.onStart(this.pointers, e, ...args);
    }
  }

}

/**
 * debug helpers, just leave them here
 */
// const canvas = document.createElement("canvas");
// canvas.height = window.innerHeight;
// canvas.width = window.innerWidth;
// Object.assign(canvas.style, {
//   pointerEvents: "none",
//   position: "fixed",
//   top: "0",
//   left: "0"
// });
// document.body.append(canvas);
//
// const ctx = canvas.getContext("2d")!;
//
// function draw({ x, y }: ITouch, style: string): void {
//   ctx.fillStyle = style;
//   ctx.fillRect(x - 2.5, y - 2.5, 5, 5);
// }

class TwoFingerHandler {
  constructor(rectRef, eventChannel) {
    this.prevDistance = 0;
    this.rectRef = rectRef;
    this.eventChannel = eventChannel;
  }

  onEnd() {// noop
  }

  onMove(pointers, e) {
    const events = Array.from(pointers.values());
    const currentDistance = distance(events[0].clientX, events[0].clientY, events[1].clientX, events[1].clientY);
    const {
      prevEvents,
      prevDistance
    } = this;
    this.prevDistance = currentDistance;
    this.prevEvents = events;

    if (!prevEvents) {
      return;
    }

    const dx1 = events[0].clientX - prevEvents[0].clientX;
    const dx2 = events[1].clientX - prevEvents[1].clientX;
    const dy1 = events[0].clientY - prevEvents[0].clientY;
    const dy2 = events[1].clientY - prevEvents[1].clientY;
    const dx = (dx1 + dx2) / 2;
    const dy = (dy1 + dy2) / 2;
    const scale = (currentDistance - prevDistance) / prevDistance + 1;
    const anchor = getContainerCenter(this.rectRef);

    if (!anchor) {
      return;
    }

    this.eventChannel.trigger({
      type: GraphCanvasEvent.Pinch,
      rawEvent: e,
      dx,
      dy,
      scale,
      anchor
    });
  }

  onStart(pointers) {
    if (pointers.size !== 2) {
      throw new Error(`Unexpected touch event with ${pointers.size} touches`);
    }

    this.prevEvents = Array.from(pointers.values());
    this.prevDistance = distance(this.prevEvents[0].clientX, this.prevEvents[0].clientY, this.prevEvents[1].clientX, this.prevEvents[1].clientY);
  }

}

const useGraphTouchHandler = (rectRef, eventChannel) => {
  return React.useMemo(() => {
    const touchEvents = new TouchController(new Map().set(2, new TwoFingerHandler(rectRef, eventChannel)));
    return touchEvents.eventHandlers;
  }, [rectRef, eventChannel]);
};

/* eslint-disable @typescript-eslint/ban-ts-comment */
const isSafari = getBrowser() === BrowserType.Safari;
let prevScale = 0;
function useSafariScale({
  rectRef,
  svgRef,
  eventChannel
}) {
  useEffect(() => {
    const el = svgRef.current;

    if (!isSafari || !el || isMobile()) {
      return () => {// noop
      };
    }

    const onGestureEvent = animationFramed(e => {
      const {
        scale
      } = e;
      const delta = scale / prevScale;
      prevScale = scale;
      eventChannel.trigger({
        type: GraphCanvasEvent.Zoom,
        rawEvent: e,
        scale: delta,
        anchor: getContainerCenter(rectRef)
      });
    });

    const onGestureStart = e => {
      e.stopPropagation();
      e.preventDefault();
      prevScale = e.scale;
      eventChannel.trigger({
        type: GraphCanvasEvent.Zoom,
        rawEvent: e,
        scale: e.scale,
        anchor: getContainerCenter(rectRef)
      });
    };

    const onGestureChange = e => {
      e.stopPropagation();
      e.preventDefault();
      onGestureEvent(e);
    };

    const onGestureEnd = e => {
      e.stopPropagation();
      e.preventDefault();
      onGestureEvent(e);
    }; // @ts-ignore


    el.addEventListener("gesturestart", onGestureStart); // @ts-ignore

    el.addEventListener("gesturechange", onGestureChange); // @ts-ignore

    el.addEventListener("gestureend", onGestureEnd);
    return () => {
      // @ts-ignore
      el.removeEventListener("gesturestart", onGestureStart); // @ts-ignore

      el.removeEventListener("gesturechange", onGestureChange); // @ts-ignore

      el.removeEventListener("gestureend", onGestureEnd);
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
}

/**
 * @todo migrate to React.useDeferredValue after Concurrent mode release
 */

function useDeferredValue(value, {
  timeout
}) {
  const [state, setState] = useState(value);
  useEffect(() => {
    const timer = setTimeout(() => {
      setState(value);
    }, timeout);
    return () => {
      clearTimeout(timer);
    };
  }, [value, timeout]);
  return state;
}

const useSelectBox = (dispatch, selectBoxPositionState) => {
  const selectBoxPosition = useDeferredValue(selectBoxPositionState, {
    timeout: 100
  });
  React.useEffect(() => {
    dispatch({
      type: GraphCanvasEvent.UpdateNodeSelectionBySelectBox
    }); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectBoxPosition]);
};

const useGraphState = () => {
  return useContext(GraphStateContext);
};
const useGraphData = () => {
  return useContext(GraphValueContext);
};

/**
 * this function is used both in useEventChannel and behaviorReducer to share the same logic
 */

const handleBehaviorChange = (prevBehavior, event) => {
  switch (event.type) {
    case GraphNodeEvent.DragStart:
      return GraphBehavior.Dragging;

    case GraphEdgeEvent.ConnectStart:
      return GraphBehavior.Connecting;

    case GraphCanvasEvent.SelectStart:
      return GraphBehavior.MultiSelect;

    case GraphCanvasEvent.DragStart:
      return GraphBehavior.Panning;

    case GraphCanvasEvent.DraggingNodeFromItemPanelStart:
      return GraphBehavior.AddingNode;

    case GraphNodeEvent.DragEnd:
    case GraphEdgeEvent.ConnectEnd:
    case GraphCanvasEvent.SelectEnd:
    case GraphCanvasEvent.DragEnd:
    case GraphCanvasEvent.DraggingNodeFromItemPanelEnd:
      return GraphBehavior.Default;

    default:
      return prevBehavior;
  }
};
const behaviorReducer = (prevState, action) => {
  const nextBehavior = handleBehaviorChange(prevState.behavior, action);

  if (nextBehavior === prevState.behavior) {
    return prevState;
  }

  return Object.assign(Object.assign({}, prevState), {
    behavior: nextBehavior
  });
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const canvasReducer = (state, action) => {
  switch (action.type) {
    case GraphCanvasEvent.Paste:
      {
        const {
          position
        } = action;

        if (!isViewportComplete(state.viewport)) {
          return state;
        }

        const {
          rect
        } = state.viewport;
        let pasteNodes = action.data.nodes;

        if (position && rect) {
          const realPoint = getRealPointFromClientPoint(position.x, position.y, state.viewport);
          let dx;
          let dy;
          pasteNodes = pasteNodes.map((n, idx) => {
            // (dx,dy) are same for all copied nodes
            if (idx === 0) {
              dx = realPoint.x - n.x;
              dy = realPoint.y - n.y;
            }

            return Object.assign(Object.assign({}, n), {
              x: dx ? n.x - COPIED_NODE_SPACING + dx : n.x,
              y: dy ? n.y - COPIED_NODE_SPACING + dy : n.y,
              state: GraphNodeStatus.Selected
            });
          });
        }

        let next = unSelectAllEntity()(state.data.present);
        pasteNodes.forEach(node => {
          next = next.insertNode(node);
        });
        action.data.edges.forEach(edge => {
          next = next.insertEdge(edge);
        });
        return Object.assign(Object.assign({}, state), {
          data: pushHistory(state.data, next)
        });
      }

    case GraphCanvasEvent.Delete:
      if (!state.settings.features.has(GraphFeatures.Delete)) {
        return state;
      }

      return Object.assign(Object.assign({}, state), {
        data: pushHistory(state.data, state.data.present.deleteItems({
          node: notSelected,
          edge: notSelected
        }), unSelectAllEntity())
      });

    case GraphCanvasEvent.Undo:
      return Object.assign(Object.assign({}, state), {
        data: undo(state.data)
      });

    case GraphCanvasEvent.Redo:
      return Object.assign(Object.assign({}, state), {
        data: redo(state.data)
      });

    case GraphCanvasEvent.KeyDown:
      {
        const key = action.rawEvent.key.toLowerCase();

        if (state.activeKeys.has(key)) {
          return state;
        }

        const set = new Set(state.activeKeys);
        set.add(key);
        return Object.assign(Object.assign({}, state), {
          activeKeys: set
        });
      }

    case GraphCanvasEvent.KeyUp:
      {
        const key = action.rawEvent.key.toLowerCase();

        if (!state.activeKeys.has(key)) {
          return state;
        }

        const set = new Set(state.activeKeys);
        set.delete(key);
        return Object.assign(Object.assign({}, state), {
          activeKeys: set
        });
      }

    case GraphCanvasEvent.SetData:
      return Object.assign(Object.assign({}, state), {
        data: resetUndoStack(action.data)
      });

    case GraphCanvasEvent.UpdateData:
      return Object.assign(Object.assign({}, state), {
        data: action.shouldRecord ? pushHistory(state.data, action.updater(state.data.present)) : Object.assign(Object.assign({}, state.data), {
          present: action.updater(state.data.present)
        })
      });

    case GraphCanvasEvent.ResetUndoStack:
      return Object.assign(Object.assign({}, state), {
        data: resetUndoStack(state.data.present)
      });

    case GraphCanvasEvent.UpdateSettings:
      {
        const settings = __rest(action, ["type"]);

        return Object.assign(Object.assign({}, state), {
          settings: Object.assign(Object.assign({}, state.settings), settings)
        });
      }

    default:
      return state;
  }
};

function composeReducers(reducers) {
  return next => reducers.reduceRight((prev, current) => current(prev), next);
}

const VisitPortHelper = props => {
  const {
    neighborPorts,
    data
  } = props;
  const selectRef = React.useRef(null);
  const [selectedItem, setSelectedItem] = React.useState();
  const onContainerKeyDown = React.useCallback(evt => {
    if (evt.key === "Escape") {
      evt.stopPropagation();
      evt.preventDefault();

      if (selectedItem) {
        props.onComplete(selectedItem);
      }
    }
  }, [selectedItem, props]);
  const onContainerBlur = React.useCallback(() => {//
  }, []);
  const onContainerChange = React.useCallback(evt => {
    const value = JSON.parse(evt.target.value);

    if (value.nodeId && value.portId) {
      setSelectedItem({
        nodeId: value.nodeId,
        portId: value.portId
      });
    }
  }, [setSelectedItem]);
  React.useEffect(() => {
    if (selectRef.current) {
      selectRef.current.focus({
        preventScroll: true
      });
    }
  }, []);
  return jsx("select", Object.assign({
    onKeyDown: onContainerKeyDown,
    onBlur: onContainerBlur,
    ref: selectRef,
    onChange: onContainerChange
  }, {
    children: neighborPorts.map(s => {
      const isSelected = selectedItem && selectedItem.portId === s.portId && selectedItem.nodeId === s.nodeId;
      const value = JSON.stringify(s);
      const node = data.nodes.get(s.nodeId);

      if (!node) {
        return null;
      }

      const port = node.ports ? node.ports.filter(p => p.id === s.portId)[0] : null;

      if (!port) {
        return null;
      }

      const label = `${node.ariaLabel || node.name || node.id}: ${port.ariaLabel || port.name || port.id}`;
      return jsx("option", Object.assign({
        value: value,
        "aria-selected": isSelected,
        "aria-label": label
      }, {
        children: label
      }), `${s.nodeId}-${s.portId}`);
    })
  }));
};

const item = (node = undefined, port = undefined) => ({
  node,
  port
});

const findDOMElement = (svg, {
  node,
  port
}) => {
  var _a, _b;

  let id;

  if (node && port) {
    id = getPortUid((_a = svg.dataset.graphId) !== null && _a !== void 0 ? _a : "", node, port);
  } else if (node) {
    id = getNodeUid((_b = svg.dataset.graphId) !== null && _b !== void 0 ? _b : "", node);
  } else {
    return null;
  }

  return svg.getElementById(id);
};
const focusItem = (svgRef, nextItem, evt, eventChannel) => {
  if (!svgRef.current) {
    return;
  }

  const el = findDOMElement(svgRef.current, nextItem);

  if (el) {
    evt.preventDefault();
    evt.stopPropagation();
    el.focus({
      preventScroll: true
    });
    eventChannel.trigger({
      type: GraphCanvasEvent.Navigate,
      node: nextItem.node,
      port: nextItem.port,
      rawEvent: evt
    });
  } else if (!nextItem.node && !nextItem.port) {
    eventChannel.trigger({
      type: GraphCanvasEvent.Navigate,
      node: nextItem.node,
      port: nextItem.port,
      rawEvent: evt
    });
  }
};
const getNextItem = (data, curNode, port) => {
  if (curNode.ports) {
    const portIndex = port ? curNode.ports.findIndex(p => p.id === port.id) : -1;
    const nextPortIndex = portIndex + 1;

    if (nextPortIndex < curNode.ports.length) {
      return item(curNode, curNode.ports[nextPortIndex]);
    }
  }

  const nextNode = curNode.next && data.nodes.get(curNode.next);

  if (nextNode) {
    return item(nextNode);
  }

  return item();
};
const getPrevItem = (data, curNode, port) => {
  if (port && curNode.ports) {
    const prevPortIndex = curNode.ports.findIndex(p => p.id === port.id) - 1;

    if (prevPortIndex >= 0) {
      return item(curNode, curNode.ports[prevPortIndex]);
    }

    return item(curNode);
  }

  const prevNode = curNode.prev && data.nodes.get(curNode.prev);

  if (prevNode) {
    return item(prevNode, prevNode.ports && prevNode.ports.length ? prevNode.ports[prevNode.ports.length - 1] : undefined);
  }

  return item();
};
const nextConnectablePort = (graphConfig, params) => (data, node, port) => {
  var _a, _b, _c;

  let next = getNextItem(data, node, port);

  while (!(((_a = next.node) === null || _a === void 0 ? void 0 : _a.id) === node.id && ((_b = next.port) === null || _b === void 0 ? void 0 : _b.id) === (port === null || port === void 0 ? void 0 : port.id))) {
    if (!next.node) {
      next = item(data.getNavigationFirstNode());
    } else if (next.port) {
      if ((_c = graphConfig.getPortConfig(next.port)) === null || _c === void 0 ? void 0 : _c.getIsConnectable(Object.assign(Object.assign({}, params), {
        data,
        parentNode: next.node,
        model: next.port
      }))) {
        return next;
      }
    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion


    next = getNextItem(data, next.node, next.port);
  }

  return item();
};
const focusNextPort = (ports, node, curPortId, svgRef, evt, eventChannel) => {
  const curPortIndex = ports.findIndex(p => p.id === curPortId);
  const nextPortIndex = (curPortIndex + 1) % ports.length;
  const nextPort = ports[nextPortIndex];

  if (nextPort && svgRef.current) {
    focusItem(svgRef, {
      node,
      port: nextPort
    }, evt, eventChannel);
  }
};
const focusPrevPort = (ports, node, curPortId, svgRef, evt, eventChannel) => {
  const curPortIndex = ports.findIndex(p => p.id === curPortId);
  const prevPortIndex = (curPortIndex - 1 + ports.length) % ports.length;
  const prevPort = ports[prevPortIndex];

  if (prevPort && svgRef.current) {
    focusItem(svgRef, {
      node,
      port: prevPort
    }, evt, eventChannel);
  }
};
const getFocusNodeHandler = compareFn => (data, curNodeId, svgRef, graphController, evt, eventChannel) => {
  const sortedNodes = Array.from(data.nodes.values()).sort(compareFn);
  const curNodeIndex = sortedNodes.findIndex(n => n.id === curNodeId);
  const nextNode = sortedNodes[(curNodeIndex + 1) % sortedNodes.length];

  if (nextNode && svgRef.current) {
    graphController.dispatch({
      type: GraphNodeEvent.Select,
      nodes: [nextNode.id]
    });
    graphController.dispatch({
      type: GraphNodeEvent.Centralize,
      nodes: [nextNode.id]
    });
    focusItem(svgRef, {
      node: nextNode,
      port: undefined
    }, evt, eventChannel);
  }
};
const focusLeftNode = getFocusNodeHandler((n1, n2) => n1.x * 10 + n1.y - n2.x * 10 - n2.y);
const focusRightNode = getFocusNodeHandler((n1, n2) => n2.x * 10 + n2.y - n1.x * 10 - n1.y);
const focusDownNode = getFocusNodeHandler((n1, n2) => n1.x + n1.y * 10 - n2.x - n2.y * 10);
const focusUpNode = getFocusNodeHandler((n1, n2) => n2.x + n2.y * 10 - n1.x - n1.y * 10);
const goToConnectedPort = (data, node, port, svgRef, evt, eventChannel) => {
  var _a;

  const neighborPorts = getNeighborPorts(data, node.id, port.id);

  if (neighborPorts.length === 1 && svgRef.current) {
    const targetNode = data.nodes.get(neighborPorts[0].nodeId);

    if (!targetNode) {
      return;
    }

    const targetPort = (_a = targetNode.ports) === null || _a === void 0 ? void 0 : _a.find(p => p.id === neighborPorts[0].portId);

    if (!targetPort) {
      return;
    }

    focusItem(svgRef, {
      node: targetNode,
      port: targetPort
    }, evt, eventChannel);
  } else if (neighborPorts.length > 1 && svgRef.current) {
    const onComplete = nextPort => {
      var _a;

      ReactDOM.unmountComponentAtNode(visitPortHelperContainer);

      if (svgRef.current) {
        const curEditorContainer = svgRef.current.closest(".react-dag-editor-container");

        if (curEditorContainer) {
          curEditorContainer.removeChild(visitPortHelperContainer);
        }
      }

      const targetNode = data.nodes.get(nextPort.nodeId);

      if (!targetNode) {
        return;
      }

      const targetPort = (_a = targetNode.ports) === null || _a === void 0 ? void 0 : _a.find(p => p.id === nextPort.portId);

      if (!targetPort) {
        return;
      }

      focusItem(svgRef, {
        node: targetNode,
        port: targetPort
      }, evt, eventChannel);
    };

    const visitPortHelperContainer = document.createElement("div");
    const editorContainer = svgRef.current.closest(".react-dag-editor-container");

    if (editorContainer) {
      editorContainer.appendChild(visitPortHelperContainer);
    }

    visitPortHelperContainer.style.position = "fixed";
    visitPortHelperContainer.style.top = "0";
    ReactDOM.render(jsx(VisitPortHelper, {
      neighborPorts: neighborPorts,
      // eslint-disable-next-line react/jsx-no-bind
      onComplete: onComplete,
      data: data
    }), visitPortHelperContainer);
  }
};
/**
 * @param _data graph data
 * @param _node node model
 * @param port port data
 *
 * @returns port arial label
 */

function defaultGetPortAriaLabel(_data, _node, port) {
  return port.ariaLabel;
}
/**
 *
 * @param node the node data
 *
 * @returns the string value for the aria label
 */

function defaultGetNodeAriaLabel(node) {
  return node.ariaLabel;
}

function attachPort(state, nodeId, portId) {
  if (!state.connectState) {
    return state;
  }

  let data = state.data.present;
  data = data.updatePort(nodeId, portId, updateStatus(add(GraphPortStatus.ConnectingAsTarget)));

  if (state.connectState.targetNode && state.connectState.targetPort) {
    data = data.updatePort(state.connectState.targetNode, state.connectState.targetPort, updateStatus(remove(GraphPortStatus.ConnectingAsTarget)));
  }

  return Object.assign(Object.assign({}, state), {
    connectState: Object.assign(Object.assign({}, state.connectState), {
      targetNode: nodeId,
      targetPort: portId
    }),
    data: Object.assign(Object.assign({}, state.data), {
      present: data
    })
  });
}

function clearAttach(state) {
  if (!state.connectState) {
    return state;
  }

  let data = state.data.present;
  const {
    targetPort,
    targetNode
  } = state.connectState;

  if (targetNode && targetPort) {
    data = data.updatePort(targetNode, targetPort, updateStatus(remove(GraphPortStatus.ConnectingAsTarget)));
  }

  return Object.assign(Object.assign({}, state), {
    connectState: Object.assign(Object.assign({}, state.connectState), {
      targetNode: undefined,
      targetPort: undefined
    }),
    data: Object.assign(Object.assign({}, state.data), {
      present: data
    })
  });
} // eslint-disable-next-line complexity


const connectingReducer = (state, action) => {
  var _a, _b, _c;

  if (!isViewportComplete(state.viewport)) {
    return state;
  }

  const {
    rect
  } = state.viewport;

  switch (action.type) {
    case GraphEdgeEvent.ConnectStart:
      return Object.assign(Object.assign({}, state), {
        connectState: Object.assign(Object.assign({}, EMPTY_CONNECT_STATE), {
          sourceNode: action.nodeId,
          sourcePort: action.portId,
          movingPoint: action.clientPoint ? {
            x: action.clientPoint.x - rect.left,
            y: action.clientPoint.y - rect.top
          } : undefined
        }),
        data: Object.assign(Object.assign({}, state.data), {
          present: state.data.present.updatePort(action.nodeId, action.portId, updateStatus(add(GraphPortStatus.Connecting)))
        })
      });

    case GraphEdgeEvent.ConnectMove:
      if (state.connectState) {
        return Object.assign(Object.assign({}, state), {
          connectState: Object.assign(Object.assign({}, state.connectState), {
            movingPoint: {
              x: action.clientX - rect.left,
              y: action.clientY - rect.top
            }
          })
        });
      }

      return state;

    case GraphEdgeEvent.ConnectEnd:
      if (state.connectState) {
        const {
          edgeWillAdd,
          isCancel
        } = action;
        const {
          sourceNode,
          sourcePort,
          targetNode,
          targetPort
        } = state.connectState;
        let data = state.data.present;
        data = data.updatePort(sourceNode, sourcePort, updateStatus(replace(GraphPortStatus.Default)));

        if (!isCancel && targetNode && targetPort) {
          let edge = {
            source: sourceNode,
            sourcePortId: sourcePort,
            target: targetNode,
            targetPortId: targetPort,
            id: v4(),
            status: GraphEdgeStatus.Default
          };

          if (edgeWillAdd) {
            edge = edgeWillAdd(edge, data);
          }

          data = data.insertEdge(edge).updatePort(targetNode, targetPort, updateStatus(replace(GraphPortStatus.Default)));
          return Object.assign(Object.assign({}, state), {
            connectState: undefined,
            data: pushHistory(state.data, data, unSelectAllEntity())
          });
        }

        return Object.assign(Object.assign({}, state), {
          connectState: undefined,
          data: Object.assign(Object.assign({}, state.data), {
            present: data
          })
        });
      }

      return state;

    case GraphEdgeEvent.ConnectNavigate:
      if (state.connectState) {
        const data = state.data.present;
        const sourceNode = data.nodes.get(state.connectState.sourceNode);
        const sourcePort = sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.getPort(state.connectState.sourcePort);
        const targetNode = state.connectState.targetNode ? data.nodes.get(state.connectState.targetNode) : undefined;
        const targetPort = state.connectState.targetPort ? targetNode === null || targetNode === void 0 ? void 0 : targetNode.getPort(state.connectState.targetPort) : undefined;

        if (!sourceNode || !sourcePort) {
          return state;
        }

        const next = nextConnectablePort(state.settings.graphConfig, {
          anotherNode: sourceNode,
          anotherPort: sourcePort
        })(data, targetNode || sourceNode, targetPort);

        if (!next.node || !next.port || next.node.id === sourceNode.id && next.port.id === sourcePort.id) {
          return state;
        }

        return attachPort(state, next.node.id, next.port.id);
      }

      return state;

    case GraphPortEvent.PointerEnter:
      if (state.connectState) {
        const {
          sourceNode,
          sourcePort
        } = state.connectState;
        const data = state.data.present;
        const node = data.nodes.get(action.node.id);
        const port = node === null || node === void 0 ? void 0 : node.getPort(action.port.id);
        const anotherNode = data.nodes.get(sourceNode);
        const anotherPort = anotherNode === null || anotherNode === void 0 ? void 0 : anotherNode.getPort(sourcePort);

        if (node && port && anotherNode && anotherPort && isConnectable(state.settings.graphConfig, {
          parentNode: node,
          model: port,
          data,
          anotherPort,
          anotherNode
        })) {
          return attachPort(state, node.id, port.id);
        }
      }

      return state;

    case GraphNodeEvent.PointerEnter:
    case GraphNodeEvent.PointerMove:
      if (state.connectState) {
        const {
          clientX,
          clientY
        } = action.rawEvent;
        const {
          sourceNode,
          sourcePort
        } = state.connectState;
        const data = state.data.present;
        const node = data.nodes.get(action.node.id);
        const anotherNode = data.nodes.get(sourceNode);
        const anotherPort = anotherNode === null || anotherNode === void 0 ? void 0 : anotherNode.getPort(sourcePort);

        if (node && anotherNode && anotherPort) {
          const targetPort = getNearestConnectablePort({
            parentNode: node,
            clientX,
            clientY,
            graphConfig: state.settings.graphConfig,
            data: state.data.present,
            viewport: state.viewport,
            anotherPort,
            anotherNode
          });

          if (!targetPort) {
            return state;
          }

          return attachPort(state, node.id, targetPort.id);
        }
      }

      return state;

    case GraphNodeEvent.PointerLeave:
      if (((_a = state.connectState) === null || _a === void 0 ? void 0 : _a.targetNode) === action.node.id) {
        return clearAttach(state);
      }

      return state;

    case GraphPortEvent.PointerLeave:
      if (((_b = state.connectState) === null || _b === void 0 ? void 0 : _b.targetNode) === action.node.id && ((_c = state.connectState) === null || _c === void 0 ? void 0 : _c.targetPort) === action.port.id) {
        return clearAttach(state);
      }

      return state;

    default:
      return state;
  }
};

const contextMenuReducer = (prevState, action) => {
  let nextContextMenuPosition = prevState.contextMenuPosition;

  switch (action.type) {
    case GraphCanvasEvent.ContextMenu:
    case GraphNodeEvent.ContextMenu:
    case GraphEdgeEvent.ContextMenu:
    case GraphPortEvent.ContextMenu:
      {
        const e = action.rawEvent;

        if (e.button === MouseEventButton.Secondary) {
          nextContextMenuPosition = {
            x: e.clientX,
            y: e.clientY
          };
        }
      }
      break;

    case GraphCanvasEvent.Click:
    case GraphNodeEvent.Click:
    case GraphEdgeEvent.Click:
    case GraphPortEvent.Click:
      nextContextMenuPosition = undefined;
      break;

    case GraphContextMenuEvent.Open:
      nextContextMenuPosition = {
        x: action.x,
        y: action.y
      };
      break;

    case GraphContextMenuEvent.Close:
      nextContextMenuPosition = undefined;
      break;
  }

  if (prevState.contextMenuPosition === nextContextMenuPosition) {
    return prevState;
  }

  return Object.assign(Object.assign({}, prevState), {
    contextMenuPosition: nextContextMenuPosition
  });
};

const edgeReducer = (state, action) => {
  switch (action.type) {
    case GraphEdgeEvent.DoubleClick:
      if (!state.settings.features.has(GraphFeatures.EditEdge)) {
        return state;
      }

      return Object.assign(Object.assign({}, state), {
        data: Object.assign(Object.assign({}, state.data), {
          present: state.data.present.updateEdge(action.edge.id, updateStatus(replace(GraphEdgeStatus.Editing)))
        })
      });

    case GraphEdgeEvent.MouseEnter:
      return Object.assign(Object.assign({}, state), {
        data: Object.assign(Object.assign({}, state.data), {
          present: state.data.present.updateEdge(action.edge.id, updateStatus(add(GraphEdgeStatus.Activated)))
        })
      });

    case GraphEdgeEvent.MouseLeave:
      return Object.assign(Object.assign({}, state), {
        data: Object.assign(Object.assign({}, state.data), {
          present: state.data.present.updateEdge(action.edge.id, updateStatus(remove(GraphEdgeStatus.Activated)))
        })
      });

    case GraphEdgeEvent.Click:
    case GraphEdgeEvent.ContextMenu:
      return Object.assign(Object.assign({}, state), {
        data: Object.assign(Object.assign({}, state.data), {
          present: unSelectAllEntity()(state.data.present).updateEdge(action.edge.id, updateStatus(add(GraphEdgeStatus.Selected)))
        })
      });

    case GraphEdgeEvent.Add:
      return Object.assign(Object.assign({}, state), {
        data: pushHistory(state.data, state.data.present.insertEdge(action.edge))
      });

    default:
      return state;
  }
};

/**
 * get alignment lines
 * @param draggingNodes the dragging node(s)
 * @param nodes all nodes to find the alignment lines
 * @param graphConfig graphConfig of type IGraphConfig
 * @param threshold threshold to align, default is 2
 */

const getAlignmentLines = (draggingNodes, nodes, graphConfig, threshold = 2) => {
  const dummyDraggingNodeHW = getDummyDraggingNode(draggingNodes);
  const closestNodes = getClosestNodes(dummyDraggingNodeHW, draggingNodes, nodes, graphConfig, threshold);
  return getLines(dummyDraggingNodeHW, closestNodes, draggingNodes.length);
};
/**
 * get the dx or dy to auto align/attach
 * @param alignmentLines all alignment lines
 * @param nodes the dragging dummy node(s)
 * @param _graphConfig graphConfig of type IGraphConfig
 */

const getAutoAlignDisplacement = (alignmentLines, nodes, _graphConfig, alignDirection) => {
  let min = Infinity;
  let res = 0;
  const nodeHW = getDummyDraggingNode(nodes);
  const widthOrHeight = alignDirection === "x" ? nodeHW.width || 0 : nodeHW.height || 0;
  alignmentLines.forEach(item => {
    let alignLine;

    if (alignDirection === "x" && item.x1 === item.x2) {
      alignLine = item.x1;
    } else if (alignDirection === "y" && item.y1 === item.y2) {
      alignLine = item.y1;
    } else {
      return;
    }

    const distance1 = nodeHW[alignDirection] - alignLine;
    const distanceMiddle = nodeHW[alignDirection] + (widthOrHeight || 0) / 2 - alignLine;
    const distance2 = nodeHW[alignDirection] + (widthOrHeight || 0) - alignLine;

    if (Math.abs(distance1) < min) {
      min = Math.abs(distance1);
      res = distance1 > 0 ? -min : min;
    }

    if (Math.abs(distanceMiddle) < min) {
      min = Math.abs(distanceMiddle);
      res = distanceMiddle > 0 ? -min : min;
    }

    if (Math.abs(distance2) < min) {
      min = Math.abs(distance2);
      res = distance2 > 0 ? -min : min;
    }
  });
  return res;
};
/**
 * get min coordinate of nodes
 * @param nodes among these nodes to get the min coordinate
 * @param field "x"|"y"
 */

const getMinCoordinate = (nodes, field) => {
  if (!nodes.length) {
    return undefined;
  }

  return Math.min(...nodes.map(n => n[field]));
};
/**
 * get max coordinate of nodes
 * @param nodes among these nodes to get the max coordinate
 * @param field "x"|"y"
 */


const getMaxCoordinate = (nodes, field) => {
  if (!nodes.length) {
    return undefined;
  }

  return Math.max(...nodes.map(n => n[field] + (field === "y" ? n.height || 0 : n.width || 0)));
};
/**
 * set height and width for a node, and return the new node
 * @param node the node to set height and width
 * @param graphConfig graphConfig of type IGraphConfig
 */


const setSizeForNode = (node, graphConfig) => {
  return Object.assign(Object.assign({}, node), getNodeSize(node, graphConfig));
};
/**
 * get the bounding box of the nodes
 * @param nodes the nodes to calculate the bounding box
 */


const getBoundingBoxOfNodes = nodes => {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  nodes.forEach(n => {
    const tempMinX = n.x;
    const tempMinY = n.y;
    const tempMaxX = n.x + (n.width || 0);
    const tempMaxY = n.y + (n.height || 0);

    if (tempMinX < minX) {
      minX = tempMinX;
    }

    if (tempMinY < minY) {
      minY = tempMinY;
    }

    if (tempMaxX > maxX) {
      maxX = tempMaxX;
    }

    if (tempMaxY > maxY) {
      maxY = tempMaxY;
    }
  });
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
};
/**
 * get dummy dragging node constructed by all dragging nodes
 * @param draggingNodes all dragging nodes
 * @param graphConfig graphConfig of type IGraphConfig
 */


const getDummyDraggingNode = draggingNodes => {
  const {
    x,
    y,
    width,
    height
  } = getBoundingBoxOfNodes(draggingNodes);
  const dummyDraggingNode = {
    id: v4(),
    x,
    y,
    width,
    height
  };
  return dummyDraggingNode;
};
/**
 * get the nodes closest to(within the threshold) the different sides of the dragging node(s)
 * @param dummyDraggingNode the dummy dragging node constructed by the dragging nodes
 * @param draggingNodes the dragging node(s)
 * @param nodes among these nodes to get the closest nodes
 * @param graphConfig graphConfig of type IGraphConfig
 * @param threshold threshold to align
 */


const getClosestNodes = (dummyDraggingNode, draggingNodes, nodes, graphConfig, threshold = 2) => {
  const resX = []; // will has 3 items: the nodes closest to the "left side", "middle", "right side" (the order must follow this) of the dragging node

  const resY = []; // will has 3 items: the nodes closest to the "top", "middle", "bottom" (the order must follow this) of the dragging node

  const {
    x: draggingNodeX,
    y: draggingNodeY,
    width: draggingNodeWidth = 0,
    height: draggingNodeHeight = 0
  } = dummyDraggingNode;
  let minDistanceX = threshold;
  let minDistanceY = threshold;
  nodes.forEach(node => {
    if (draggingNodes.find(dn => dn.id === node.id)) {
      return;
    }

    const nodeHW = setSizeForNode(node, graphConfig);
    const {
      width: nodeWidth = 0,
      height: nodeHeight = 0
    } = nodeHW; // compare X coordinate of dragging node

    [draggingNodeX, draggingNodeX + draggingNodeWidth / 2, draggingNodeX + draggingNodeWidth].forEach((draggingNodeValue, alignPos) => {
      if (!resX[alignPos]) {
        resX[alignPos] = {};
      }

      if (!resX[alignPos].closestNodes) {
        resX[alignPos].closestNodes = [];
      }

      [nodeHW.x, nodeHW.x + nodeWidth / 2, nodeHW.x + nodeWidth].forEach(comparedValue => {
        var _a;

        const distance = Math.abs(draggingNodeValue - comparedValue);

        if (distance <= minDistanceX) {
          (_a = resX[alignPos].closestNodes) === null || _a === void 0 ? void 0 : _a.push(nodeHW);
          resX[alignPos].alignCoordinateValue = comparedValue;
          minDistanceX = distance;
        }
      });
    }); // compare Y coordinate of dragging node

    [draggingNodeY, draggingNodeY + draggingNodeHeight / 2, draggingNodeY + draggingNodeHeight].forEach((draggingNodeValue, alignPos) => {
      if (!resY[alignPos]) {
        resY[alignPos] = {};
      }

      if (!resY[alignPos].closestNodes) {
        resY[alignPos].closestNodes = [];
      }

      [nodeHW.y, nodeHW.y + nodeHeight / 2, nodeHW.y + nodeHeight].forEach(comparedValue => {
        var _a;

        const distance = Math.abs(draggingNodeValue - comparedValue);

        if (distance <= minDistanceY) {
          (_a = resY[alignPos].closestNodes) === null || _a === void 0 ? void 0 : _a.push(nodeHW);
          resY[alignPos].alignCoordinateValue = comparedValue;
          minDistanceY = distance;
        }
      });
    });
  });
  return {
    closestX: resX,
    closestY: resY
  };
};
/**
 * get alignment lines
 * @param draggingNode the dragging node
 * @param closestNodes all closest nodes within the threshold
 */


const getLines = (draggingNode, closestNodes, numberOfDraggingNodes = 1) => {
  const xLines = [];
  const yLines = [];
  const closestXNodes = closestNodes.closestX;
  const closestYNodes = closestNodes.closestY; // vertical lines

  closestXNodes.forEach((item, alignPos) => {
    var _a;

    if (item.alignCoordinateValue === undefined || // if it has the left alignment line for the dragging node OR has multi dragging nodes, will don't need middle alignment line
    alignPos === 1 && (xLines.length || numberOfDraggingNodes > 1)) {
      return;
    }

    const sameXNodes = [];
    const x = item.alignCoordinateValue;
    (_a = item.closestNodes) === null || _a === void 0 ? void 0 : _a.forEach(node => {
      if (node.x === x || node.x + (node.width || 0) / 2 === x || node.x + (node.width || 0) === x) {
        sameXNodes.push(node);
      }
    });
    const y1 = getMinCoordinate([draggingNode, ...sameXNodes], "y");
    const y2 = getMaxCoordinate([draggingNode, ...sameXNodes], "y");

    if (y1 !== undefined && y2 !== undefined) {
      xLines.push({
        x1: x,
        y1,
        x2: x,
        y2,
        visible: true
      });
    }
  }); // horizontal lines

  closestYNodes.forEach((item, alignPos) => {
    var _a;

    if (item.alignCoordinateValue === undefined || // if it has the top alignment line for the dragging node OR has multi dragging nodes, will don't need middle alignment line
    alignPos === 1 && (yLines.length || numberOfDraggingNodes > 1)) {
      return;
    }

    const sameYNodes = [];
    const y = item.alignCoordinateValue;
    (_a = item.closestNodes) === null || _a === void 0 ? void 0 : _a.forEach(node => {
      if (node.y === y || node.y + (node.height || 0) / 2 === y || node.y + (node.height || 0) === y) {
        sameYNodes.push(node);
      }
    });
    const x1 = getMinCoordinate([draggingNode, ...sameYNodes], "x");
    const x2 = getMaxCoordinate([draggingNode, ...sameYNodes], "x");

    if (x1 !== undefined && x2 !== undefined) {
      yLines.push({
        x1,
        y1: y,
        x2,
        y2: y,
        visible: true
      });
    }
  });
  return [...xLines, ...yLines];
};

function pipe(...args) {
  return args.reduceRight((result, current) => value => result(current(value)), identical);
}

const getDelta = (start, end, value) => {
  if (value < start) {
    return -10;
  }

  if (value > end) {
    return 10;
  }

  return 0;
};

function getSelectedNodes(data, graphConfig) {
  const nodes = [];
  data.nodes.forEach(node => {
    if (!isSelected(node)) {
      return;
    }

    nodes.push(Object.assign({
      id: node.id,
      x: node.x,
      y: node.y
    }, getNodeSize(node, graphConfig)));
  });
  return nodes;
}

function dragNodeHandler(state, event) {
  if (!isViewportComplete(state.viewport)) {
    return state;
  }

  const limitScale = scale => {
    return Math.max(scale, getScaleLimit(data, state.settings));
  };

  const e = event.rawEvent;
  const {
    rect
  } = state.viewport;
  const nextState = Object.assign({}, state);
  const data = state.data.present;
  const viewportDx = getDelta(rect.left, rect.right, e.clientX);
  const viewportDy = getDelta(rect.top, rect.bottom, e.clientY);
  const scale = viewportDx !== 0 || viewportDy !== 0 ? 0.999 : 1;
  const viewport = viewportDx !== 0 || viewportDx !== 0 ? pipe(pan(-viewportDx, -viewportDy), zoom({
    scale,
    anchor: getRelativePoint(rect, e),
    direction: Direction.XY,
    limitScale
  }))(state.viewport) : state.viewport;
  const delta = getPointDeltaByClientDelta(event.dx + viewportDx * scale, event.dy + viewportDy * scale, viewport.transformMatrix);
  const dummyNodes = Object.assign(Object.assign({}, state.dummyNodes), {
    dx: state.dummyNodes.dx + delta.x,
    dy: state.dummyNodes.dy + delta.y,
    isVisible: event.isVisible
  });

  if (event.isAutoAlignEnable) {
    const renderedNodes = getRenderedNodes(data.nodes, state.viewport);

    if (renderedNodes.length < event.autoAlignThreshold) {
      const nodes = dummyNodes.nodes.map(it => Object.assign(Object.assign({}, it), {
        x: it.x + dummyNodes.dx,
        y: it.y + dummyNodes.dy
      }));
      const alignmentLines = getAlignmentLines(nodes, renderedNodes, state.settings.graphConfig, state.viewport.transformMatrix[0] > 0.3 ? 2 : 5);

      if (alignmentLines.length) {
        const dxAligned = getAutoAlignDisplacement(alignmentLines, nodes, state.settings.graphConfig, "x");
        const dyAligned = getAutoAlignDisplacement(alignmentLines, nodes, state.settings.graphConfig, "y");
        dummyNodes.alignedDX = dummyNodes.dx + dxAligned;
        dummyNodes.alignedDY = dummyNodes.dy + dyAligned;
      } else {
        dummyNodes.alignedDX = undefined;
        dummyNodes.alignedDY = undefined;
      }

      nextState.alignmentLines = alignmentLines;
    } else {
      dummyNodes.alignedDX = undefined;
      dummyNodes.alignedDY = undefined;
    }
  }

  nextState.dummyNodes = dummyNodes;
  nextState.viewport = viewport;
  return nextState;
}

function handleDraggingNewNode(state, action) {
  if (!state.settings.features.has(GraphFeatures.AutoAlign)) {
    return state;
  }

  const data = state.data.present;
  const renderedNodes = getRenderedNodes(data.nodes, state.viewport);
  const alignmentLines = getAlignmentLines([action.node], renderedNodes, state.settings.graphConfig, state.viewport.transformMatrix[0] > 0.3 ? 2 : 5);
  return Object.assign(Object.assign({}, state), {
    alignmentLines
  });
}

function dragStart(state, action) {
  let data = state.data.present;
  const targetNode = data.nodes.get(action.node.id);

  if (!targetNode) {
    return state;
  }

  let selectedNodes;

  if (action.isMultiSelect) {
    data = data.selectNodes(node => node.id === action.node.id || isSelected(node));
    selectedNodes = getSelectedNodes(data, state.settings.graphConfig);
  } else if (!isSelected(targetNode)) {
    selectedNodes = [Object.assign({
      id: action.node.id,
      x: action.node.x,
      y: action.node.y
    }, getNodeSize(action.node, state.settings.graphConfig))];
  } else {
    selectedNodes = getSelectedNodes(data, state.settings.graphConfig);
  }

  return Object.assign(Object.assign({}, state), {
    data: Object.assign(Object.assign({}, state.data), {
      present: data
    }),
    dummyNodes: Object.assign(Object.assign({}, emptyDummyNodes()), {
      isVisible: false,
      nodes: selectedNodes
    })
  });
}

function dragEnd(state, action) {
  let data = state.data.present;

  if (action.isDragCanceled) {
    return Object.assign(Object.assign({}, state), {
      alignmentLines: [],
      dummyNodes: emptyDummyNodes()
    });
  }

  const {
    dx,
    dy
  } = state.dummyNodes;
  data = data.updateNodesPositionAndSize(state.dummyNodes.nodes.map(node => Object.assign(Object.assign({}, node), {
    x: node.x + dx,
    y: node.y + dy,
    width: undefined,
    height: undefined
  })));
  return Object.assign(Object.assign({}, state), {
    alignmentLines: [],
    dummyNodes: emptyDummyNodes(),
    data: pushHistory(state.data, data, unSelectAllEntity())
  });
} // centralize node or locate node to the specific position


function locateNode(action, state) {
  const data = state.data.present;

  if (!isViewportComplete(state.viewport) || !action.nodes.length) {
    return state;
  }

  if (action.nodes.length === 1) {
    const nodeId = action.nodes[0];
    const node = data.nodes.get(nodeId);

    if (!node) {
      return state;
    }

    const {
      width,
      height
    } = getNodeSize(node, state.settings.graphConfig);
    const nodeX = action.type === GraphNodeEvent.Centralize ? node.x + width / 2 : node.x;
    const nodeY = action.type === GraphNodeEvent.Centralize ? node.y + height / 2 : node.y;
    const {
      x: clientX,
      y: clientY
    } = transformPoint(nodeX, nodeY, state.viewport.transformMatrix);
    const position = action.type === GraphNodeEvent.Locate ? action.position : undefined;
    return Object.assign(Object.assign({}, state), {
      viewport: scrollIntoView(clientX, clientY, state.viewport.rect, true, position)(state.viewport)
    });
  }

  const {
    minNodeX,
    minNodeY,
    maxNodeX,
    maxNodeY
  } = getContentArea$1(data, state.settings.graphConfig, new Set(action.nodes));
  return Object.assign(Object.assign({}, state), {
    viewport: focusArea(minNodeX, minNodeY, maxNodeX, maxNodeY, state.viewport)
  });
}

const nodeReducer = (state, action) => {
  const data = state.data.present;

  switch (action.type) {
    //#region resize
    case GraphNodeEvent.ResizingStart:
      return Object.assign(Object.assign({}, state), {
        dummyNodes: Object.assign(Object.assign({}, emptyDummyNodes()), {
          isVisible: true,
          nodes: getSelectedNodes(data, state.settings.graphConfig)
        })
      });

    case GraphNodeEvent.Resizing:
      return Object.assign(Object.assign({}, state), {
        dummyNodes: Object.assign(Object.assign({}, state.dummyNodes), {
          dx: action.dx,
          dy: action.dy,
          dWidth: action.dWidth,
          dHeight: action.dHeight
        })
      });

    case GraphNodeEvent.ResizingEnd:
      {
        const {
          dx,
          dy,
          dWidth,
          dHeight
        } = state.dummyNodes;
        return Object.assign(Object.assign({}, state), {
          dummyNodes: emptyDummyNodes(),
          data: pushHistory(state.data, data.updateNodesPositionAndSize(state.dummyNodes.nodes.map(node => Object.assign(Object.assign({}, node), {
            x: node.x + dx,
            y: node.y + dy,
            width: node.width + dWidth,
            height: node.height + dHeight
          }))), unSelectAllEntity())
        });
      }
    //#endregion resize
    //#region drag

    case GraphNodeEvent.DragStart:
      return dragStart(state, action);

    case GraphNodeEvent.Drag:
      return dragNodeHandler(state, action);

    case GraphNodeEvent.DragEnd:
      return dragEnd(state, action);
    //#endregion drag

    case GraphNodeEvent.PointerEnter:
      switch (state.behavior) {
        case GraphBehavior.Default:
          return Object.assign(Object.assign({}, state), {
            data: Object.assign(Object.assign({}, state.data), {
              present: data.updateNode(action.node.id, updateStatus(add(GraphNodeStatus.Activated)))
            })
          });

        default:
          return state;
      }

    case GraphNodeEvent.PointerLeave:
      switch (state.behavior) {
        case GraphBehavior.Default:
        case GraphBehavior.Connecting:
          return Object.assign(Object.assign({}, state), {
            data: Object.assign(Object.assign({}, state.data), {
              present: data.updateNode(action.node.id, updateStatus(remove(GraphNodeStatus.Activated)))
            })
          });

        default:
          return state;
      }

    case GraphCanvasEvent.DraggingNodeFromItemPanel:
      return handleDraggingNewNode(state, action);

    case GraphCanvasEvent.DraggingNodeFromItemPanelEnd:
      {
        if (action.node) {
          return Object.assign(Object.assign({}, state), {
            alignmentLines: [],
            data: pushHistory(state.data, state.data.present.insertNode(Object.assign(Object.assign({}, action.node), {
              status: GraphNodeStatus.Selected
            })), unSelectAllEntity())
          });
        }

        return Object.assign(Object.assign({}, state), {
          alignmentLines: []
        });
      }

    case GraphNodeEvent.Centralize:
    case GraphNodeEvent.Locate:
      return locateNode(action, state);

    case GraphNodeEvent.Add:
      return Object.assign(Object.assign({}, state), {
        data: pushHistory(state.data, data.insertNode(action.node))
      });

    case GraphNodeEvent.DoubleClick:
      return Object.assign(Object.assign({}, state), {
        data: Object.assign(Object.assign({}, state.data), {
          present: state.data.present.updateNode(action.node.id, updateStatus(add(GraphNodeStatus.Editing)))
        })
      });

    default:
      return state;
  }
};

const portReducer = (state, action) => {
  switch (action.type) {
    case GraphPortEvent.Focus:
    case GraphPortEvent.PointerEnter:
      return Object.assign(Object.assign({}, state), {
        data: Object.assign(Object.assign({}, state.data), {
          present: state.data.present.updatePort(action.node.id, action.port.id, updateStatus(add(GraphPortStatus.Activated)))
        })
      });

    case GraphPortEvent.Blur:
    case GraphPortEvent.PointerLeave:
      return Object.assign(Object.assign({}, state), {
        data: Object.assign(Object.assign({}, state.data), {
          present: state.data.present.updatePort(action.node.id, action.port.id, updateStatus(remove(GraphPortStatus.Activated)))
        })
      });

    case GraphPortEvent.Click:
    case GraphPortEvent.ContextMenu:
      return Object.assign(Object.assign({}, state), {
        data: Object.assign(Object.assign({}, state.data), {
          present: unSelectAllEntity()(state.data.present).updatePort(action.node.id, action.port.id, updateStatus(add(GraphPortStatus.Selected)))
        })
      });

    default:
      return state;
  }
};

const selectNodeBySelectBox = (graphConfig, transformMatrix, selectBox, data) => {
  if (!selectBox.width || !selectBox.height) {
    return data;
  }

  const selectAreaMinX = Math.min(selectBox.startX, selectBox.startX + selectBox.width);
  const selectAreaMaxX = Math.max(selectBox.startX, selectBox.startX + selectBox.width);
  const selectAreaMinY = Math.min(selectBox.startY, selectBox.startY + selectBox.height);
  const selectAreaMaxY = Math.max(selectBox.startY, selectBox.startY + selectBox.height);
  const primeSelectionMin = reverseTransformPoint(selectAreaMinX, selectAreaMinY, transformMatrix);
  const primeSelectionMax = reverseTransformPoint(selectAreaMaxX, selectAreaMaxY, transformMatrix); // padding box does not apply transform matrix

  const primeRectSelectionBox = {
    minX: primeSelectionMin.x,
    minY: primeSelectionMin.y,
    maxX: primeSelectionMax.x,
    maxY: primeSelectionMax.y
  };
  return data.selectNodes(n => {
    const {
      width,
      height
    } = getNodeSize(n, graphConfig);
    const rectNode = {
      minX: n.x,
      minY: n.y,
      maxX: n.x + width,
      maxY: n.y + height
    };
    return checkRectIntersect(primeRectSelectionBox, rectNode);
  });
};

function handleNavigate(state, action) {
  let data = unSelectAllEntity()(state.data.present);

  if (action.node && action.port) {
    data = data.updatePort(action.node.id, action.port.id, updateStatus(add(GraphPortStatus.Selected)));
  } else if (action.node) {
    const nodeId = action.node.id;
    data = data.selectNodes(node => node.id === nodeId);
  }

  return Object.assign(Object.assign({}, state), {
    data: Object.assign(Object.assign({}, state.data), {
      present: data
    })
  });
}

const selectionReducer = (state, action) => {
  var _a, _b;

  const data = state.data.present;
  const isLassoSelectEnable = state.settings.features.has(GraphFeatures.LassoSelect);

  switch (action.type) {
    case GraphCanvasEvent.Click:
    case GraphCanvasEvent.ResetSelection:
    case GraphCanvasEvent.ContextMenu:
      return Object.assign(Object.assign({}, state), {
        data: Object.assign(Object.assign({}, state.data), {
          present: unSelectAllEntity()(data)
        })
      });

    case GraphNodeEvent.Click:
    case GraphNodeEvent.ContextMenu:
      return Object.assign(Object.assign({}, state), {
        data: Object.assign(Object.assign({}, state.data), {
          present: nodeSelection(action.rawEvent, action.node)(data)
        })
      });

    case GraphCanvasEvent.SelectStart:
      {
        if (!isViewportComplete(state.viewport)) {
          return state;
        }

        const point = getRelativePoint(state.viewport.rect, action.rawEvent);
        return Object.assign(Object.assign({}, state), {
          data: Object.assign(Object.assign({}, state.data), {
            present: unSelectAllEntity()(data)
          }),
          selectBoxPosition: {
            startX: point.x,
            startY: !isLassoSelectEnable ? point.y : 0,
            width: 0,
            height: 0
          }
        });
      }

    case GraphCanvasEvent.SelectMove:
      if (state.behavior !== GraphBehavior.MultiSelect) {
        return state;
      }

      return Object.assign(Object.assign({}, state), {
        selectBoxPosition: Object.assign(Object.assign({}, state.selectBoxPosition), {
          width: state.selectBoxPosition.width + action.dx,
          height: !isLassoSelectEnable ? state.selectBoxPosition.height + action.dy : (_b = (_a = state.viewport.rect) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : state.selectBoxPosition.height
        })
      });

    case GraphCanvasEvent.SelectEnd:
      return Object.assign(Object.assign({}, state), {
        selectBoxPosition: emptySelectBoxPosition(),
        data: Object.assign(Object.assign({}, state.data), {
          present: selectNodeBySelectBox(state.settings.graphConfig, state.viewport.transformMatrix, state.selectBoxPosition, data)
        })
      });

    case GraphCanvasEvent.UpdateNodeSelectionBySelectBox:
      {
        if (state.behavior !== GraphBehavior.MultiSelect) {
          return state;
        }

        return Object.assign(Object.assign({}, state), {
          data: Object.assign(Object.assign({}, state.data), {
            present: selectNodeBySelectBox(state.settings.graphConfig, state.viewport.transformMatrix, state.selectBoxPosition, data)
          })
        });
      }

    case GraphCanvasEvent.Navigate:
      return handleNavigate(state, action);

    case GraphNodeEvent.SelectAll:
      return Object.assign(Object.assign({}, state), {
        data: Object.assign(Object.assign({}, state.data), {
          present: data.selectNodes(() => true)
        })
      });

    case GraphNodeEvent.Select:
      {
        const nodes = new Set(action.nodes);
        return Object.assign(Object.assign({}, state), {
          data: Object.assign(Object.assign({}, state.data), {
            present: data.selectNodes(node => nodes.has(node.id))
          })
        });
      }

    default:
      return state;
  }
};

function getRectCenter(rect) {
  return {
    x: rect.width / 2,
    y: rect.height / 2
  };
}

function resetViewport(viewport, data, graphConfig, action) {
  if (!isViewportComplete(viewport)) {
    return viewport;
  }

  if (!action.ensureNodeVisible) {
    return Object.assign(Object.assign({}, viewport), {
      transformMatrix: EMPTY_TRANSFORM_MATRIX
    });
  }

  const {
    nodes,
    groups
  } = data;

  if (nodes.size === 0) {
    return Object.assign(Object.assign({}, viewport), {
      transformMatrix: EMPTY_TRANSFORM_MATRIX
    });
  }

  const isShapeRectInViewport = r => {
    return isRectVisible(r, viewport);
  };

  const nodeRects = nodes.map(n => getNodeRect(n, graphConfig));
  const hasVisibleNode = nodeRects.find(isShapeRectInViewport);

  if (hasVisibleNode) {
    return Object.assign(Object.assign({}, viewport), {
      transformMatrix: EMPTY_TRANSFORM_MATRIX
    });
  }

  const groupRects = groups.map(g => getGroupRect(g, nodes, graphConfig));
  const hasVisibleGroup = groupRects.find(isShapeRectInViewport);

  if (hasVisibleGroup) {
    return Object.assign(Object.assign({}, viewport), {
      transformMatrix: EMPTY_TRANSFORM_MATRIX
    });
  } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion


  let focusNode = nodeRects.first();

  const findTopMostRect = cur => {
    if (focusNode.y > cur.y) {
      focusNode = cur;
    }
  };

  nodeRects.forEach(findTopMostRect);
  groupRects.forEach(findTopMostRect);
  return Object.assign(Object.assign({}, viewport), {
    transformMatrix: [1, 0, 0, 1, -focusNode.x, -focusNode.y]
  });
}

function zoomToFit(viewport, data, settings, action) {
  if (!isViewportComplete(viewport)) {
    return viewport;
  }

  const {
    graphConfig,
    nodeMaxVisibleSize,
    nodeMinVisibleSize
  } = settings;
  const transformMatrix = getZoomFitMatrix(Object.assign(Object.assign({}, action), {
    data,
    graphConfig,
    rect: viewport.rect,
    nodeMaxVisibleSize,
    nodeMinVisibleSize
  }));
  return Object.assign(Object.assign({}, viewport), {
    transformMatrix
  });
}

const reducer = (viewport, action, data, settings) => {
  var _a, _b, _c, _d;

  const {
    graphConfig,
    canvasBoundaryPadding,
    features
  } = settings;

  const limitScale = scale => {
    return Math.max(scale, getScaleLimit(data, settings));
  };

  switch (action.type) {
    case GraphCanvasEvent.ViewportResize:
      return Object.assign(Object.assign({}, viewport), {
        rect: action.viewportRect
      });

    case GraphCanvasEvent.Zoom:
      if (!isViewportComplete(viewport)) {
        return viewport;
      }

      return zoom({
        scale: action.scale,
        anchor: (_a = action.anchor) !== null && _a !== void 0 ? _a : getRectCenter(viewport.rect),
        direction: action.direction,
        limitScale
      })(viewport);

    case GraphScrollBarEvent.Scroll:
    case GraphCanvasEvent.MouseWheelScroll:
    case GraphCanvasEvent.Pan:
    case GraphCanvasEvent.Drag:
      {
        if (!isViewportComplete(viewport)) {
          return viewport;
        }

        const {
          transformMatrix,
          rect
        } = viewport;
        let {
          dx,
          dy
        } = action;
        const limitBoundary = features.has(GraphFeatures.LimitBoundary);
        const groupPadding = (_c = (_b = data.groups) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.padding; // TODO: this is not precise

        if (limitBoundary) {
          const {
            minX,
            maxX,
            minY,
            maxY
          } = getOffsetLimit({
            data,
            graphConfig,
            rect,
            transformMatrix,
            canvasBoundaryPadding,
            groupPadding
          });
          dx = clamp(minX - transformMatrix[4], maxX - transformMatrix[4], dx);
          dy = clamp(minY - transformMatrix[5], maxY - transformMatrix[5], dy);
        }

        return pan(dx, dy)(viewport);
      }

    case GraphCanvasEvent.Pinch:
      {
        const {
          dx,
          dy,
          scale,
          anchor
        } = action;
        return pipe(pan(dx, dy), zoom({
          scale,
          anchor,
          limitScale
        }))(viewport);
      }

    case GraphMinimapEvent.Pan:
      return minimapPan(action.dx, action.dy)(viewport);

    case GraphCanvasEvent.ResetViewport:
      return resetViewport(viewport, data, graphConfig, action);

    case GraphCanvasEvent.ZoomTo:
      if (!isViewportComplete(viewport)) {
        return viewport;
      }

      return zoomTo({
        scale: action.scale,
        anchor: (_d = action.anchor) !== null && _d !== void 0 ? _d : getRectCenter(viewport.rect),
        direction: action.direction,
        limitScale
      })(viewport);

    case GraphCanvasEvent.ZoomToFit:
      return zoomToFit(viewport, data, settings, action);

    case GraphCanvasEvent.ScrollIntoView:
      if (viewport.rect) {
        const {
          x,
          y
        } = transformPoint(action.x, action.y, viewport.transformMatrix);
        return scrollIntoView(x, y, viewport.rect, true)(viewport);
      }

      return viewport;

    default:
      return viewport;
  }
};

const viewportReducer = (state, action) => {
  const viewport = reducer(state.viewport, action, state.data.present, state.settings);
  return viewport === state.viewport ? state : Object.assign(Object.assign({}, state), {
    viewport
  });
};

const builtinReducer = composeReducers([behaviorReducer, viewportReducer, nodeReducer, portReducer, edgeReducer, canvasReducer, connectingReducer, selectionReducer, contextMenuReducer].map(reducer => next => (state, action) => next(reducer(state, action), action)));
function getGraphReducer(middleware = undefined, finalReducer = identical) {
  const finalMiddleware = middleware ? composeReducers([middleware, builtinReducer]) : builtinReducer;
  return finalMiddleware(finalReducer);
}
function useGraphReducer(params, middleware) {
  const reducer = React.useMemo(() => getGraphReducer(middleware), [middleware]);
  const [state, dispatchImpl] = React.useReducer(reducer, params, createGraphState);
  const sideEffects = useConst(() => []);
  const prevStateRef = React.useRef(state);
  const dispatch = React.useCallback((action, callback) => {
    if (callback) {
      sideEffects.push(callback);
    }

    dispatchImpl(action);
  }, [sideEffects]);
  React.useEffect(() => {
    const prevState = prevStateRef.current;

    if (prevState === state) {
      return;
    }

    prevStateRef.current = state;
    unstable_batchedUpdates(() => {
      sideEffects.forEach(callback => {
        try {
          callback(state, prevState);
        } catch (e) {
          // eslint-disable-next-line no-console
          console.error(e);
        }
      });
      sideEffects.length = 0;
    }); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [state]);
  return [state, dispatch];
}

const useBackgroundRect = state => {
  const {
    viewport
  } = state;
  const renderedArea = useRenderedArea(viewport, true);
  return {
    rect: renderedArea
  };
};

class MouseMoveEventProvider {
  constructor(target) {
    this.target = target;
  }

  off(type, callback) {
    switch (type) {
      case "move":
        this.target.removeEventListener("mousemove", callback);
        break;

      case "end":
        this.target.removeEventListener("mouseup", callback);
        break;
    }

    return this;
  }

  on(type, callback) {
    switch (type) {
      case "move":
        this.target.addEventListener("mousemove", callback);
        break;

      case "end":
        this.target.addEventListener("mouseup", callback);
        break;
    }

    return this;
  }

}

const useGetMouseDownOnAnchor = (node, eventChannel) => {
  const graphController = useGraphController();
  return React.useCallback(f => evt => {
    evt.preventDefault();
    evt.stopPropagation();
    eventChannel.trigger({
      type: GraphNodeEvent.ResizingStart,
      rawEvent: evt,
      node
    });
    const drag = new DragController(new MouseMoveEventProvider(graphController.getGlobalEventTarget()), defaultGetPositionFromEvent);

    drag.onMove = ({
      totalDX,
      totalDY,
      e: rawEvent
    }) => {
      eventChannel.trigger(Object.assign({
        type: GraphNodeEvent.Resizing,
        rawEvent,
        node,
        dx: 0,
        dy: 0,
        dWidth: 0,
        dHeight: 0
      }, f(totalDX, totalDY)));
    };

    drag.onEnd = ({
      e: rawEvent
    }) => {
      eventChannel.trigger({
        type: GraphNodeEvent.ResizingEnd,
        rawEvent,
        node
      });
    };

    eventChannel.trigger({
      type: GraphNodeEvent.ResizingStart,
      rawEvent: evt,
      node
    });
    drag.start(evt.nativeEvent);
  }, [eventChannel, graphController, node]);
};

class PointerEventProvider {
  constructor(target, pointerId = null) {
    this.eventEmitter = new EventEmitter();

    this.onMove = e => {
      if (this.pointerId === null || this.pointerId === e.pointerId) {
        this.eventEmitter.emit("move", e);
      }
    };

    this.onUp = e => {
      if (this.pointerId === null || this.pointerId === e.pointerId) {
        this.eventEmitter.emit("end", e);
      }
    };

    this.target = target;
    this.pointerId = pointerId;
  }

  off(type, callback) {
    this.eventEmitter.off(type, callback);
    this.ensureRemoveListener(type);
    return this;
  }

  on(type, callback) {
    this.ensureAddListener(type);
    this.eventEmitter.on(type, callback);
    return this;
  }

  ensureAddListener(type) {
    if (!this.eventEmitter.listeners(type).length) {
      switch (type) {
        case "move":
          this.target.addEventListener("pointermove", this.onMove);
          break;

        case "end":
          this.target.addEventListener("pointerup", this.onUp);
          break;
      }
    }
  }

  ensureRemoveListener(type) {
    if (!this.eventEmitter.listeners(type).length) {
      switch (type) {
        case "move":
          this.target.removeEventListener("pointermove", this.onMove);
          break;

        case "end":
          this.target.removeEventListener("pointerup", this.onUp);
          break;
      }
    }
  }

}

const withSimulatedClick = (params, type) => ({
  totalDX,
  totalDY,
  e: rawEvent
}) => {
  var _a;

  const {
    eventChannel,
    dragThreshold,
    containerRef
  } = params;
  const events = [];
  events.push({
    type,
    rawEvent
  });

  if (rawEvent.target instanceof Node && ((_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.contains(rawEvent.target)) && isWithinThreshold(totalDX, totalDY, dragThreshold)) {
    events.push({
      type: GraphCanvasEvent.Click,
      rawEvent
    });
  }

  eventChannel.batch(events);
};

const dragMultiSelect = (e, params) => {
  const {
    getPositionFromEvent,
    graphController,
    eventChannel
  } = params;
  const dragging = new DragController(new MouseMoveEventProvider(graphController.getGlobalEventTarget()), getPositionFromEvent);

  dragging.onMove = ({
    dx,
    dy,
    e: rawEvent
  }) => {
    eventChannel.trigger({
      type: GraphCanvasEvent.SelectMove,
      rawEvent,
      dx,
      dy
    });
  };

  dragging.onEnd = withSimulatedClick(params, GraphCanvasEvent.SelectEnd);
  eventChannel.trigger({
    type: GraphCanvasEvent.SelectStart,
    rawEvent: e
  });
  dragging.start(e);
};

const dragPan = (e, params) => {
  const {
    getPositionFromEvent,
    graphController,
    eventChannel
  } = params;
  const dragging = new DragController(new MouseMoveEventProvider(graphController.getGlobalEventTarget()), getPositionFromEvent);

  dragging.onMove = ({
    dx,
    dy,
    e: rawEvent
  }) => {
    eventChannel.trigger({
      type: GraphCanvasEvent.Drag,
      rawEvent,
      dx,
      dy
    });
  };

  dragging.onEnd = withSimulatedClick(params, GraphCanvasEvent.DragEnd);
  dragging.start(e);
  eventChannel.trigger({
    type: GraphCanvasEvent.DragStart,
    rawEvent: e
  });
};

const onContainerMouseDown = (e, params) => {
  var _a;

  e.preventDefault();
  e.stopPropagation();

  if (e.button !== MouseEventButton.Primary) {
    return;
  }

  const {
    canvasMouseMode,
    isPanDisabled,
    isMultiSelectDisabled,
    state,
    isLassoSelectEnable,
    graphController
  } = params; // in pan mode, hold ctrl or shift to perform select.
  // in select mode, hold space to perform pan

  const isPanMode = canvasMouseMode === CanvasMouseMode.Pan && !e.ctrlKey && !e.shiftKey && !e.metaKey || ((_a = state.activeKeys) === null || _a === void 0 ? void 0 : _a.has(" "));

  if (!isPanDisabled && isPanMode) {
    dragPan(e.nativeEvent, params);
  } else if (!isMultiSelectDisabled || isLassoSelectEnable && !e.ctrlKey && !e.metaKey) {
    dragMultiSelect(e.nativeEvent, params);
  } else {
    graphController.canvasClickOnce = true;
  }
};

function isMouseButNotLeft(e) {
  return e.pointerType === "mouse" && e.button !== MouseEventButton.Primary;
}

const onNodePointerDown = (evt, target, params) => {
  evt.preventDefault();
  const {
    svgRef,
    isNodesDraggable,
    getPositionFromEvent,
    isClickNodeToSelectDisabled,
    eventChannel,
    dragThreshold,
    rectRef,
    isAutoAlignEnable,
    autoAlignThreshold,
    graphController
  } = params;

  if (isNodesDraggable) {
    evt.stopPropagation();
  }

  const isMouseRight = isMouseButNotLeft(evt);

  if (isClickNodeToSelectDisabled || isMouseRight) {
    return;
  }

  if (svgRef.current) {
    svgRef.current.focus({
      preventScroll: true
    });
  }

  const isMultiSelect = checkIsMultiSelect(evt);
  const dragging = new DragNodeController(new PointerEventProvider(graphController.getGlobalEventTarget(), evt.pointerId), getPositionFromEvent, rectRef);

  dragging.onMove = ({
    dx,
    dy,
    totalDX,
    totalDY,
    e
  }) => {
    if (isNodesDraggable) {
      eventChannel.trigger({
        type: GraphNodeEvent.Drag,
        node: target,
        dx,
        dy,
        rawEvent: e,
        isVisible: !isWithinThreshold(totalDX, totalDY, dragThreshold),
        isAutoAlignEnable,
        autoAlignThreshold
      });
    }
  };

  dragging.onEnd = ({
    totalDX,
    totalDY,
    e
  }) => {
    var _a, _b;

    graphController.pointerId = null;
    const isDragCanceled = isWithinThreshold(totalDX, totalDY, dragThreshold);

    if (isDragCanceled || !isNodesDraggable) {
      graphController.nodeClickOnce = target;
    }

    eventChannel.trigger({
      type: GraphNodeEvent.DragEnd,
      node: target,
      rawEvent: e,
      isDragCanceled
    });

    if (isDragCanceled) {
      const simulatedEvent = new MouseEvent("click", e);
      (_b = (_a = evt.currentTarget) !== null && _a !== void 0 ? _a : evt.target) === null || _b === void 0 ? void 0 : _b.dispatchEvent(simulatedEvent);
    }
  };

  graphController.pointerId = evt.pointerId;

  if (evt.target instanceof Element && evt.pointerType !== "mouse") {
    evt.target.releasePointerCapture(evt.pointerId);
  }

  eventChannel.trigger({
    type: GraphNodeEvent.DragStart,
    node: target,
    rawEvent: evt,
    isMultiSelect
  });
  dragging.start(evt.nativeEvent);
};

const useCanvasKeyboardEventHandlers = args => {
  const {
    featureControl,
    graphConfig,
    setCurHoverNode,
    setCurHoverPort,
    eventChannel
  } = args;
  const {
    isDeleteDisabled,
    isPasteDisabled,
    isUndoEnabled
  } = featureControl;
  return React.useMemo(() => {
    const keyDownHandlerMap = new Map();

    const deleteKeyDownHandler = () => evt => {
      evt.preventDefault();
      evt.stopPropagation();

      if (isDeleteDisabled) {
        return;
      }

      eventChannel.trigger({
        type: GraphCanvasEvent.Delete
      });
      setCurHoverNode(undefined);
      setCurHoverPort(undefined);
    };

    keyDownHandlerMap.set("delete", deleteKeyDownHandler());
    keyDownHandlerMap.set("backspace", deleteKeyDownHandler());

    const cKeyDownHandler = evt => {
      if (metaControl(evt)) {
        evt.preventDefault();
        evt.stopPropagation();
        eventChannel.trigger({
          type: GraphCanvasEvent.Copy
        });
      }
    };

    keyDownHandlerMap.set("c", cKeyDownHandler);

    const vKeyDownHandler = evt => {
      if (metaControl(evt)) {
        evt.preventDefault();
        evt.stopPropagation();

        if (isPasteDisabled) {
          return;
        }

        const data = graphConfig.getClipboard().read();

        if (data) {
          eventChannel.trigger({
            type: GraphCanvasEvent.Paste,
            data
          });
        }
      }
    };

    keyDownHandlerMap.set("v", vKeyDownHandler);

    const zKeyDownHandler = evt => {
      if (!isUndoEnabled) {
        return;
      }

      if (metaControl(evt)) {
        evt.preventDefault();
        evt.stopPropagation();
        eventChannel.trigger({
          type: GraphCanvasEvent.Undo
        });
      }
    };

    if (isUndoEnabled) {
      keyDownHandlerMap.set("z", zKeyDownHandler);
    }

    const yKeyDownHandler = evt => {
      if (!isUndoEnabled) {
        return;
      }

      if (metaControl(evt)) {
        evt.preventDefault();
        evt.stopPropagation();
        eventChannel.trigger({
          type: GraphCanvasEvent.Redo
        });
      }
    };

    if (isUndoEnabled) {
      keyDownHandlerMap.set("y", yKeyDownHandler);
    }

    const aKeyDownHandler = evt => {
      if (metaControl(evt)) {
        evt.preventDefault();
        evt.stopPropagation();
        eventChannel.trigger({
          type: GraphNodeEvent.SelectAll
        });
      }
    };

    keyDownHandlerMap.set("a", aKeyDownHandler);

    const spaceKeyDownHandler = evt => {
      evt.preventDefault();
      evt.stopPropagation();
    };

    const ctrlKeyDownHandler = evt => {
      evt.preventDefault();
      evt.stopPropagation();
    };

    const metaKeyDownHandler = evt => {
      evt.preventDefault();
      evt.stopPropagation();
    };

    const shiftKeyDownHandler = evt => {
      evt.preventDefault();
      evt.stopPropagation();
    };

    keyDownHandlerMap.set(" ", spaceKeyDownHandler);
    keyDownHandlerMap.set("control", ctrlKeyDownHandler);
    keyDownHandlerMap.set("meta", metaKeyDownHandler);
    keyDownHandlerMap.set("shift", shiftKeyDownHandler);
    return evt => {
      if (evt.repeat) {
        return;
      }

      const key = evt.key.toLowerCase();
      const handler = keyDownHandlerMap.get(key);

      if (handler) {
        handler.call(null, evt);
      }
    };
  }, [eventChannel, graphConfig, isDeleteDisabled, isPasteDisabled, isUndoEnabled, setCurHoverNode, setCurHoverPort]);
};

let prevMouseDownPortId;
let prevMouseDownPortTime;
function useEventChannel({
  props,
  dispatch,
  rectRef,
  svgRef,
  containerRef,
  featureControl,
  graphConfig,
  setFocusedWithoutMouse,
  setCurHoverNode,
  setCurHoverPort,
  eventChannel,
  updateViewport,
  graphController
}) {
  const {
    dragThreshold = 10,
    autoAlignThreshold = DEFAULT_AUTO_ALIGN_THRESHOLD,
    getPositionFromEvent = defaultGetPositionFromEvent,
    canvasMouseMode,
    edgeWillAdd
  } = props;
  const {
    isNodesDraggable,
    isAutoAlignEnable,
    isClickNodeToSelectDisabled,
    isPanDisabled,
    isMultiSelectDisabled,
    isLassoSelectEnable,
    isConnectDisabled,
    isPortHoverViewEnable,
    isNodeEditDisabled,
    isA11yEnable
  } = featureControl;
  const animationFramedDispatch = React.useMemo(() => animationFramed(dispatch), [dispatch]);
  const keyDownHandler = useCanvasKeyboardEventHandlers({
    featureControl,
    eventChannel,
    graphConfig,
    setCurHoverNode,
    setCurHoverPort
  });

  const focusFirstNode = e => {
    const data = graphController.getData();

    if (data.nodes.size > 0 && svgRef.current) {
      const firstNode = data.head && data.nodes.get(data.head);

      if (firstNode) {
        focusItem(svgRef, {
          node: firstNode,
          port: undefined
        }, e, eventChannel);
      }
    }
  }; //#region edge


  const handleEdgeEvent = event => {
    switch (event.type) {
      case GraphEdgeEvent.ConnectStart:
      case GraphEdgeEvent.ConnectMove:
      case GraphEdgeEvent.ConnectEnd:
      case GraphEdgeEvent.ConnectNavigate:
      case GraphEdgeEvent.Click:
      case GraphEdgeEvent.MouseEnter:
      case GraphEdgeEvent.MouseLeave:
      case GraphEdgeEvent.DoubleClick:
        dispatch(event);
        break;

      case GraphEdgeEvent.ContextMenu:
        event.rawEvent.stopPropagation();
        event.rawEvent.preventDefault();
        dispatch(event);
        break;
    }
  }; //#endregion edge
  //#region canvas
  // eslint-disable-next-line complexity


  const handleCanvasEvent = event => {
    var _a, _b;

    switch (event.type) {
      case GraphCanvasEvent.ViewportResize:
      case GraphCanvasEvent.Drag:
      case GraphCanvasEvent.MouseWheelScroll:
      case GraphCanvasEvent.Zoom:
      case GraphCanvasEvent.Pinch:
      case GraphCanvasEvent.Click:
      case GraphCanvasEvent.SelectStart:
      case GraphCanvasEvent.SelectMove:
      case GraphCanvasEvent.SelectEnd:
      case GraphCanvasEvent.ResetSelection:
      case GraphCanvasEvent.Navigate:
      case GraphCanvasEvent.Paste:
      case GraphCanvasEvent.Undo:
      case GraphCanvasEvent.Redo:
      case GraphCanvasEvent.Delete:
      case GraphCanvasEvent.KeyUp:
      case GraphCanvasEvent.DraggingNodeFromItemPanelStart:
      case GraphCanvasEvent.DraggingNodeFromItemPanel:
      case GraphCanvasEvent.DraggingNodeFromItemPanelEnd:
        dispatch(event);
        break;

      case GraphCanvasEvent.Copy:
        {
          const selectedData = filterSelectedItems(graphController.getData());
          const clipboard = graphConfig.getClipboard();
          clipboard.write(selectedData);
        }
        break;

      case GraphCanvasEvent.KeyDown:
        if (!event.rawEvent.repeat && event.rawEvent.target === event.rawEvent.currentTarget && !event.rawEvent.shiftKey && event.rawEvent.key === "Tab") {
          event.rawEvent.preventDefault();
          event.rawEvent.stopPropagation();
          setFocusedWithoutMouse(true);
          focusFirstNode(event.rawEvent);
        } else {
          keyDownHandler(event.rawEvent);
        }

        dispatch(event);
        break;

      case GraphCanvasEvent.MouseDown:
        {
          graphController.nodeClickOnce = null;
          (_a = svgRef.current) === null || _a === void 0 ? void 0 : _a.focus({
            preventScroll: true
          });
          setFocusedWithoutMouse(false);
          const evt = event.rawEvent;
          updateViewport();
          onContainerMouseDown(evt, {
            state: graphController.state,
            canvasMouseMode,
            isPanDisabled,
            isMultiSelectDisabled,
            isLassoSelectEnable,
            dragThreshold,
            containerRef,
            getPositionFromEvent: defaultGetPositionFromEvent,
            eventChannel,
            graphController
          });
        }
        break;

      case GraphCanvasEvent.MouseUp:
        if (graphController.canvasClickOnce) {
          graphController.canvasClickOnce = false;
          const evt = event.rawEvent;

          if (evt.target instanceof Node && ((_b = svgRef.current) === null || _b === void 0 ? void 0 : _b.contains(evt.target)) && evt.target.nodeName === "svg") {
            eventChannel.trigger({
              type: GraphCanvasEvent.Click,
              rawEvent: event.rawEvent
            });
          }
        }

        break;

      case GraphCanvasEvent.ContextMenu:
        event.rawEvent.preventDefault();
        event.rawEvent.stopPropagation();
        dispatch(event);
        break;

      case GraphCanvasEvent.MouseMove:
        {
          const evt = event.rawEvent;
          graphController.setMouseClientPosition({
            x: evt.clientX,
            y: evt.clientY
          });
        }
        break;

      case GraphCanvasEvent.MouseLeave:
        graphController.unsetMouseClientPosition();
        graphController.canvasClickOnce = false;
        break;

      case GraphCanvasEvent.Blur:
        setFocusedWithoutMouse(false);
        break;
    }
  }; //#endregion canvas
  //#region node


  const onNodePointerEnter = event => {
    const {
      node
    } = event;
    const {
      isNodeHoverViewEnabled
    } = featureControl;
    const behavior = graphController.getBehavior();

    switch (behavior) {
      case GraphBehavior.Connecting:
      case GraphBehavior.Default:
        if (isNodeHoverViewEnabled) {
          setCurHoverNode(node.id);
          setCurHoverPort(undefined);
        }

        break;
    }

    dispatch(event);
  };

  const onNodePointerLeave = event => {
    dispatch(event);
    setCurHoverNode(undefined);
  };

  const onNodeDoubleClick = event => {
    if (isNodeEditDisabled) {
      return;
    }

    event.rawEvent.stopPropagation();
    dispatch(event);
  };

  const onNodeKeyDown = event => {
    if (!svgRef || !isA11yEnable) {
      return;
    }

    const data = graphController.getData();
    const {
      node
    } = event;
    const evt = event.rawEvent;

    switch (evt.key) {
      case "Tab":
        {
          evt.preventDefault();
          evt.stopPropagation();
          const nextItem = evt.shiftKey ? getPrevItem(data, node) : getNextItem(data, node);
          focusItem(svgRef, nextItem, evt, eventChannel);
        }
        break;

      case "ArrowUp":
        evt.preventDefault();
        evt.stopPropagation();
        focusUpNode(data, node.id, svgRef, graphController, evt, eventChannel);
        break;

      case "ArrowDown":
        evt.preventDefault();
        evt.stopPropagation();
        focusDownNode(data, node.id, svgRef, graphController, evt, eventChannel);
        break;

      case "ArrowLeft":
        evt.preventDefault();
        evt.stopPropagation();
        focusLeftNode(data, node.id, svgRef, graphController, evt, eventChannel);
        break;

      case "ArrowRight":
        evt.preventDefault();
        evt.stopPropagation();
        focusRightNode(data, node.id, svgRef, graphController, evt, eventChannel);
        break;
    }
  }; // eslint-disable-next-line complexity


  const handleNodeEvent = event => {
    var _a;

    switch (event.type) {
      case GraphNodeEvent.ResizingStart:
      case GraphNodeEvent.Resizing:
      case GraphNodeEvent.ResizingEnd:
      case GraphNodeEvent.DragStart:
      case GraphNodeEvent.Drag:
      case GraphNodeEvent.DragEnd:
      case GraphNodeEvent.SelectAll:
        dispatch(event);
        break;

      case GraphNodeEvent.PointerMove:
        if (event.rawEvent.pointerId === graphController.pointerId) {
          animationFramedDispatch(event);
        }

        break;

      case GraphNodeEvent.PointerDown:
        {
          graphController.nodeClickOnce = null;

          if (graphController.getBehavior() !== GraphBehavior.Default) {
            return;
          }

          const evt = event.rawEvent;
          updateViewport();
          onNodePointerDown(evt, event.node, {
            svgRef,
            rectRef,
            isNodesDraggable,
            isAutoAlignEnable,
            dragThreshold,
            getPositionFromEvent,
            isClickNodeToSelectDisabled,
            autoAlignThreshold,
            eventChannel,
            graphController
          });
        }
        break;

      case GraphNodeEvent.PointerEnter:
        onNodePointerEnter(event);
        break;

      case GraphNodeEvent.PointerLeave:
        onNodePointerLeave(event);
        break;

      case GraphNodeEvent.MouseDown:
        graphController.nodeClickOnce = null;
        event.rawEvent.preventDefault();

        if (isNodesDraggable) {
          event.rawEvent.stopPropagation();
        }

        setFocusedWithoutMouse(false);
        break;

      case GraphNodeEvent.Click:
        if (((_a = graphController.nodeClickOnce) === null || _a === void 0 ? void 0 : _a.id) === event.node.id) {
          const {
            currentTarget
          } = event.rawEvent;

          if (currentTarget instanceof SVGElement) {
            currentTarget.focus({
              preventScroll: true
            });
          }

          event.node = graphController.nodeClickOnce;
          dispatch(event);
          graphController.nodeClickOnce = null;
        } else {
          event.intercepted = true;
        }

        break;

      case GraphNodeEvent.ContextMenu:
        event.rawEvent.preventDefault();
        event.rawEvent.stopPropagation();
        dispatch(event);
        break;

      case GraphNodeEvent.DoubleClick:
        onNodeDoubleClick(event);
        break;

      case GraphNodeEvent.KeyDown:
        onNodeKeyDown(event);
        break;
    }
  }; //#endregion node
  //#region port


  const onPortPointerDown = React.useCallback(event => {
    const evt = event.rawEvent;
    const {
      node,
      port
    } = event;
    setFocusedWithoutMouse(false);
    evt.stopPropagation();
    evt.preventDefault();
    prevMouseDownPortId = `${node.id}:${port.id}`;
    prevMouseDownPortTime = performance.now();

    if (isConnectDisabled || isMouseButNotLeft(evt)) {
      return;
    }

    updateViewport();
    const globalEventTarget = graphController.getGlobalEventTarget();
    const dragging = new DragController(new PointerEventProvider(globalEventTarget, evt.pointerId), getPositionFromEvent);

    dragging.onMove = ({
      clientX,
      clientY,
      e
    }) => {
      eventChannel.trigger({
        type: GraphEdgeEvent.ConnectMove,
        rawEvent: e,
        clientX,
        clientY
      });
    };

    dragging.onEnd = ({
      e,
      totalDY,
      totalDX
    }) => {
      var _a, _b;

      const isCancel = isWithinThreshold(totalDX, totalDY, dragThreshold);
      eventChannel.trigger({
        type: GraphEdgeEvent.ConnectEnd,
        rawEvent: e,
        edgeWillAdd,
        isCancel
      });
      graphController.pointerId = null;

      if (isCancel) {
        const simulatedEvent = new MouseEvent("click", e);
        (_b = (_a = evt.currentTarget) !== null && _a !== void 0 ? _a : evt.target) === null || _b === void 0 ? void 0 : _b.dispatchEvent(simulatedEvent);
      }
    };

    eventChannel.trigger({
      type: GraphEdgeEvent.ConnectStart,
      nodeId: node.id,
      portId: port.id,
      rawEvent: evt,
      clientPoint: {
        x: evt.clientX,
        y: evt.clientY
      }
    });

    if (evt.target instanceof Element && evt.pointerType !== "mouse") {
      evt.target.releasePointerCapture(evt.pointerId);
    }

    graphController.pointerId = evt.pointerId;
    dragging.start(evt.nativeEvent);
  }, [edgeWillAdd, eventChannel, getPositionFromEvent, graphController, isConnectDisabled, setFocusedWithoutMouse, updateViewport]);
  const onPortPointerUp = React.useCallback(event => {
    const evt = event.rawEvent;
    const {
      node,
      port
    } = event; // simulate port click event

    if (prevMouseDownPortId === `${node.id}:${port.id}` && performance.now() - (prevMouseDownPortTime || 0) < 500) {
      prevMouseDownPortId = undefined;
      prevMouseDownPortTime = undefined;
      eventChannel.trigger({
        type: GraphPortEvent.Click,
        node,
        port,
        rawEvent: evt
      });
    }
  }, [eventChannel]);

  const onPortPointerEnter = event => {
    const behavior = graphController.getBehavior();

    switch (behavior) {
      case GraphBehavior.Default:
        setCurHoverPort([event.node.id, event.port.id]);
        break;
    }

    if (isPortHoverViewEnable) {
      setCurHoverPort([event.node.id, event.port.id]);
    }

    if (event.rawEvent.pointerId === graphController.pointerId) {
      dispatch(event);
    }
  };

  const onPortPointerLeave = event => {
    setCurHoverPort(undefined);
    dispatch(event);
  };

  const onPortKeyDown = event => {
    var _a, _b, _c;

    if (!isA11yEnable) {
      return;
    }

    const evt = event.rawEvent; // nativeEvent.code not support by Edge <79, use evt.key to polyfill

    if (evt.altKey && (evt.nativeEvent.code === "KeyC" || evt.key === "c")) {
      evt.preventDefault();
      evt.stopPropagation();
      eventChannel.trigger({
        type: GraphEdgeEvent.ConnectStart,
        nodeId: event.node.id,
        portId: event.port.id,
        rawEvent: evt
      });
      return;
    }

    const data = graphController.getData();
    const {
      node,
      port
    } = event;

    switch (evt.key) {
      case "Tab":
        if (isA11yEnable && graphController.getBehavior() === GraphBehavior.Connecting) {
          evt.preventDefault();
          evt.stopPropagation();
          eventChannel.trigger({
            type: GraphEdgeEvent.ConnectNavigate,
            rawEvent: evt
          });
        } else {
          const nextItem = evt.shiftKey ? getPrevItem(data, node, port) : getNextItem(data, node, port);
          focusItem(svgRef, nextItem, evt, eventChannel);
        }

        break;

      case "ArrowUp":
      case "ArrowLeft":
        evt.preventDefault();
        evt.stopPropagation();
        focusPrevPort((_a = node.ports) !== null && _a !== void 0 ? _a : [], node, port.id, svgRef, evt, eventChannel);
        break;

      case "ArrowDown":
      case "ArrowRight":
        evt.preventDefault();
        evt.stopPropagation();
        focusNextPort((_b = node.ports) !== null && _b !== void 0 ? _b : [], node, port.id, svgRef, evt, eventChannel);
        break;

      case "g":
        evt.preventDefault();
        evt.stopPropagation();
        goToConnectedPort(data, node, port, svgRef, evt, eventChannel);
        break;

      case "Escape":
        if (graphController.getBehavior() === GraphBehavior.Connecting) {
          evt.preventDefault();
          evt.stopPropagation();

          if (svgRef.current) {
            (_c = findDOMElement(svgRef.current, {
              node,
              port
            })) === null || _c === void 0 ? void 0 : _c.blur();
          }
        }

        break;

      case "Enter":
        evt.preventDefault();
        evt.stopPropagation();
        eventChannel.trigger({
          type: GraphEdgeEvent.ConnectEnd,
          rawEvent: evt.nativeEvent,
          edgeWillAdd,
          isCancel: false
        });
        break;
    }
  };

  const handlePortEvent = event => {
    switch (event.type) {
      case GraphPortEvent.Click:
        dispatch(event);
        break;

      case GraphPortEvent.PointerDown:
        onPortPointerDown(event);
        break;

      case GraphPortEvent.PointerUp:
        onPortPointerUp(event);
        break;

      case GraphPortEvent.PointerEnter:
        onPortPointerEnter(event);
        break;

      case GraphPortEvent.PointerLeave:
        onPortPointerLeave(event);
        break;

      case GraphPortEvent.ContextMenu:
        event.rawEvent.preventDefault();
        event.rawEvent.stopPropagation();
        dispatch(event);
        break;

      case GraphPortEvent.Focus:
        event.rawEvent.stopPropagation();
        dispatch(event);
        break;

      case GraphPortEvent.Blur:
        if (graphController.getBehavior() === GraphBehavior.Connecting) {
          eventChannel.trigger({
            type: GraphEdgeEvent.ConnectEnd,
            rawEvent: event.rawEvent.nativeEvent,
            edgeWillAdd,
            isCancel: true
          });
        }

        break;

      case GraphPortEvent.KeyDown:
        onPortKeyDown(event);
        break;
    }
  }; //#endregion port


  const handleEvent = event => {
    const behavior = handleBehaviorChange(graphController.getBehavior(), event);
    graphController.setBehavior(behavior);
    handleEdgeEvent(event);
    handleCanvasEvent(event);
    handleNodeEvent(event);
    handlePortEvent(event); //#region other events

    switch (event.type) {
      case GraphMinimapEvent.Pan:
      case GraphScrollBarEvent.Scroll:
      case GraphContextMenuEvent.Open:
      case GraphContextMenuEvent.Close:
        dispatch(event);
        break;
    } //#endregion other events

  };

  React.useImperativeHandle(eventChannel.listenersRef, () => handleEvent);
  React.useImperativeHandle(eventChannel.externalHandlerRef, () => props.onEvent);
}

const useFeatureControl = features => {
  return React.useMemo(() => {
    const isNodesDraggable = features.has(GraphFeatures.NodeDraggable);
    const isNodeResizable = features.has(GraphFeatures.NodeResizable);
    const isAutoFitDisabled = !features.has(GraphFeatures.AutoFit);
    const isPanDisabled = !features.has(GraphFeatures.PanCanvas);
    const isMultiSelectDisabled = !features.has(GraphFeatures.MultipleSelect);
    const isLassoSelectEnable = features.has(GraphFeatures.LassoSelect);
    const isNodeHoverViewEnabled = features.has(GraphFeatures.NodeHoverView);
    const isClickNodeToSelectDisabled = !features.has(GraphFeatures.ClickNodeToSelect);
    const isConnectDisabled = !features.has(GraphFeatures.AddNewEdges);
    const isPortHoverViewEnable = features.has(GraphFeatures.PortHoverView);
    const isNodeEditDisabled = !features.has(GraphFeatures.EditNode);
    const isVerticalScrollDisabled = !features.has(GraphFeatures.CanvasVerticalScrollable);
    const isHorizontalScrollDisabled = !features.has(GraphFeatures.CanvasHorizontalScrollable);
    const isA11yEnable = features.has(GraphFeatures.A11yFeatures);
    const isAutoAlignEnable = features.has(GraphFeatures.AutoAlign);
    const isCtrlKeyZoomEnable = features.has(GraphFeatures.CtrlKeyZoom);
    const isLimitBoundary = features.has(GraphFeatures.LimitBoundary);
    const isVirtualizationEnabled = !features.has(GraphFeatures.AutoFit);
    const isEdgeEditable = features.has(GraphFeatures.EditEdge);
    const isDeleteDisabled = !features.has(GraphFeatures.Delete);
    const isPasteDisabled = !features.has(GraphFeatures.AddNewNodes) || !features.has(GraphFeatures.AddNewEdges);
    const isUndoEnabled = features.has(GraphFeatures.UndoStack);
    const isScrollbarVisible = (!isVerticalScrollDisabled || !isHorizontalScrollDisabled || !isPanDisabled) && isLimitBoundary && !features.has(GraphFeatures.InvisibleScrollbar);
    return {
      isNodesDraggable,
      isNodeResizable,
      isAutoFitDisabled,
      isPanDisabled,
      isMultiSelectDisabled,
      isLassoSelectEnable,
      isNodeHoverViewEnabled,
      isClickNodeToSelectDisabled,
      isConnectDisabled,
      isPortHoverViewEnable,
      isNodeEditDisabled,
      isVerticalScrollDisabled,
      isHorizontalScrollDisabled,
      isA11yEnable,
      isAutoAlignEnable,
      isCtrlKeyZoomEnable,
      isLimitBoundary,
      isVirtualizationEnabled,
      isEdgeEditable,
      isDeleteDisabled,
      isPasteDisabled,
      isUndoEnabled,
      isScrollbarVisible
    };
  }, [features]);
};

const emptyLine = () => ({
  x1: 0,
  y1: 0,
  x2: 0,
  y2: 0,
  visible: false
});
const Line = props => {
  var _a;

  const {
    line,
    style
  } = props;
  const lineStyle = Object.assign(Object.assign({
    // strokeDasharray: "0,0",
    strokeWidth: 1
  }, style), {
    stroke: line.visible ? (_a = style === null || style === void 0 ? void 0 : style.stroke) !== null && _a !== void 0 ? _a : "#ea4300" : "none"
  });
  return jsx("line", {
    className: "auto-align-hint",
    x1: line.x1,
    y1: line.y1,
    x2: line.x2,
    y2: line.y2,
    style: lineStyle
  });
};

const AlignmentLines = /*#__PURE__*/React.memo(({
  style
}) => {
  const alignmentLines = useAlignmentLines();
  return jsx(Fragment, {
    children: alignmentLines.map((l, index) => {
      if (l.visible) {
        return jsx(Line, {
          line: l,
          style: style
        }, index);
      }

      return null;
    })
  });
});
AlignmentLines.displayName = "AlignmentLines";

const NodeFrame = props => {
  var _a, _b;

  const slotsContext = React.useContext(SlotsContext);
  return jsx(Fragment, {
    children: (_b = (_a = slotsContext.renderNodeFrame) === null || _a === void 0 ? void 0 : _a.call(slotsContext, props)) !== null && _b !== void 0 ? _b : props.children
  });
};

const NodeResizeHandler = props => {
  var _a, _b;

  const slotsContext = React.useContext(SlotsContext);
  return jsx(Fragment, {
    children: (_b = (_a = slotsContext.renderNodeResizeHandler) === null || _a === void 0 ? void 0 : _a.call(slotsContext, props)) !== null && _b !== void 0 ? _b : props.children
  });
};

const Slots = {
  NodeFrame,
  NodeResizeHandler
};

const AnimatingNodeGroup = props => {
  var _a, _b;

  const {
    dummyNodes,
    graphData
  } = props;
  const graphConfig = useGraphConfig();
  const {
    dWidth,
    dHeight
  } = dummyNodes;
  const dx = (_a = dummyNodes.alignedDX) !== null && _a !== void 0 ? _a : dummyNodes.dx;
  const dy = (_b = dummyNodes.alignedDY) !== null && _b !== void 0 ? _b : dummyNodes.dy;
  return jsx("g", {
    children: dummyNodes.nodes.map(dummyNode => {
      const node = graphData.nodes.get(dummyNode.id);

      if (!node) {
        return null;
      }

      const x = dummyNode.x + dx;
      const y = dummyNode.y + dy;
      const width = dummyNode.width + dWidth;
      const height = dummyNode.height + dHeight;
      const nodeConfig = getNodeConfig(node, graphConfig);

      if (nodeConfig === null || nodeConfig === void 0 ? void 0 : nodeConfig.renderDummy) {
        return nodeConfig.renderDummy(Object.assign(Object.assign({}, node.inner), {
          x,
          y,
          width,
          height
        }));
      }

      return jsx(Slots.NodeFrame, Object.assign({
        height: height,
        width: width,
        x: x,
        y: y
      }, {
        children: jsx("rect", {
          transform: `translate(${x},${y})`,
          height: height,
          width: width,
          stroke: defaultColors.dummyNodeStroke,
          strokeDasharray: "4",
          fill: "none"
        }, node.id)
      }), `node-frame-${dummyNode.id}`);
    })
  });
};

const ConnectingLine = props => {
  const {
    autoAttachLine,
    connectingLine,
    styles
  } = props;
  const strokeColor = (styles === null || styles === void 0 ? void 0 : styles.stroke) || defaultColors.primaryColor;
  const fill = (styles === null || styles === void 0 ? void 0 : styles.fill) || "none";
  const strokeDasharray = (styles === null || styles === void 0 ? void 0 : styles.strokeDasharray) || "4,4";
  const connectingLineStroke = connectingLine.visible ? strokeColor : "none";
  return jsxs("g", {
    children: [jsx("defs", {
      children: jsx("marker", Object.assign({
        id: "markerArrow",
        markerWidth: "10",
        markerHeight: "10",
        refX: "6",
        refY: "5",
        orient: "auto",
        markerUnits: "strokeWidth"
      }, {
        children: jsx("path", {
          d: "M0,0 L6,5 L0,10",
          style: {
            stroke: connectingLineStroke,
            fill: "none"
          }
        })
      }))
    }), jsx("line", {
      x1: connectingLine.x1,
      y1: connectingLine.y1,
      x2: connectingLine.x2,
      y2: connectingLine.y2,
      style: {
        stroke: connectingLineStroke,
        fill,
        strokeDasharray
      },
      markerEnd: "url(#markerArrow)"
    }), jsx("path", {
      d: getCurvePathD(autoAttachLine.x2, autoAttachLine.x1, autoAttachLine.y2, autoAttachLine.y1),
      style: {
        stroke: autoAttachLine.visible ? strokeColor : "none",
        fill: "none"
      }
    })]
  });
};

const Connecting = /*#__PURE__*/React.memo(props => {
  const {
    styles,
    graphConfig,
    viewport,
    movingPoint
  } = props;
  const {
    sourcePort,
    sourceNode,
    targetPort,
    targetNode
  } = useConnectingState();

  if (!sourceNode || !sourcePort) {
    return null;
  }

  const sourcePortPosition = sourceNode.getPortPosition(sourcePort.id, graphConfig);
  let targetPortPosition;
  let isAttach = false;

  if (targetNode && targetPort) {
    isAttach = true;
    targetPortPosition = targetNode === null || targetNode === void 0 ? void 0 : targetNode.getPortPosition(targetPort.id, graphConfig);
  } else {
    targetPortPosition = sourcePortPosition;
  }

  if (!sourcePortPosition || !targetPortPosition) {
    return null;
  }

  const sourcePoint = transformPoint(sourcePortPosition.x, sourcePortPosition.y, viewport.transformMatrix);
  const targetPoint = transformPoint(targetPortPosition.x, targetPortPosition.y, viewport.transformMatrix);
  const connectingLine = movingPoint ? {
    x1: sourcePoint.x,
    y1: sourcePoint.y,
    x2: movingPoint.x,
    y2: movingPoint.y,
    visible: !isAttach
  } : emptyLine();
  const autoAttachLine = {
    x1: sourcePoint.x,
    y1: sourcePoint.y,
    x2: targetPoint.x,
    y2: targetPoint.y,
    visible: isAttach
  };
  return jsx(ConnectingLine, {
    connectingLine: connectingLine,
    autoAttachLine: autoAttachLine,
    styles: styles
  });
});
Connecting.displayName = "Connecting";

const defaultStyle = {
  position: "fixed",
  userSelect: "none"
};
const GraphContextMenu = ({
  state,
  onClick
}) => {
  var _a, _b;

  const ref = React.useRef(null);
  const [style, setStyle] = React.useState(Object.assign({}, defaultStyle));
  React.useLayoutEffect(() => {
    const el = ref.current;

    if (!el || !state.contextMenuPosition) {
      return;
    }

    const {
      x,
      y
    } = state.contextMenuPosition;
    const {
      clientWidth,
      clientHeight
    } = document.documentElement;
    const {
      width,
      height
    } = el.getBoundingClientRect();
    const nextStyle = Object.assign({}, defaultStyle);

    if (x + width >= clientWidth) {
      nextStyle.right = 0;
    } else {
      nextStyle.left = x;
    }

    if (y + height > clientHeight) {
      nextStyle.bottom = 0;
    } else {
      nextStyle.top = y;
    }

    setStyle(nextStyle); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [(_a = state.contextMenuPosition) === null || _a === void 0 ? void 0 : _a.x, (_b = state.contextMenuPosition) === null || _b === void 0 ? void 0 : _b.y]);
  const contextMenuConfig = useContextMenuConfigContext();
  const [content, setContent] = React.useState(jsx(Fragment, {}));
  React.useEffect(() => {
    const data = state.data.present;
    let selectedNodesCount = 0;
    let selectedPortsCount = 0;
    let selectedEdgesCount = 0;
    data.nodes.forEach(node => {
      var _a;

      if (isSelected(node)) {
        selectedNodesCount += 1;
      }

      (_a = node.ports) === null || _a === void 0 ? void 0 : _a.forEach(port => {
        if (isSelected(port)) {
          selectedPortsCount += 1;
        }
      });
    });
    data.edges.forEach(edge => {
      if (isSelected(edge)) {
        selectedEdgesCount += 1;
      }
    });
    let menu; // todo port menu

    if (selectedPortsCount + selectedNodesCount + selectedEdgesCount > 1) {
      menu = contextMenuConfig.getMenu(MenuType.Multi);
    } else if (selectedPortsCount + selectedNodesCount + selectedEdgesCount === 0) {
      menu = contextMenuConfig.getMenu(MenuType.Canvas);
    } else if (selectedNodesCount === 1) {
      menu = contextMenuConfig.getMenu(MenuType.Node);
    } else if (selectedPortsCount === 1) {
      menu = contextMenuConfig.getMenu(MenuType.Port);
    } else {
      menu = contextMenuConfig.getMenu(MenuType.Edge);
    }

    setContent(menu);
  }, [state.data.present, contextMenuConfig]);
  const handleContextMenu = React.useCallback(evt => {
    evt.stopPropagation();
    evt.preventDefault();
  }, []);
  return jsx(Fragment, {
    children: state.contextMenuPosition && jsx("div", Object.assign({
      ref: ref,
      onClick: onClick,
      onContextMenu: handleContextMenu,
      role: "button",
      style: style
    }, {
      children: content
    }))
  });
};

const Renderer = props => jsx("rect", {
  height: props.height,
  width: props.width,
  fill: props.group.fill
});

const defaultGroup = {
  render: Renderer
};

const Group = props => {
  var _a;

  const {
    data,
    group
  } = props;
  const graphConfig = useGraphConfig();
  const {
    x,
    y,
    width,
    height
  } = React.useMemo(() => getGroupRect(group, data.nodes, graphConfig), [group, data.nodes, graphConfig]);
  const groupConfig = (_a = graphConfig.getGroupConfig(group)) !== null && _a !== void 0 ? _a : defaultGroup;
  const automationId = `group-container-${group.id}`;
  return jsx("g", Object.assign({
    "data-automation-id": automationId,
    transform: `translate(${x}, ${y})`
  }, {
    children: groupConfig.render({
      group,
      height,
      width
    })
  }), group.id);
};

const GraphGroupsRenderer = props => {
  return jsx("g", {
    children: React.useMemo(() => props.groups.map(group => {
      return jsx(Group, {
        group: group,
        data: props.data
      }, group.id);
    }), [props.groups, props.data])
  });
};

const NodeTooltips = props => {
  const {
    node,
    viewport
  } = props;
  const graphConfig = useGraphConfig();

  if (!node) {
    return null;
  }

  if (!has(GraphNodeStatus.Activated)(node.status)) {
    return null;
  }

  const nodeConfig = getNodeConfig(node, graphConfig);

  if (!(nodeConfig === null || nodeConfig === void 0 ? void 0 : nodeConfig.renderTooltips)) {
    return null;
  }

  return jsx("div", Object.assign({
    className: "node-tooltips"
  }, {
    children: nodeConfig.renderTooltips({
      model: node,
      viewport
    })
  }));
};

const PortTooltips = props => {
  const graphConfig = useGraphConfig();
  const {
    parentNode,
    port,
    viewport
  } = props;
  const isPortTooltipsVisible = has(GraphPortStatus.Activated)(port.status);

  if (!isPortTooltipsVisible) {
    return null;
  }

  const portConfig = graphConfig.getPortConfig(port);

  if (!portConfig || !portConfig.renderTooltips) {
    return null;
  }

  const pos = parentNode.getPortPosition(port.id, graphConfig);

  if (!pos) {
    return null;
  }

  return jsx("div", Object.assign({
    className: "port-tooltips"
  }, {
    children: jsx(ConnectingStateContext.Consumer, {
      children: ({
        sourceNode,
        sourcePort
      }) => portConfig.renderTooltips && portConfig.renderTooltips(Object.assign({
        model: port,
        parentNode,
        data: props.data,
        anotherNode: sourceNode,
        anotherPort: sourcePort,
        viewport
      }, pos))
    })
  }));
};

function useRefValue(value) {
  const ref = useRef(value);
  useLayoutEffect(() => {
    ref.current = value;
  }, [value]);
  return ref;
}

const SCROLL_BAR_WIDTH = 10;
const wrapperCommonStyle = {
  position: "absolute",
  cursor: "initial"
};
const useStyles = createUseStyles({
  verticalScrollWrapper: Object.assign(Object.assign({}, wrapperCommonStyle), {
    height: "100%",
    width: SCROLL_BAR_WIDTH,
    top: 0,
    right: 0
  }),
  horizontalScrollWrapper: Object.assign(Object.assign({}, wrapperCommonStyle), {
    height: SCROLL_BAR_WIDTH,
    width: "100%",
    bottom: 0,
    left: 0
  }),
  verticalScrollStyle: args => ({
    height: args.scrollbarLayout.verticalScrollHeight,
    width: "100%",
    backgroundColor: defaultColors.scrollbarColor,
    position: "absolute",
    top: 0,
    right: 0,
    transform: `translateY(${args.scrollbarLayout.verticalScrollTop}px)`
  }),
  horizontalScrollStyle: args => ({
    width: args.scrollbarLayout.horizontalScrollWidth - SCROLL_BAR_WIDTH,
    height: "100%",
    backgroundColor: defaultColors.scrollbarColor,
    position: "absolute",
    left: 0,
    bottom: 0,
    transform: `translateX(${args.scrollbarLayout.horizontalScrollLeft}px)`
  })
});
const Scrollbar = props => {
  const {
    vertical = true,
    horizontal = true,
    offsetLimit,
    eventChannel,
    viewport
  } = props;
  const graphController = useGraphController();
  const scrollbarLayout = getScrollbarLayout(viewport, offsetLimit);
  const classes = useStyles({
    scrollbarLayout
  });
  const scrollbarLayoutRef = useRefValue(scrollbarLayout);
  /**
   * @param e
   */

  function onVerticalScrollMouseDown(e) {
    e.preventDefault();
    e.stopPropagation();
    const {
      height: containerHeight
    } = viewport.rect;
    const dragging = new DragController(new MouseMoveEventProvider(graphController.getGlobalEventTarget()), defaultGetPositionFromEvent);

    dragging.onMove = ({
      dy: scrollbarDy,
      e: rawEvent
    }) => {
      const {
        totalContentHeight
      } = scrollbarLayoutRef.current;
      const dy = -(scrollbarDy * totalContentHeight) / containerHeight;
      eventChannel.trigger({
        type: GraphScrollBarEvent.Scroll,
        rawEvent,
        dx: 0,
        dy
      });
    };

    dragging.onEnd = () => {
      eventChannel.trigger({
        type: GraphScrollBarEvent.ScrollEnd
      });
    };

    dragging.start(e.nativeEvent);
    eventChannel.trigger({
      type: GraphScrollBarEvent.ScrollStart
    });
  }
  /**
   * @param e
   */


  function onHorizontalScrollMouseDown(e) {
    e.preventDefault();
    e.stopPropagation();
    const {
      width: containerWidth
    } = viewport.rect;
    const dragging = new DragController(new MouseMoveEventProvider(graphController.getGlobalEventTarget()), defaultGetPositionFromEvent);

    dragging.onMove = ({
      dx: scrollbarDx,
      e: rawEvent
    }) => {
      const {
        totalContentWidth
      } = scrollbarLayoutRef.current;
      const dx = -(scrollbarDx * totalContentWidth) / containerWidth;
      eventChannel.trigger({
        type: GraphScrollBarEvent.Scroll,
        rawEvent,
        dx,
        dy: 0
      });
    };

    dragging.onEnd = () => {
      eventChannel.trigger({
        type: GraphScrollBarEvent.ScrollEnd
      });
    };

    dragging.start(e.nativeEvent);
    eventChannel.trigger({
      type: GraphScrollBarEvent.ScrollStart
    });
  }

  return jsxs(Fragment, {
    children: [vertical && jsx("div", Object.assign({
      className: classes.verticalScrollWrapper
    }, {
      children: jsx("div", {
        className: classes.verticalScrollStyle,
        onMouseDown: onVerticalScrollMouseDown,
        role: "button",
        "aria-label": "vertical scrollbar",
        "aria-roledescription": "vertical scrollbar",
        id: "canvas-vertical-scrollbar"
      })
    })), horizontal && jsx("div", Object.assign({
      className: classes.horizontalScrollWrapper
    }, {
      children: jsx("div", {
        className: classes.horizontalScrollStyle,
        onMouseDown: onHorizontalScrollMouseDown,
        role: "button",
        "aria-label": "horizontal scrollbar",
        "aria-roledescription": "horizontal scrollbar",
        id: "canvas-horizontal-scrollbar"
      })
    }))]
  });
}; // =========================== utils for scroll bar ================================

/**
 * get the total content height, including the container height and the scrollable area
 *
 * @param containerHeight
 * @param offsetLimit
 * @returns totalContentHeight
 */

function getTotalContentHeight(containerHeight, offsetLimit) {
  const {
    minY,
    maxY
  } = offsetLimit;
  return containerHeight + maxY - minY;
}
/**
 * get the total content width, including the container width and the scrollable area
 *
 * @param containerWidth
 * @param offsetLimit
 * @returns totalContentWidth
 */


function getTotalContentWidth(containerWidth, offsetLimit) {
  const {
    minX,
    maxX
  } = offsetLimit;
  return containerWidth + maxX - minX;
}
/**
 * get the scrollbar size and position
 *
 * @param rect
 * @param offsetLimit
 * @param zoomPanSettings
 * @returns
 */


function getScrollbarLayout(viewport, offsetLimit) {
  const {
    rect,
    transformMatrix
  } = viewport;
  const totalContentHeight = getTotalContentHeight(rect.height, offsetLimit);
  const totalContentWidth = getTotalContentWidth(rect.width, offsetLimit);
  return {
    totalContentHeight,
    totalContentWidth,
    verticalScrollHeight: rect.height * rect.height / totalContentHeight,
    horizontalScrollWidth: rect.width * rect.width / totalContentWidth,
    verticalScrollTop: (offsetLimit.maxY - transformMatrix[5]) * rect.height / totalContentHeight,
    horizontalScrollLeft: (offsetLimit.maxX - transformMatrix[4]) * rect.width / totalContentWidth
  };
}

const Transform = ({
  matrix,
  children
}) => {
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const transform = React.useMemo(() => `matrix(${matrix.join(" ")})`, matrix);
  return jsx("g", Object.assign({
    transform: transform
  }, {
    children: children
  }));
};

function getHintPoints(source, target, {
  minX,
  minY,
  maxX,
  maxY
}, yOnRightAxis, xOnBottomAxis, xOnTopAxis, yOnLeftAxis) {
  if (source.x === target.x) {
    return {
      x: source.x,
      y: source.y < target.y ? maxY : minY
    };
  }

  if (source.x < target.x) {
    if (source.y < target.y) {
      return yOnRightAxis <= maxY ? {
        x: maxX,
        y: yOnRightAxis
      } : {
        x: xOnBottomAxis,
        y: maxY
      };
    } else {
      return yOnRightAxis >= minY ? {
        x: maxX,
        y: yOnRightAxis
      } : {
        x: xOnTopAxis,
        y: minY
      };
    }
  }

  if (source.y < target.y) {
    return xOnBottomAxis > minX ? {
      x: xOnBottomAxis,
      y: maxY
    } : {
      x: minX,
      y: yOnLeftAxis
    };
  }

  return yOnLeftAxis > minY ? {
    x: minX,
    y: yOnLeftAxis
  } : {
    x: xOnTopAxis,
    y: minY
  };
}

const GraphEdge = /*#__PURE__*/React.memo( // eslint-disable-next-line complexity
props => {
  var _a;

  const {
    edge,
    data: graphModel,
    eventChannel,
    source,
    target,
    graphId
  } = props;
  const graphConfig = useGraphConfig();
  const virtualization = useVirtualization();
  const {
    viewport,
    renderedArea,
    visibleArea
  } = virtualization;

  const edgeEvent = type => e => {
    e.persist();
    eventChannel.trigger({
      type,
      edge,
      rawEvent: e
    });
  };

  const isSourceRendered = isPointInRect(renderedArea, source);
  const isTargetRendered = isPointInRect(renderedArea, target);
  const isVisible = isSourceRendered && isTargetRendered;
  React.useLayoutEffect(() => {
    if (isVisible) {
      virtualization.renderedEdges.add(edge.id);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [virtualization]);

  if (!isVisible) {
    return null;
  }

  const edgeConfig = graphConfig.getEdgeConfig(edge);

  if (!edgeConfig) {
    Debug.warn(`invalid edge ${JSON.stringify(edge)}`);
    return null;
  }

  if (!edgeConfig.render) {
    Debug.warn(`Missing "render" method in edge config ${JSON.stringify(edge)}`);
    return null;
  }

  const isSourceVisible = isPointInRect(visibleArea, source);
  const isTargetVisible = isPointInRect(visibleArea, target);
  let edgeNode = edgeConfig.render({
    model: edge,
    data: graphModel,
    x1: source.x,
    y1: source.y,
    x2: target.x,
    y2: target.y,
    viewport
  });

  if (has(GraphEdgeStatus.ConnectedToSelected)(edge.status) && (!isSourceVisible || !isTargetVisible)) {
    const linearFunction = getLinearFunction(source.x, source.y, target.x, target.y);
    const inverseLinearFunction = getLinearFunction(source.y, source.x, target.y, target.x);
    const hintSource = isSourceVisible ? source : target;
    const hintTarget = isSourceVisible ? target : source;
    const yOnRightAxis = linearFunction(visibleArea.maxX);
    const xOnBottomAxis = inverseLinearFunction(visibleArea.maxY);
    const xOnTopAxis = inverseLinearFunction(visibleArea.minY);
    const yOnLeftAxis = linearFunction(visibleArea.minX);
    const hintPoint = getHintPoints(hintSource, hintTarget, visibleArea, yOnRightAxis, xOnBottomAxis, xOnTopAxis, yOnLeftAxis);

    if (isSourceVisible && edgeConfig.renderWithTargetHint) {
      edgeNode = edgeConfig.renderWithTargetHint({
        model: edge,
        data: graphModel,
        x1: source.x,
        y1: source.y,
        x2: hintPoint.x,
        y2: hintPoint.y,
        viewport
      });
    } else if (isTargetVisible && edgeConfig.renderWithSourceHint) {
      edgeNode = edgeConfig.renderWithSourceHint({
        model: edge,
        data: graphModel,
        x1: hintPoint.x,
        y1: hintPoint.y,
        x2: target.x,
        y2: target.y,
        viewport
      });
    }
  }

  const id = getEdgeUid(graphId, edge);
  const className = `edge-container-${edge.id}`;
  const automationId = (_a = edge.automationId) !== null && _a !== void 0 ? _a : className;
  return jsx("g", Object.assign({
    id: id,
    onClick: edgeEvent(GraphEdgeEvent.Click),
    onDoubleClick: edgeEvent(GraphEdgeEvent.DoubleClick),
    onMouseDown: edgeEvent(GraphEdgeEvent.MouseDown),
    onMouseUp: edgeEvent(GraphEdgeEvent.MouseUp),
    onMouseEnter: edgeEvent(GraphEdgeEvent.MouseEnter),
    onMouseLeave: edgeEvent(GraphEdgeEvent.MouseLeave),
    onContextMenu: edgeEvent(GraphEdgeEvent.ContextMenu),
    onMouseMove: edgeEvent(GraphEdgeEvent.MouseMove),
    onMouseOver: edgeEvent(GraphEdgeEvent.MouseOver),
    onMouseOut: edgeEvent(GraphEdgeEvent.MouseOut),
    onFocus: undefined,
    onBlur: undefined,
    className: className,
    "data-automation-id": automationId
  }, {
    children: edgeNode
  }));
});

function compareEqual(prev, props) {
  return prev.node === props.node;
}

const EdgeChampNodeRender = /*#__PURE__*/React.memo(props => {
  var _a, _b;

  const {
    node,
    data
  } = props,
        others = __rest(props, ["node", "data"]);

  const graphConfig = useGraphConfig();
  const values = [];
  const valueCount = node.valueCount;

  for (let i = 0; i < valueCount; i += 1) {
    const it = node.getValue(i);
    const source = (_a = data.nodes.get(it.source)) === null || _a === void 0 ? void 0 : _a.getPortPosition(it.sourcePortId, graphConfig);
    const target = (_b = data.nodes.get(it.target)) === null || _b === void 0 ? void 0 : _b.getPortPosition(it.targetPortId, graphConfig);

    if (source && target) {
      values.push( /*#__PURE__*/createElement(GraphEdge, Object.assign({}, others, {
        key: it.id,
        data: data,
        edge: it,
        source: source,
        target: target
      })));
    }
  }

  const children = [];
  const nodeCount = node.nodeCount;

  for (let i = 0; i < nodeCount; i += 1) {
    const it = node.getNode(i);

    if (it.type === NodeType$1.Bitmap) {
      children.push(jsx(EdgeChampNodeRender, Object.assign({}, props, {
        node: it
      }), node.getHash(i)));
    } else {
      children.push(jsx(EdgeHashCollisionNodeRender, Object.assign({}, props, {
        node: it
      }), it.getHash()));
    }
  }

  return jsxs(Fragment, {
    children: [values, children]
  });
}, compareEqual);
EdgeChampNodeRender.displayName = "EdgeChampNodeRender";
const EdgeHashCollisionNodeRender = /*#__PURE__*/React.memo(props => {
  const {
    data,
    node
  } = props,
        others = __rest(props, ["data", "node"]);

  const graphConfig = useGraphConfig();
  return jsx(Fragment, {
    children: node.values.map(edge => {
      var _a, _b;

      const source = (_a = data.nodes.get(edge.source)) === null || _a === void 0 ? void 0 : _a.getPortPosition(edge.sourcePortId, graphConfig);
      const target = (_b = data.nodes.get(edge.target)) === null || _b === void 0 ? void 0 : _b.getPortPosition(edge.targetPortId, graphConfig);

      if (source && target) {
        return /*#__PURE__*/createElement(GraphEdge, Object.assign({}, others, {
          key: edge.id,
          data: data,
          edge: edge,
          source: source,
          target: target
        }));
      } else {
        return null;
      }
    })
  });
}, compareEqual);
EdgeHashCollisionNodeRender.displayName = "EdgeHashCollisionNodeRender";
const EdgeTree = props => {
  const {
    tree
  } = props,
        others = __rest(props, ["tree"]);

  return jsx(EdgeChampNodeRender, Object.assign({}, others, {
    node: tree.root
  }));
};

// use static css file here
const styles = mergeStyleSets({
  svg: [{
    position: "absolute",
    overflow: "hidden",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%"
  }, {
    "&:focus": {
      outline: "none"
    }
  }],
  node: {
    cursor: "move"
  },
  container: {
    position: "relative",
    width: "100%",
    height: "100%",
    overflow: "hidden",
    touchAction: "none"
  },
  buttonA11Y: {
    opacity: 0,
    width: 0,
    height: 0,
    overflow: "hidden"
  },
  addingNodeSvg: {
    zIndex: 1000000,
    position: "fixed",
    left: 0,
    top: 0,
    width: "100%",
    height: "100%"
  },
  moduleItem: {
    userSelect: "none",
    cursor: "pointer"
  },
  minimap: {
    height: 320,
    width: 320,
    userSelect: "none",
    touchAction: "none"
  },
  minimapSvg: {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%"
  }
});

const GraphNode = props => {
  var _a;

  const {
    node,
    eventChannel,
    getNodeAriaLabel,
    viewport,
    graphId
  } = props;
  const graphConfig = useGraphConfig();
  const nodeConfig = getNodeConfig(node, graphConfig);

  const nodeEvent = type => evt => {
    evt.persist();
    const e = {
      type,
      node,
      rawEvent: evt
    };
    eventChannel.trigger(e);
  };

  const onClick = e => {
    e.persist();
    const isMultiSelect = checkIsMultiSelect(e);
    eventChannel.trigger({
      type: GraphNodeEvent.Click,
      rawEvent: e,
      isMultiSelect,
      node
    });
  };

  const id = getNodeUid(graphId, node);
  const automationId = (_a = node.automationId) !== null && _a !== void 0 ? _a : getNodeAutomationId(node);

  if (!(nodeConfig === null || nodeConfig === void 0 ? void 0 : nodeConfig.render)) {
    Debug.warn(`Missing "render" method in node config`);
    return null;
  }

  return jsx("g", Object.assign({
    id: id,
    // for IE and Edge
    focusable: "true",
    tabIndex: 0,
    className: styles.node,
    onPointerDown: nodeEvent(GraphNodeEvent.PointerDown),
    onPointerEnter: nodeEvent(GraphNodeEvent.PointerEnter),
    onPointerMove: nodeEvent(GraphNodeEvent.PointerMove),
    onPointerLeave: nodeEvent(GraphNodeEvent.PointerLeave),
    onPointerUp: nodeEvent(GraphNodeEvent.PointerUp),
    onDoubleClick: nodeEvent(GraphNodeEvent.DoubleClick),
    onMouseDown: nodeEvent(GraphNodeEvent.MouseDown),
    onMouseUp: nodeEvent(GraphNodeEvent.MouseUp),
    onMouseEnter: nodeEvent(GraphNodeEvent.MouseEnter),
    onMouseLeave: nodeEvent(GraphNodeEvent.MouseLeave),
    onContextMenu: nodeEvent(GraphNodeEvent.ContextMenu),
    onMouseMove: nodeEvent(GraphNodeEvent.MouseMove),
    onMouseOver: nodeEvent(GraphNodeEvent.MouseOver),
    onMouseOut: nodeEvent(GraphNodeEvent.MouseOut),
    onClick: onClick,
    onKeyDown: nodeEvent(GraphNodeEvent.KeyDown),
    "aria-label": getNodeAriaLabel(node),
    role: "group",
    "aria-roledescription": "node",
    "data-automation-id": automationId
  }, {
    children: jsx("g", Object.assign({
      className: "node-box-container"
    }, {
      children: nodeConfig.render({
        model: node,
        viewport
      })
    }))
  }));
};

const RESIZE_POINT_WIDTH = 8;
const RESIZE_POINT_HEIGHT = 8;
const NodeAnchor = ({
  x,
  y,
  cursor,
  onMouseDown
}) => {
  return jsx(Slots.NodeResizeHandler, Object.assign({
    x: x,
    y: y,
    cursor: cursor,
    onMouseDown: onMouseDown
  }, {
    children: jsx("rect", {
      x: x,
      y: y,
      height: RESIZE_POINT_HEIGHT,
      width: RESIZE_POINT_WIDTH,
      stroke: defaultColors.controlPointColor,
      fill: "transparent",
      cursor: cursor,
      onMouseDown: onMouseDown
    })
  }));
};

const BBOX_PADDING = 15;
const GraphNodeAnchors = props => {
  var _a, _b;

  const {
    node,
    getMouseDown
  } = props;
  const graphConfig = useGraphConfig();
  const nodeConfig = getNodeConfig(node, graphConfig);
  const minWidth = (_a = nodeConfig === null || nodeConfig === void 0 ? void 0 : nodeConfig.getMinWidth(node)) !== null && _a !== void 0 ? _a : 0;
  const minHeight = (_b = nodeConfig === null || nodeConfig === void 0 ? void 0 : nodeConfig.getMinHeight(node)) !== null && _b !== void 0 ? _b : 0;
  const height = getRectHeight(nodeConfig, node);
  const width = getRectWidth(nodeConfig, node);
  const nw = getMouseDown((dx, dy) => {
    const finalDx = Math.min(dx, width - minWidth);
    const finalDy = Math.min(dy, height - minHeight);
    return {
      dx: +finalDx,
      dy: +finalDy,
      dWidth: -finalDx,
      dHeight: -finalDy
    };
  });
  const n = getMouseDown((_dx, dy) => {
    const finalDy = Math.min(dy, height - minHeight);
    return {
      dy: +finalDy,
      dHeight: -finalDy
    };
  });
  const ne = getMouseDown((dx, dy) => {
    const finalDx = Math.max(dx, minWidth - width);
    const finalDy = Math.min(dy, height - minHeight);
    return {
      dy: +finalDy,
      dWidth: +finalDx,
      dHeight: -finalDy
    };
  });
  const e = getMouseDown(dx => {
    const finalDx = Math.max(dx, minWidth - width);
    return {
      dWidth: +finalDx
    };
  });
  const se = getMouseDown((dx, dy) => {
    const finalDx = Math.max(dx, minWidth - width);
    const finalDy = Math.max(dy, minHeight - height);
    return {
      dWidth: +finalDx,
      dHeight: +finalDy
    };
  });
  const s = getMouseDown((_dx, dy) => {
    const finalDy = Math.max(dy, minHeight - height);
    return {
      dHeight: +finalDy
    };
  });
  const sw = getMouseDown((dx, dy) => {
    const finalDx = Math.min(dx, width - minWidth);
    const finalDy = Math.max(dy, minHeight - height);
    return {
      dx: +finalDx,
      dWidth: -finalDx,
      dHeight: +finalDy
    };
  });
  const w = getMouseDown(dx => {
    const finalDx = Math.min(dx, width - minWidth);
    return {
      dx: finalDx,
      dWidth: -finalDx
    };
  });
  return jsxs(Fragment, {
    children: [jsx(NodeAnchor, {
      cursor: "nw-resize",
      x: node.x - BBOX_PADDING,
      y: node.y - BBOX_PADDING - RESIZE_POINT_HEIGHT,
      onMouseDown: nw
    }, "nw-resize"), jsx(NodeAnchor, {
      x: node.x + width / 2 - RESIZE_POINT_WIDTH / 2,
      y: node.y - BBOX_PADDING - RESIZE_POINT_HEIGHT,
      cursor: "n-resize",
      onMouseDown: n
    }, "n-resize"), jsx(NodeAnchor, {
      x: node.x + width + BBOX_PADDING - RESIZE_POINT_WIDTH,
      y: node.y - BBOX_PADDING - RESIZE_POINT_HEIGHT,
      cursor: "ne-resize",
      onMouseDown: ne
    }, "ne-resize"), jsx(NodeAnchor, {
      x: node.x + width + BBOX_PADDING - RESIZE_POINT_WIDTH,
      y: node.y + height / 2 - RESIZE_POINT_HEIGHT / 2,
      cursor: "e-resize",
      onMouseDown: e
    }, "e-resize"), jsx(NodeAnchor, {
      x: node.x + width + BBOX_PADDING - RESIZE_POINT_WIDTH,
      y: node.y + height + BBOX_PADDING,
      cursor: "se-resize",
      onMouseDown: se
    }, "se-resize"), jsx(NodeAnchor, {
      x: node.x + width / 2 - RESIZE_POINT_WIDTH / 2,
      y: node.y + height + BBOX_PADDING,
      cursor: "s-resize",
      onMouseDown: s
    }, "s-resize"), jsx(NodeAnchor, {
      x: node.x - BBOX_PADDING,
      y: node.y + height + BBOX_PADDING,
      cursor: "sw-resize",
      onMouseDown: sw
    }, "sw-resize"), jsx(NodeAnchor, {
      x: node.x - BBOX_PADDING,
      y: node.y + height / 2 - RESIZE_POINT_HEIGHT / 2,
      cursor: "w-resize",
      onMouseDown: w
    }, "w-resize")]
  });
};

const GraphOneNodePorts = props => {
  const {
    data,
    node,
    getPortAriaLabel,
    eventChannel,
    viewport,
    graphId
  } = props;
  const graphConfig = useGraphConfig();
  const ports = node.ports;

  if (!ports) {
    return null;
  }

  const portEvent = (type, port) => e => {
    e.persist();
    eventChannel.trigger({
      type,
      node,
      port,
      rawEvent: e
    });
  };

  return jsx("g", {
    children: ports.map(p => {
      var _a;

      const portConfig = graphConfig.getPortConfig(p);

      if (!portConfig || !portConfig.render) {
        Debug.warn(`invalid port config ${node.id}:${node.name} - ${p.id}:${p.name}`);
        return null;
      }

      const pos = node.getPortPosition(p.id, graphConfig);

      if (!pos) {
        return null;
      }

      const portKey = getPortUid(graphId, node, p);
      const automationId = (_a = p.automationId) !== null && _a !== void 0 ? _a : getPortAutomationId(p, node);
      return jsx("g", Object.assign({
        id: portKey,
        tabIndex: 0,
        // for IE and Edge
        focusable: "true",
        onPointerDown: portEvent(GraphPortEvent.PointerDown, p),
        onPointerUp: portEvent(GraphPortEvent.PointerUp, p),
        onDoubleClick: portEvent(GraphPortEvent.DoubleClick, p),
        onMouseDown: portEvent(GraphPortEvent.MouseDown, p),
        onMouseUp: portEvent(GraphPortEvent.MouseUp, p),
        onContextMenu: portEvent(GraphPortEvent.ContextMenu, p),
        onPointerEnter: portEvent(GraphPortEvent.PointerEnter, p),
        onPointerLeave: portEvent(GraphPortEvent.PointerLeave, p),
        onMouseMove: portEvent(GraphPortEvent.MouseMove, p),
        onMouseOver: portEvent(GraphPortEvent.MouseOver, p),
        onMouseOut: portEvent(GraphPortEvent.MouseOut, p),
        onFocus: portEvent(GraphPortEvent.Focus, p),
        onBlur: portEvent(GraphPortEvent.Blur, p),
        onKeyDown: portEvent(GraphPortEvent.KeyDown, p),
        onClick: portEvent(GraphPortEvent.Click, p),
        "aria-label": getPortAriaLabel(data, node, p),
        role: "group",
        "aria-roledescription": "port",
        "data-automation-id": automationId
      }, {
        children: jsx(ConnectingStateContext.Consumer, {
          children: ({
            sourceNode,
            sourcePort
          }) => portConfig === null || portConfig === void 0 ? void 0 : portConfig.render(Object.assign({
            model: p,
            data,
            parentNode: node,
            anotherNode: sourceNode,
            anotherPort: sourcePort,
            viewport
          }, pos))
        })
      }), portKey);
    })
  });
};

const GraphNodeParts = _a => {
  var {
    node,
    isNodeResizable,
    renderNodeAnchors
  } = _a,
      commonProps = __rest(_a, ["node", "isNodeResizable", "renderNodeAnchors"]);

  const virtualization = useVirtualization();
  const {
    renderedArea,
    viewport
  } = virtualization;
  const getMouseDown = useGetMouseDownOnAnchor(node, commonProps.eventChannel);
  const isVisible = isPointInRect(renderedArea, node);
  React.useLayoutEffect(() => {
    if (isVisible) {
      virtualization.renderedEdges.add(node.id);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [virtualization]);

  if (!isVisible) {
    return null;
  }

  let nodeAnchors;

  if (isNodeResizable && isNodeEditing(node)) {
    const defaultAnchors = jsx(GraphNodeAnchors, {
      node: node,
      getMouseDown: getMouseDown
    });

    nodeAnchors = renderNodeAnchors ? renderNodeAnchors(node, getMouseDown, defaultAnchors) : defaultAnchors;
  }

  return jsxs(Fragment, {
    children: [jsx(GraphNode, Object.assign({}, commonProps, {
      node: node,
      viewport: viewport
    })), jsx(GraphOneNodePorts, Object.assign({}, commonProps, {
      node: node,
      viewport: viewport
    })), nodeAnchors]
  });
};

const GraphNodePartsMemo = /*#__PURE__*/React.memo(GraphNodeParts);

const NodeTreeNode = /*#__PURE__*/React.memo(_a => {
  var {
    node
  } = _a,
      others = __rest(_a, ["node"]);

  const values = node.values.map(arg => {
    const it = arg[1];
    return jsx(GraphNodePartsMemo, Object.assign({
      node: it
    }, others), it.id);
  });
  const children = node.type === NodeType.Internal ? node.children.map((child, index) => {
    const key = index < node.selfSize ? node.getKey(index) : "last";
    return jsx(NodeTreeNode, Object.assign({
      node: child
    }, others), key);
  }) : undefined;
  return jsxs(Fragment, {
    children: [values, children]
  });
}, (prevProps, nextProps) => prevProps.node === nextProps.node);
NodeTreeNode.displayName = "NodeTreeNode";
const NodeTree = _a => {
  var {
    tree
  } = _a,
      others = __rest(_a, ["tree"]);

  return jsx(NodeTreeNode, Object.assign({
    node: tree.sortedRoot
  }, others));
};

const NodeLayers = ({
  data,
  renderTree
}) => {
  const layers = new Set();
  data.nodes.forEach(n => layers.add(n.layer));
  return jsx(Fragment, {
    children: Array.from(layers.values()).sort().map(l => renderTree(data.nodes.filter(n => n.layer === l), l))
  });
};

const VirtualizationProvider = ({
  viewport,
  isVirtualizationEnabled,
  virtualizationDelay,
  eventChannel,
  children
}) => {
  const renderedArea = useRenderedArea(viewport, isVirtualizationEnabled);
  const visibleArea = React.useMemo(() => getVisibleArea(viewport), [viewport]);
  const contextValue = React.useMemo(() => ({
    viewport,
    renderedArea,
    visibleArea,
    renderedEdges: new Set(),
    renderedNodes: new Set(),
    timestamp: performance.now()
  }), [viewport, renderedArea, visibleArea]);
  const context = useDeferredValue(contextValue, {
    timeout: virtualizationDelay
  });
  const previousContextRef = React.useRef(context);
  React.useEffect(() => {
    const previousContext = previousContextRef.current;
    previousContextRef.current = context;
    eventChannel.trigger({
      type: GraphCanvasEvent.VirtualizationRecalculated,
      performanceStartTime: context.timestamp,
      renderedNodes: previousContext.renderedNodes,
      renderedEdges: previousContext.renderedEdges,
      previousRenderedNodes: previousContext.renderedNodes,
      previousRenderedEdges: previousContext.renderedEdges
    });
  }, [context, eventChannel]);
  return jsx(VirtualizationContext.Provider, Object.assign({
    value: context
  }, {
    children: children
  }));
};

const getCursorStyle = ({
  canvasMouseMode,
  state,
  isPanDisabled,
  isMultiSelecting
}) => {
  if (state.behavior === GraphBehavior.Connecting) {
    return "initial";
  }

  const isClickMultipleSelect = ["meta", "control"].some(key => state.activeKeys.has(key));

  if (isClickMultipleSelect) {
    return "initial";
  }

  const isAreaSelection = state.activeKeys.has("shift");

  if (isAreaSelection) {
    return "crosshair";
  } // selection mode


  if (canvasMouseMode !== CanvasMouseMode.Pan) {
    if (state.activeKeys.has(" ") && !isPanDisabled) {
      return "grab";
    }

    if (isMultiSelecting) {
      return "crosshair";
    }

    return "inherit";
  }

  return isPanDisabled ? "inherit" : "grab";
};
/**
 * @param state
 * @param isNodeDraggable
 */


function getNodeCursor(isNodeDraggable) {
  return isNodeDraggable ? "move" : "initial";
}

const getGraphStyles = (props, state, isPanDisabled, isNodeDraggable, focusedWithoutMouse, isMultiSelecting) => {
  var _a, _b;

  return mergeStyleSets({
    svg: ["react-dag-editor-svg-container", styles.svg, (_a = props.styles) === null || _a === void 0 ? void 0 : _a.svg, {
      "& *:focus": {
        outline: defaultColors.outlineStyle
      },
      [`& .${styles.node}`]: {
        cursor: getNodeCursor(isNodeDraggable)
      }
    }],
    container: ["react-dag-editor-container", styles.container, {
      cursor: getCursorStyle({
        canvasMouseMode: props.canvasMouseMode,
        state,
        isPanDisabled,
        isMultiSelecting
      }),
      [`&.${styles.container}`]: Object.assign(Object.assign({
        background: defaultColors.canvasBackground
      }, props.style), (_b = props.styles) === null || _b === void 0 ? void 0 : _b.root)
    }, focusedWithoutMouse && {
      outline: `${defaultColors.focusOutlineColor} solid 1px`
    }],
    buttonA11y: ["react-dag-editor-a11y-help-button", styles.buttonA11Y],
    node: [styles.node]
  });
};

function Graph(props) {
  var _a, _b, _c, _d, _e;

  const [focusedWithoutMouse, setFocusedWithoutMouse] = React.useState(false);
  const graphController = useGraphController();
  const {
    state,
    dispatch
  } = useGraphState();
  const data = state.data.present;
  const {
    viewport
  } = state;
  const {
    eventChannel
  } = graphController;
  const graphId = useConst(() => `graph-${v4()}`);
  const defaultSVGRef = React.useRef(null);
  const {
    focusCanvasAccessKey = "f",
    zoomSensitivity = 0.1,
    scrollSensitivity = 0.5,
    svgRef = defaultSVGRef,
    virtualizationDelay = 500,
    background = null
  } = props;
  const graphConfig = useGraphConfig();
  const featureControl = useFeatureControl(state.settings.features);
  const [curHoverNode, setCurHoverNode] = React.useState();
  const [curHoverPort, setCurHoverPort] = React.useState(undefined);
  const containerRef = React.useRef(null);
  const rectRef = React.useRef(undefined);
  const updateViewport = useUpdateViewportCallback(rectRef, svgRef, eventChannel);
  useEventChannel({
    props,
    dispatch,
    rectRef,
    svgRef,
    setFocusedWithoutMouse,
    containerRef,
    featureControl,
    graphConfig,
    setCurHoverNode,
    setCurHoverPort,
    updateViewport,
    eventChannel,
    graphController
  });
  useContainerRect(state, svgRef, containerRef, updateViewport);
  const {
    isNodesDraggable,
    isNodeResizable,
    isPanDisabled,
    isMultiSelectDisabled,
    isLassoSelectEnable,
    isNodeEditDisabled,
    isVerticalScrollDisabled,
    isHorizontalScrollDisabled,
    isA11yEnable,
    isCtrlKeyZoomEnable,
    isVirtualizationEnabled,
    isScrollbarVisible
  } = featureControl;
  useSelectBox(dispatch, state.selectBoxPosition);

  const canvasEventHandler = type => rawEvent => {
    rawEvent.persist();
    eventChannel.trigger({
      type,
      rawEvent
    });
  };

  const classes = getGraphStyles(props, state, isPanDisabled, isNodesDraggable, focusedWithoutMouse, state.behavior === GraphBehavior.MultiSelect);
  useWheelHandler({
    containerRef,
    svgRef,
    rectRef,
    zoomSensitivity,
    scrollSensitivity,
    dispatch,
    isHorizontalScrollDisabled,
    isVerticalScrollDisabled,
    isCtrlKeyZoomEnable,
    eventChannel,
    graphConfig
  });
  const onContextMenuClick = React.useCallback(evt => {
    evt.preventDefault();
    evt.stopPropagation();
    eventChannel.trigger({
      type: GraphContextMenuEvent.Close
    });

    if (svgRef.current) {
      // to prevent: the keyboard events will be disabled after using the context menu (because the context menu is not the element of svg)
      svgRef.current.focus({
        preventScroll: true
      });
    }
  }, [eventChannel, svgRef]);
  const onFocusButtonClick = React.useCallback(() => {
    setFocusedWithoutMouse(true);

    if (svgRef.current) {
      svgRef.current.focus({
        preventScroll: true
      });
    }
  }, [svgRef]);
  useSafariScale({
    rectRef,
    svgRef,
    eventChannel
  });
  const accessKey = isA11yEnable ? focusCanvasAccessKey : undefined;
  const touchHandlers = useGraphTouchHandler(rectRef, eventChannel);
  const renderNodeTree = React.useCallback((tree, layer) => {
    var _a, _b;

    return jsx(NodeTree, {
      graphId: graphId,
      isNodeResizable: isNodeResizable,
      tree: tree,
      data: data,
      isNodeEditDisabled: isNodeEditDisabled,
      eventChannel: eventChannel,
      getNodeAriaLabel: (_a = props.getNodeAriaLabel) !== null && _a !== void 0 ? _a : defaultGetNodeAriaLabel,
      getPortAriaLabel: (_b = props.getPortAriaLabel) !== null && _b !== void 0 ? _b : defaultGetPortAriaLabel,
      renderNodeAnchors: props.renderNodeAnchors
    }, layer);
  }, [data, eventChannel, graphId, isNodeEditDisabled, isNodeResizable, props.getNodeAriaLabel, props.getPortAriaLabel, props.renderNodeAnchors]);

  if (!isSupported()) {
    const {
      onBrowserNotSupported = () => jsx("p", {
        children: "Your browser is not supported"
      })
    } = props;
    return jsx(Fragment, {
      children: onBrowserNotSupported()
    });
  }

  const renderPortTooltip = () => {
    if (!curHoverPort || !isViewportComplete(state.viewport)) {
      return null;
    }

    const [nodeId, portId] = curHoverPort;
    const node = data.nodes.get(nodeId);

    if (!node) {
      return null;
    }

    const port = node.getPort(portId);

    if (!port) {
      return null;
    }

    return jsx(PortTooltips, {
      port: port,
      parentNode: node,
      data: data,
      viewport: state.viewport
    });
  };

  const renderNodeTooltip = () => {
    var _a;

    if (!curHoverNode || !isViewportComplete(state.viewport)) {
      return null;
    } // do not show tooltip if current node has contextmenu


    const curHoverNodeHasContextMenu = state.contextMenuPosition && curHoverNode === ((_a = state.data.present.nodes.find(isSelected)) === null || _a === void 0 ? void 0 : _a.id);

    if (curHoverNodeHasContextMenu) {
      return null;
    }

    return jsx(NodeTooltips, {
      node: data.nodes.get(curHoverNode),
      viewport: state.viewport
    });
  };

  return jsxs("div", Object.assign({
    ref: containerRef,
    role: "application",
    id: graphId,
    className: classes.container
  }, touchHandlers, {
    onDoubleClick: canvasEventHandler(GraphCanvasEvent.DoubleClick),
    onMouseDown: canvasEventHandler(GraphCanvasEvent.MouseDown),
    onMouseUp: canvasEventHandler(GraphCanvasEvent.MouseUp),
    onContextMenu: canvasEventHandler(GraphCanvasEvent.ContextMenu),
    onMouseMove: canvasEventHandler(GraphCanvasEvent.MouseMove),
    onMouseOver: canvasEventHandler(GraphCanvasEvent.MouseOver),
    onMouseOut: canvasEventHandler(GraphCanvasEvent.MouseOut),
    onFocus: canvasEventHandler(GraphCanvasEvent.Focus),
    onBlur: canvasEventHandler(GraphCanvasEvent.Blur),
    onKeyDown: canvasEventHandler(GraphCanvasEvent.KeyDown),
    onKeyUp: canvasEventHandler(GraphCanvasEvent.KeyUp)
  }, {
    children: [jsx("button", {
      className: classes.buttonA11y,
      onClick: onFocusButtonClick,
      accessKey: accessKey,
      hidden: true
    }), jsxs("svg", Object.assign({
      tabIndex: 0,
      // for IE and Edge
      focusable: "true",
      preserveAspectRatio: "xMidYMid meet",
      ref: svgRef,
      className: classes.svg,
      "data-graph-id": graphId
    }, {
      children: [jsx("title", {
        children: props.title
      }), jsx("desc", {
        children: props.desc
      }), jsxs(Transform, Object.assign({
        matrix: viewport.transformMatrix
      }, {
        children: [state.viewport.rect && jsxs(VirtualizationProvider, Object.assign({
          viewport: state.viewport,
          isVirtualizationEnabled: isVirtualizationEnabled,
          virtualizationDelay: virtualizationDelay,
          eventChannel: eventChannel
        }, {
          children: [background, jsx(GraphGroupsRenderer, {
            data: data,
            groups: (_a = data.groups) !== null && _a !== void 0 ? _a : constantEmptyArray()
          }), jsx(EdgeTree, {
            graphId: graphId,
            tree: data.edges,
            data: data,
            eventChannel: eventChannel
          }), jsx(NodeLayers, {
            data: data,
            renderTree: renderNodeTree
          })]
        })), state.dummyNodes.isVisible && jsx(AnimatingNodeGroup, {
          dummyNodes: state.dummyNodes,
          graphData: state.data.present
        }), jsx(AlignmentLines, {
          style: (_b = props.styles) === null || _b === void 0 ? void 0 : _b.alignmentLine
        })]
      })), (!isMultiSelectDisabled || isLassoSelectEnable) && jsx(SelectBox, {
        selectBoxPosition: state.selectBoxPosition,
        style: (_c = props.styles) === null || _c === void 0 ? void 0 : _c.selectBox
      }), state.connectState && jsx(Connecting, {
        graphConfig: graphConfig,
        eventChannel: eventChannel,
        viewport: state.viewport,
        styles: (_d = props.styles) === null || _d === void 0 ? void 0 : _d.connectingLine,
        movingPoint: state.connectState.movingPoint
      })]
    })), isScrollbarVisible && isViewportComplete(state.viewport) && jsx(Scrollbar, {
      viewport: state.viewport,
      offsetLimit: getOffsetLimit({
        data,
        graphConfig,
        rect: state.viewport.rect,
        transformMatrix: viewport.transformMatrix,
        canvasBoundaryPadding: state.settings.canvasBoundaryPadding,
        groupPadding: (_e = data.groups[0]) === null || _e === void 0 ? void 0 : _e.padding
      }),
      dispatch: dispatch,
      horizontal: !isHorizontalScrollDisabled,
      vertical: !isVerticalScrollDisabled,
      eventChannel: eventChannel
    }), jsx(GraphContextMenu, {
      state: state,
      onClick: onContextMenuClick,
      "data-automation-id": "context-menu-container"
    }), renderNodeTooltip(), renderPortTooltip()]
  }));
}

const emptyNodeConfig = {
  render() {
    return null;
  },

  getMinHeight() {
    return 0;
  },

  getMinWidth() {
    return 0;
  }

};

function useSvgRect(svgRef) {
  const [rect, setRect] = useState(undefined);
  useLayoutEffect(() => {
    if (!svgRef.current) {
      return;
    }

    setRect(svgRef.current.getBoundingClientRect());
  }, [svgRef]);
  return rect;
}

const AddingNodeSvg = ({
  model,
  svgRef,
  nextNodeRef
}) => {
  const rect = useSvgRect(svgRef);
  const graphConfig = useGraphConfig();
  const graphController = useGraphController();
  const alignmentLines = useAlignmentLines();
  const viewport = useViewport();
  const dummyNode = React.useMemo(() => {
    if (!model || !viewport.rect) {
      return null;
    }

    const {
      transformMatrix
    } = viewport;
    const {
      left,
      top
    } = viewport.rect;
    const diffLeft = left / transformMatrix[0];
    const diffTop = top / transformMatrix[3];
    return Object.assign({
      id: model.id,
      x: model.x - diffLeft,
      y: model.y - diffTop
    }, getNodeSize(model, graphConfig));
  }, [graphConfig, viewport, model]);
  React.useLayoutEffect(() => {
    if (!dummyNode) {
      return;
    }

    graphController.eventChannel.trigger({
      type: GraphCanvasEvent.DraggingNodeFromItemPanel,
      node: dummyNode
    }); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dummyNode === null || dummyNode === void 0 ? void 0 : dummyNode.x, dummyNode === null || dummyNode === void 0 ? void 0 : dummyNode.y]);
  const attachedNode = React.useMemo(() => {
    if (!dummyNode || !model) {
      return null;
    }

    const dxAligned = getAutoAlignDisplacement(alignmentLines, [dummyNode], graphConfig, "x");
    const dyAligned = getAutoAlignDisplacement(alignmentLines, [dummyNode], graphConfig, "y");
    return Object.assign(Object.assign({}, model), {
      x: model.x + dxAligned,
      y: model.y + dyAligned
    });
  }, [alignmentLines, dummyNode, graphConfig, model]);
  React.useEffect(() => {
    nextNodeRef.current = attachedNode;
  }, [nextNodeRef, attachedNode]);
  const eventChannel = useConst(() => new EventChannel());
  const tempGraphId = useConst(v4);
  const node = React.useMemo(() => NodeModel.fromJSON(attachedNode !== null && attachedNode !== void 0 ? attachedNode : model, undefined, undefined), [attachedNode, model]);
  return jsx("svg", Object.assign({
    id: tempGraphId,
    ref: svgRef,
    className: styles.addingNodeSvg,
    preserveAspectRatio: "xMidYMid meet"
  }, {
    children: jsx(Transform, Object.assign({
      matrix: viewport.transformMatrix
    }, {
      children: rect && jsx(GraphNode, {
        graphId: tempGraphId,
        node: node,
        viewport: {
          rect,
          transformMatrix: viewport.transformMatrix
        },
        eventChannel: eventChannel,
        getNodeAriaLabel: defaultGetNodeAriaLabel
      })
    }))
  }));
};

const el = document.createElement("div");
document.body.appendChild(el);
/**
 * @param rect the container clement bounding box rect
 * @param clientX point: x
 * @param clientY point: y
 *
 * @returns boolean value to indicate whether the point is in bound or not.
 */

function isWithInBound(rect, clientX, clientY) {
  const {
    top,
    right,
    bottom,
    left
  } = rect;
  return clientX >= left && clientX <= right && clientY >= top && clientY <= bottom;
}

const adjustedClientPoint = (x, y, rect, transformMatrix) => {
  let adjustedX = x;
  let adjustedY = y;

  if (rect) {
    const {
      left,
      top
    } = rect;
    adjustedX = x - left;
    adjustedY = y - top;
  }

  return reverseTransformPoint(adjustedX, adjustedY, transformMatrix);
}; // adjust position to the middle of the node, and with the correct zoom/pan


const adjustPosition = (clientX, clientY, rect, transformMatrix, node, nodeConfig) => {
  const rectWidth = getRectWidth(nodeConfig, node);
  const rectHeight = getRectHeight(nodeConfig, node); // get transformed width and height

  const realWidth = transformMatrix[0] * rectWidth + transformMatrix[2] * rectHeight;
  const realHeight = transformMatrix[1] * rectWidth + transformMatrix[3] * rectHeight;
  return adjustedClientPoint(clientX - realWidth / 2, clientY - realHeight / 2, rect, transformMatrix);
};
/**
 * The Item in the item panel from which we can add node to the canvas.
 *
 * @param props type IItemProps
 * @returns
 */


const Item = props => {
  const graphConfig = useGraphConfig();
  const graphController = useGraphController();
  const [workingModel, setWorkingModel] = React.useState(null);
  const nextNodeRef = useRefValue(workingModel);
  const svgRef = React.useRef(null);
  const {
    style,
    children,
    getNode,
    dragWillStart = noop
  } = props;
  const onPointerDown = React.useCallback(evt => {
    var _a;

    evt.stopPropagation();

    if (isMouseButNotLeft(evt) || !graphController.getEnabledFeatures().has(GraphFeatures.AddNewNodes)) {
      return;
    }

    const partial = getNode();
    const nodeConfig = (_a = graphConfig.getNodeConfig(partial)) !== null && _a !== void 0 ? _a : emptyNodeConfig;
    const position = adjustPosition(evt.clientX, evt.clientY, undefined, graphController.state.viewport.transformMatrix, partial, nodeConfig);
    const node = Object.assign(Object.assign(Object.assign({}, partial), position), {
      id: partial.id || v4()
    });
    const drag = new DragController(new PointerEventProvider(graphController.getGlobalEventTarget()), defaultGetPositionFromEvent);
    const eventChannel = graphController.eventChannel;
    eventChannel.trigger({
      type: GraphCanvasEvent.DraggingNodeFromItemPanelStart,
      rawEvent: evt
    });

    drag.onMove = ({
      e
    }) => {
      setWorkingModel(n => {
        if (!n) {
          return n;
        }

        return Object.assign(Object.assign({}, n), adjustPosition(e.clientX, e.clientY, undefined, graphController.state.viewport.transformMatrix, n, nodeConfig));
      });
    };

    drag.onEnd = ({
      e
    }) => {
      const viewport = graphController.state.viewport;
      let nextNode = nextNodeRef.current;

      if (!isViewportComplete(viewport) || !nextNode || !isWithInBound(viewport.rect, e.clientX, e.clientY)) {
        setWorkingModel(null);
        eventChannel.trigger({
          type: GraphCanvasEvent.DraggingNodeFromItemPanelEnd,
          node: null
        });
        return;
      }

      nextNodeRef.current = null;
      nextNode = Object.assign(Object.assign({}, nextNode), adjustPosition(e.clientX, e.clientY, viewport.rect, viewport.transformMatrix, nextNode, nodeConfig));
      eventChannel.trigger({
        type: GraphCanvasEvent.DraggingNodeFromItemPanelEnd,
        node: nextNode
      });
      setWorkingModel(null);
    };

    dragWillStart(node);
    setWorkingModel(node);
    drag.start(evt.nativeEvent);
  }, [graphController, getNode, graphConfig, dragWillStart, nextNodeRef]);
  const className = mergeStyles(styles.moduleItem, props.className);
  return jsxs(Fragment, {
    children: [jsx("div", Object.assign({
      className: className,
      style: style,
      onPointerDown: onPointerDown,
      role: "button"
    }, {
      children: children
    })), workingModel && /*#__PURE__*/ReactDOM.createPortal(jsx(AddingNodeSvg, {
      svgRef: svgRef,
      model: workingModel,
      nextNodeRef: nextNodeRef
    }), el)]
  });
};

class TouchDragAdapter {
  constructor() {
    this.startListeners = new Set();
    this.moveListeners = new Set();
    this.endListeners = new Set();
  }

  off(type, callback) {
    switch (type) {
      case "start":
        this.startListeners.delete(callback);
        break;

      case "move":
        this.moveListeners.delete(callback);
        break;

      case "end":
        this.endListeners.delete(callback);
        break;
    }

    return this;
  }

  on(type, callback) {
    switch (type) {
      case "start":
        this.startListeners.add(callback);
        break;

      case "move":
        this.moveListeners.add(callback);
        break;

      case "end":
        this.endListeners.add(callback);
        break;
    }

    return this;
  }

  onStart(_events, e, ...args) {
    this.startListeners.forEach(cb => {
      cb.call(undefined, e, ...args);
    });
  }

  onMove(_events, e, ...args) {
    this.moveListeners.forEach(cb => {
      cb.call(undefined, e, ...args);
    });
  }

  onEnd(e, ...args) {
    this.endListeners.forEach(cb => {
      cb.call(undefined, e, ...args);
    });
  }

}

const StaticNode = props => {
  const {
    node
  } = props;
  const graphConfig = useGraphConfig();
  const nodeConfig = getNodeConfig(node, graphConfig);

  if (nodeConfig === null || nodeConfig === void 0 ? void 0 : nodeConfig.renderStatic) {
    return jsx("g", {
      children: nodeConfig.renderStatic({
        model: node
      })
    });
  }

  const rectHeight = getRectHeight(nodeConfig, node);
  const rectWidth = getRectWidth(nodeConfig, node);
  return jsx("rect", {
    transform: `translate(${node.x}, ${node.y})`,
    height: rectHeight,
    width: rectWidth,
    fill: defaultColors.dummyNodeStroke
  });
};

const StaticNodeWithMemo = /*#__PURE__*/React.memo(StaticNode, (prevProps, nextProps) => {
  const prevNode = prevProps.node;
  const nextNode = nextProps.node;
  return prevNode.x === nextNode.x && prevNode.y === nextNode.y && prevNode.height === nextNode.height && prevNode.width === nextNode.width && prevNode.isInSearchResults === nextNode.isInSearchResults && prevNode.isCurrentSearchResult === nextNode.isCurrentSearchResult;
});

const ReadonlyNodeTreeNode = /*#__PURE__*/React.memo(({
  node
}) => {
  const values = node.values.map(it => jsx(StaticNodeWithMemo, {
    node: it[1]
  }, it[1].id));
  const children = node.type === NodeType.Internal ? node.children.map((child, index) => {
    const key = index < node.selfSize ? node.getKey(index) : "last";
    return jsx(ReadonlyNodeTreeNode, {
      node: child
    }, key);
  }) : undefined;
  return jsxs(Fragment, {
    children: [values, children]
  });
});
ReadonlyNodeTreeNode.displayName = "ReadonlyNodeTreeNode";
const ReadonlyNodeTree = ({
  tree
}) => {
  return jsx(ReadonlyNodeTreeNode, {
    node: tree.sortedRoot
  });
};

const StaticGraph = props => {
  const {
    nodes
  } = props.data;
  const style = Object.assign({
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    width: "100%"
  }, props.style);
  return jsx("svg", Object.assign({
    style: style
  }, {
    children: jsx(Transform, Object.assign({
      matrix: props.transformMatrix
    }, {
      children: jsx(ReadonlyNodeTree, {
        tree: nodes
      })
    }))
  }));
};

const MiniMapShadow = ({
  containerRect: rect,
  viewport,
  shadowPadding: _shadowPadding = 0,
  onClick
}) => {
  if (!rect) {
    return null;
  }

  const shadowStyle = {
    fill: defaultColors.minimapShadow,
    opacity: 0.1
  };
  const lineStyle = {
    stroke: defaultColors.inputFocusBorderAlt,
    strokeWidth: 1
  };
  const viewportStartX = Math.max(viewport.startX, _shadowPadding);
  const viewportStartY = Math.max(viewport.startY, _shadowPadding);
  const viewportEndX = Math.min(viewport.endX, rect.width - _shadowPadding);
  const viewportEndY = Math.min(viewport.endY, rect.height - _shadowPadding);
  const sideShadowHeight = viewportEndY - viewportStartY;
  const rightShadowWidth = rect.width - viewportEndX;
  const bottomShadowHeight = rect.height - viewportEndY;
  return jsxs(Fragment, {
    children: [viewportStartY > 0 && jsxs("g", {
      children: [jsx("rect", {
        onClick: onClick,
        onMouseDown: stopPropagation,
        onPointerDown: stopPropagation,
        x: 0,
        y: 0,
        height: viewportStartY,
        width: rect.width,
        style: shadowStyle
      }), jsx("line", {
        x1: viewportStartX,
        y1: viewportStartY,
        x2: viewportEndX,
        y2: viewportStartY,
        style: lineStyle
      })]
    }), viewportStartX && sideShadowHeight > 0 && jsxs("g", {
      children: [jsx("rect", {
        onClick: onClick,
        onMouseDown: stopPropagation,
        onPointerDown: stopPropagation,
        x: 0,
        y: viewportStartY,
        height: sideShadowHeight,
        width: viewportStartX,
        style: shadowStyle
      }), jsx("line", {
        x1: viewportStartX,
        y1: viewportStartY,
        x2: viewportStartX,
        y2: viewportEndY,
        style: lineStyle
      })]
    }), rightShadowWidth && sideShadowHeight > 0 && jsxs("g", {
      children: [jsx("rect", {
        onClick: onClick,
        onMouseDown: stopPropagation,
        onPointerDown: stopPropagation,
        x: viewportEndX,
        y: viewportStartY,
        height: sideShadowHeight,
        width: rightShadowWidth,
        style: shadowStyle
      }), jsx("line", {
        x1: viewportEndX,
        y1: viewportStartY,
        x2: viewportEndX,
        y2: viewportEndY,
        style: lineStyle
      })]
    }), bottomShadowHeight > 0 && jsxs("g", {
      children: [jsx("rect", {
        onClick: onClick,
        onMouseDown: stopPropagation,
        onPointerDown: stopPropagation,
        x: 0,
        y: viewportEndY,
        height: bottomShadowHeight,
        width: rect.width,
        style: shadowStyle
      }), jsx("line", {
        x1: viewportStartX,
        y1: viewportEndY,
        x2: viewportEndX,
        y2: viewportEndY,
        style: lineStyle
      })]
    })]
  });
};

const Minimap = props => {
  const {
    shadowPadding = 0,
    maxNodesCountAllowed = 150,
    onRenderUnavailable = () => null,
    renderArrow = () => undefined
  } = props;
  const graphViewport = useViewport();
  const graphController = useGraphController();
  const data = useGraphData();
  const minimapContainerStyle = Object.assign({
    background: defaultColors.minimapBackground
  }, props.style);
  const svgRef = React.useRef(null);
  const graphConfig = useGraphConfig();
  const rect = useMinimapRect(svgRef);
  const rectRef = useRefValue(rect);
  const minimapTransformMatrix = React.useMemo(() => {
    if (!rect) {
      return EMPTY_TRANSFORM_MATRIX;
    }

    return getZoomFitMatrix({
      data,
      rect,
      graphConfig,
      nodeMaxVisibleSize: {
        width: 0,
        height: 0
      },
      nodeMinVisibleSize: {
        width: Infinity,
        height: Infinity
      }
    }); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [rect, data.nodes]);
  const minimapTransformMatrixRef = useRefValue(minimapTransformMatrix);
  const viewport = React.useMemo(() => {
    if (!rect || !isViewportComplete(graphViewport)) {
      return {
        startX: 0,
        startY: 0,
        endX: 0,
        endY: 0
      };
    }

    const boundaryPoints = getVisibleArea(graphViewport);
    const {
      x: startX,
      y: startY
    } = transformPoint(boundaryPoints.minX, boundaryPoints.minY, minimapTransformMatrix);
    const {
      x: endX,
      y: endY
    } = transformPoint(boundaryPoints.maxX, boundaryPoints.maxY, minimapTransformMatrix);
    return {
      startX,
      startY,
      endX,
      endY
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [rect, minimapTransformMatrix, graphViewport.rect, ...graphViewport.transformMatrix]);
  const onClick = React.useCallback(evt => {
    evt.stopPropagation();

    if (!rect) {
      return;
    }

    const viewportWidth = viewport.endX - viewport.startX;
    const viewportHeight = viewport.endY - viewport.startY;
    const point = reverseTransformPoint(clamp(shadowPadding + viewportWidth / 2, rect.width - shadowPadding - viewportWidth / 2, evt.clientX - rect.left), clamp(shadowPadding + viewportHeight / 2, rect.height - shadowPadding - viewportHeight / 2, evt.clientY - rect.top), minimapTransformMatrix);
    graphController.eventChannel.batch([{
      type: GraphCanvasEvent.ScrollIntoView,
      x: point.x,
      y: point.y
    }, {
      type: GraphMinimapEvent.Click,
      rawEvent: evt
    }]);
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [rect]);
  const onStartDrag = React.useCallback((evt, eventProvider) => {
    if (!rectRef.current) {
      return;
    }

    const {
      left,
      top,
      right,
      bottom
    } = rectRef.current;
    const validMouseRect = {
      startX: left + shadowPadding,
      startY: top + shadowPadding,
      endX: right - shadowPadding,
      endY: bottom - shadowPadding
    };
    graphController.eventChannel.trigger({
      type: GraphMinimapEvent.PanStart,
      rawEvent: evt
    });
    const drag = new DragController(eventProvider, e => {
      const x = clamp(validMouseRect.startX, validMouseRect.endX, e.clientX);
      const y = clamp(validMouseRect.startY, validMouseRect.endY, e.clientY);
      return {
        x,
        y
      };
    });

    drag.onMove = ({
      dx,
      dy,
      e
    }) => {
      const {
        x,
        y
      } = getPointDeltaByClientDelta(-dx, -dy, minimapTransformMatrixRef.current);
      graphController.eventChannel.trigger({
        type: GraphMinimapEvent.Pan,
        dx: x,
        dy: y,
        rawEvent: e
      });
    };

    drag.start(evt);

    drag.onEnd = () => {
      graphController.eventChannel.trigger({
        type: GraphMinimapEvent.PanEnd,
        rawEvent: evt
      });
    };
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [shadowPadding]);
  const arrowParams = React.useMemo(() => {
    if (!rect) {
      return {
        showArrow: false,
        arrowDeg: 0
      };
    }

    const showArrow = viewport.startX > rect.width - shadowPadding || viewport.startY > rect.height - shadowPadding || viewport.endX < shadowPadding || viewport.endY < shadowPadding; // arrow rotate center

    const x0 = rect.width / 2;
    const y0 = rect.height / 2;
    const x1 = (viewport.startX + viewport.endX) / 2;
    const y1 = (viewport.startY + viewport.endY) / 2;
    let arrowDeg = Math.atan2(y1 - y0, x1 - x0) * 180 / Math.PI;

    if (arrowDeg < 0) {
      arrowDeg = arrowDeg + 360;
    }

    return {
      showArrow,
      arrowDeg
    };
  }, [rect, viewport, shadowPadding]);
  const onMouseDown = React.useCallback(evt => {
    onStartDrag(evt.nativeEvent, new MouseMoveEventProvider(graphController.getGlobalEventTarget()));
  }, // eslint-disable-next-line react-hooks/exhaustive-deps
  [onStartDrag]);
  const touchController = React.useMemo(() => {
    const handlers = new Map();
    const touchDragAdapter = new TouchDragAdapter();
    touchDragAdapter.on("start", e => {
      onStartDrag(e, touchDragAdapter);
    });
    handlers.set(1, touchDragAdapter);
    return new TouchController(handlers); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [onStartDrag, rect]);
  const staticGraphEl = React.useMemo(() => jsx(StaticGraph, {
    data: data,
    transformMatrix: minimapTransformMatrix
  }), // eslint-disable-next-line react-hooks/exhaustive-deps
  [data.nodes, ...minimapTransformMatrix]);

  if (data.nodes.size > maxNodesCountAllowed) {
    return jsx("div", Object.assign({
      className: "minimap-container",
      style: minimapContainerStyle
    }, {
      children: onRenderUnavailable()
    }));
  }

  return jsxs("div", Object.assign({
    className: `minimap-container ${styles.minimap}`,
    style: minimapContainerStyle
  }, {
    children: [staticGraphEl, jsx("svg", Object.assign({
      className: styles.minimapSvg
    }, touchController.eventHandlers, {
      onMouseDown: onMouseDown,
      ref: svgRef,
      "data-automation-id": "minimap-id"
    }, {
      children: jsx(MiniMapShadow, {
        containerRect: rect,
        viewport: viewport,
        shadowPadding: shadowPadding,
        onClick: onClick
      })
    })), arrowParams.showArrow && renderArrow(arrowParams.arrowDeg)]
  }));
};

const ContextMenu = props => {
  const classes = mergeStyleSets({
    contextMenu: {
      fontSize: 14,
      background: defaultColors.contextMenuBackground,
      color: defaultColors.fontColor,
      border: `1px solid ${defaultColors.contextMenuBorder}`,
      width: 193,
      lineHeight: "20px",
      cursor: "default",
      "> *": {
        padding: 8,
        ":hover": {
          background: defaultColors.contextMenuHoverBackground
        }
      }
    }
  });
  const propsMerged = Object.assign(Object.assign({}, props), {
    className: `${classes.contextMenu} ${props.className}`
  });
  const contextMenuConfig = useContextMenuConfigContext();
  contextMenuConfig.registerContextMenu(propsMerged);
  return jsx("div", {
    children: props.children
  });
};

const NodeMenu = props => {
  const contextMenuConfig = useContextMenuConfigContext();
  contextMenuConfig.registerMenu(props.children, MenuType.Node);
  return null;
};

const EdgeMenu = props => {
  const contextMenuConfig = useContextMenuConfigContext();
  contextMenuConfig.registerMenu(props.children, MenuType.Edge);
  return null;
};

const PortMenu = props => {
  const contextMenuConfig = useContextMenuConfigContext();
  contextMenuConfig.registerMenu(props.children, MenuType.Port);
  return null;
};

const CanvasMenu = props => {
  const contextMenuConfig = useContextMenuConfigContext();
  contextMenuConfig.registerMenu(props.children, MenuType.Canvas);
  return null;
};

const MultiMenu = props => {
  const contextMenuConfig = useContextMenuConfigContext();
  contextMenuConfig.registerMenu(props.children, MenuType.Multi);
  return null;
};

const GridBackground = ({
  smallGridAttributes,
  gridAttributes,
  backgroundAttributes,
  rect
}) => {
  const rectX = rect.minX;
  const rectY = rect.minY;
  const width = rect.maxX - rect.minX;
  const height = rect.maxY - rect.minY;
  return jsxs(Fragment, {
    children: [jsxs("defs", {
      children: [jsx("pattern", Object.assign({
        id: "smallGrid",
        width: "8",
        height: "8",
        patternUnits: "userSpaceOnUse"
      }, {
        children: jsx("path", Object.assign({
          d: "M 8 0 L 0 0 0 8",
          fill: "none",
          stroke: "gray",
          strokeWidth: "0.5"
        }, smallGridAttributes))
      })), jsxs("pattern", Object.assign({
        id: "grid",
        width: "80",
        height: "80",
        patternUnits: "userSpaceOnUse"
      }, {
        children: [jsx("rect", {
          width: "80",
          height: "80",
          fill: "url(#smallGrid)"
        }), jsx("path", Object.assign({
          d: "M 80 0 L 0 0 0 80",
          fill: "none",
          stroke: "gray",
          strokeWidth: "1"
        }, gridAttributes))]
      }))]
    }), jsx("rect", Object.assign({
      x: rectX,
      y: rectY,
      width: width,
      height: height,
      fill: "url(#grid)"
    }, backgroundAttributes))]
  });
};

class TestAPI {
  constructor(adapter) {
    this.adapter = adapter;
  }

  getNodesCount() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.adapter.selectAll("g[data-automation-id*='node-container-']")).length;
    });
  }

  getEdgesCount() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.adapter.selectAll("g[data-automation-id*='edge-container-']")).length;
    });
  }

  addNodeFromItemPanel(options) {
    return __awaiter(this, void 0, void 0, function* () {
      const addColumnsModuleInPanelElPos = yield this.getCentralPosBySelector(options.itemSelector);
      yield this.adapter.mouseMove(addColumnsModuleInPanelElPos.x, addColumnsModuleInPanelElPos.y);
      yield this.adapter.mouseDown();
      const canvasBBOx = yield this.getCanvasBoundingBox();
      yield this.adapter.mouseMove(canvasBBOx.x + options.x, canvasBBOx.y + options.y);
      yield this.adapter.mouseUp();
    });
  }

  connectTwoNodes({
    sourceNodeName,
    sourcePortName,
    targetNodeName,
    targetPortName
  }) {
    return __awaiter(this, void 0, void 0, function* () {
      const sourcePos = yield this.getCentralPosBySelector(this.getPortCssSelector(sourceNodeName, sourcePortName));
      yield this.adapter.mouseMove(sourcePos.x, sourcePos.y);
      yield this.adapter.mouseDown();
      const targetPos = yield this.getCentralPosBySelector(this.getPortCssSelector(targetNodeName, targetPortName));
      yield this.adapter.mouseMove(targetPos.x, targetPos.y);
      yield this.adapter.mouseUp();
    });
  }

  draggingNode(nodeName, toPosition) {
    return __awaiter(this, void 0, void 0, function* () {
      const nodeCenterPos = yield this.getCentralPosBySelector(this.getNodeCssSelector(nodeName));
      yield this.adapter.mouseMove(nodeCenterPos.x, nodeCenterPos.y);
      yield this.adapter.mouseDown();
      const canvasBBOx = yield this.getCanvasBoundingBox();
      yield this.adapter.mouseMove(toPosition.x + canvasBBOx.x, toPosition.y + canvasBBOx.y);
    });
  }

  rightClickOnNode(nodeName) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.adapter.rightClick(this.getNodeCssSelector(nodeName));
    });
  }

  clickOnNode(nodeName) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.adapter.click(this.getNodeCssSelector(nodeName));
    });
  }

  hoverOnNode(nodeName) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.adapter.hover(this.getNodeCssSelector(nodeName));
    });
  }

  hoverOnPort(nodeName, portName) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.adapter.hover(this.getPortCssSelector(nodeName, portName));
    });
  }

  hoverOnEdge(edgeId) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.adapter.hover(this.getEdgeCssSelector(edgeId));
    });
  }

  getAutoAlignHintLineCount() {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield this.adapter.selectAll("line.auto-align-hint")).length;
    });
  }
  /**
   * select node(s) with ctrl key
   *
   * @param nodeNames node names to be selected
   */


  clickOnNodesWithCtrlKey(nodeNames) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.adapter.keyDown("Control");

      for (const name of nodeNames) {
        yield this.clickOnNode(name);
      }

      yield this.adapter.keyUp("Control");
    });
  }

  rightClickOnCanvas(x, y) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.adapter.rightClick("svg.react-dag-editor-svg-container", {
        position: {
          x,
          y
        }
      });
    });
  }

  selectArea(start, end) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.adapter.mouseMove(start.x, start.y);
      yield this.adapter.mouseDown();
      yield this.adapter.mouseMove(end.x, end.y);
      yield this.adapter.mouseUp();
    });
  }

  connectWithKeyboard(isCancelConnect = false) {
    return __awaiter(this, void 0, void 0, function* () {
      // focus to a port
      yield this.focusOnCanvasWithKeyboard();
      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("Tab"); // enter connect mode

      yield this.adapter.keyDown("Alt");
      yield this.adapter.keyPress("c");
      yield this.adapter.keyUp("Alt"); // focus to another port

      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("Tab"); // finish connect or cancel connect

      if (isCancelConnect) {
        yield this.adapter.keyPress("Escape");
      } else {
        yield this.adapter.keyPress("Enter");
      }
    });
  }

  navigateAroundNodesWithKeyboard() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.focusOnCanvasWithKeyboard();
      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("ArrowDown");
      yield this.adapter.keyPress("ArrowDown");
      yield this.adapter.keyPress("ArrowRight");
      yield this.adapter.keyPress("ArrowLeft");
    });
  }

  navigateBackWithKeyboard() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.focusOnCanvasWithKeyboard();
      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("Tab"); // pressing shift key to navigate back

      yield this.adapter.keyDown("Shift");
      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyUp("Shift");
    });
  }

  navigateAroundPortsWithKeyboard() {
    return __awaiter(this, void 0, void 0, function* () {
      // focus on canvas
      yield this.focusOnCanvasWithKeyboard(); // navigate to a node

      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("ArrowDown"); // navigate to a port

      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("ArrowDown");
      yield this.adapter.keyPress("ArrowDown");
    });
  }

  goToConnectedPortWithKeyboard() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.focusOnCanvasWithKeyboard(); // navigate to a node

      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("ArrowDown"); // navigate to a port

      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("Tab"); // go to connected port

      yield this.adapter.keyDown("Alt");
      yield this.adapter.keyPress("g");
      yield this.adapter.keyUp("Alt");
    });
  }

  deleteNodeWithKeyboard() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.focusOnCanvasWithKeyboard();
      yield this.adapter.keyPress("Tab");
      yield this.adapter.keyPress("ArrowDown");
      yield this.adapter.keyPress("Delete");
    });
  }

  panCanvas(from, to) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.adapter.mouseMove(from.x, from.y);
      yield this.adapter.mouseDown();
      yield this.adapter.mouseMove(to.x, to.y);
      yield this.adapter.mouseUp();
    });
  }

  getElementBoundingBox(cssSelector) {
    return __awaiter(this, void 0, void 0, function* () {
      const el = yield this.adapter.waitForSelector(cssSelector);
      const {
        x = 0,
        y = 0,
        height = 0,
        width = 0
      } = (yield el.boundingBox()) || {};
      return {
        x,
        y,
        width,
        height
      };
    });
  }

  getCanvasBoundingBox() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.getElementBoundingBox("svg.react-dag-editor-svg-container");
    });
  }

  getMinimapBoundingBox() {
    return __awaiter(this, void 0, void 0, function* () {
      const {
        x,
        y,
        height,
        width
      } = yield this.getElementBoundingBox("svg[data-automation-id*='minimap-id']");
      return {
        x,
        y,
        width,
        height
      };
    });
  }

  dragOnItem(start, end) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.selectArea(start, end);
    });
  }

  getNodeCentralPosition(nodeName) {
    return __awaiter(this, void 0, void 0, function* () {
      const pos = yield this.getCentralPosBySelector(this.getNodeCssSelector(nodeName));
      return pos;
    });
  }

  getNodes() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.getDomElements("g[data-automation-id*='node-container-']");
    });
  }

  getEdges() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.getDomElements("g[data-automation-id*='edge-container-']");
    });
  }

  getPorts() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.getDomElements("g[aria-roledescription='port']");
    });
  }

  getNodeTooltips() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.getDomElements(".node-tooltips");
    });
  }

  getPortTooltips() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.getDomElements(".port-tooltips");
    });
  }

  composeGraph() {
    return __awaiter(this, void 0, void 0, function* () {
      const nodes = yield this.getNodes();
      const edges = yield this.getEdges();
      const ports = yield this.getPorts();
      const nodeTooltips = yield this.getNodeTooltips();
      const portTooltips = yield this.getPortTooltips();
      return {
        nodes,
        edges,
        ports,
        nodeTooltips,
        portTooltips
      };
    });
  }

  getCentralPosBySelector(cssSelector) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.getCentralPosByBBox(yield this.getElementBoundingBox(cssSelector));
    });
  }

  getDomElements(selector) {
    var _a;

    return __awaiter(this, void 0, void 0, function* () {
      return Promise.all((_a = yield this.adapter.selectAll(selector)) === null || _a === void 0 ? void 0 : _a.map(handle => __awaiter(this, void 0, void 0, function* () {
        const bbox = yield handle.boundingBox();
        const className = yield handle.getAttribute("class");
        const innerHTML = yield handle.innerHTML();
        const textContent = yield handle.textContent();
        const ariaLabel = yield handle.getAttribute("aria-label");
        const automationId = yield handle.getAttribute("data-automation-id");
        return {
          bbox,
          textContent,
          className,
          innerHTML,
          ariaLabel,
          automationId
        };
      })));
    });
  }

  getCentralPosByBBox(bbox) {
    if (!bbox) {
      return {
        x: 0,
        y: 0
      };
    }

    return {
      x: bbox.width / 2 + bbox.x,
      y: bbox.height / 2 + bbox.y
    };
  }

  getPortCssSelector(nodeName, portName) {
    return `g[data-automation-id*='${nodeName}'][data-automation-id*='${portName}'][data-automation-id*='port-']`;
  }

  getNodeCssSelector(nodeName) {
    return `g[data-automation-id*='node-container-'][data-automation-id*='${nodeName}']`;
  }

  getEdgeCssSelector(edgeId) {
    return `g[data-automation-id*='edge-container-${edgeId}']`;
  }

  focusOnCanvasWithKeyboard() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.adapter.keyDown("Alt");
      yield this.adapter.keyDown("Shift");
      yield this.adapter.keyPress("f");
      yield this.adapter.keyUp("Alt");
      yield this.adapter.keyUp("Shift");
    });
  }

}

export { ACTIVATED_STATUS, bitset as Bitset, BrowserType, CanvasMenu, CanvasMouseMode, ContextMenu, ContextMenuConfig, ContextMenuConfigContext, DEFAULT_GRAPH_SETTINGS, DEFAULT_NODE_MAX_VISIBLE_SIZE, DEFAULT_NODE_MIN_VISIBLE_SIZE, Debug, DefaultClipboard, DefaultStorage, Direction, EMPTY_CONNECT_STATE, EMPTY_GAP, EMPTY_GRAPH_STATE, EMPTY_STATUS, EMPTY_TRANSFORM_MATRIX, EMPTY_VIEW_PORT, EdgeMenu, EdgeModel, GanttChartFeatures, Graph, GraphBehavior, GraphCanvasEvent, GraphConfigBuilder, GraphConfigContext, GraphContextMenuEvent, GraphEdgeEvent, GraphEdgeStatus, GraphFeatures, GraphMinimapEvent, GraphModel, GraphNodeAnchors, GraphNodeEvent, GraphNodeStatus, GraphPortEvent, GraphPortStatus, GraphScrollBarEvent, GraphStateContext, GraphValueContext, GridBackground, Item, LinearEquation, MenuType, Minimap, MultiMenu, NodeAnchor, NodeMenu, NodeModel, PortMenu, RESIZE_POINT_HEIGHT, RESIZE_POINT_WIDTH, ReactDagEditor, SELECTED_STATUS, StaticGraph, TestAPI, ViewportContext, allFeatures, applyDefaultPortsPosition, applyHorizontalGraphPortsPosition, arrayEquals, canRedo, canUndo, checkRectIntersect, clamp, composeReducers, constantEmptyArray, createGraphState, dataReadonlyMode, debounce, defaultFeatures, defaultGetPositionFromEvent, defaultGraphStateContext, defaultPort, diffGraphEdge, diffGraphNode, diffGraphPort, distance, filterSelectedItems, focusArea, getBrowser, getClientDeltaByPointDelta, getClientPointFromRealPoint, getContainer, getContainerCenter, getContainerClientPoint, getContentArea$1 as getContentArea, getCriticalPath, getCurvePathD, getEdgeSourceTargetCoordinate, getEdgeUid, getGraphReducer, getGroupRect, getLinearFunction, getMinimapRect, getNearestConnectablePort, getNeighborPorts, getNodeAutomationId, getNodeConfig, getNodeRect, getNodeSize, getNodeUid, getOffsetLimit, getPointDeltaByClientDelta, getPortAutomationId, getPortPosition, getPortPositionByPortId, getPortUid, getRealPointFromClientPoint, getRectHeight, getRectWidth, getRelativePoint, getRenderedArea, getRenderedEdges, getRenderedNodes, getScaleLimit, getScaleRange, getTopoSortingNodes, getVisibleArea, getVisibleNodes, getZoomFitMatrix, isActivated, isCanvasEvent, isConnectable, isEdgeEvent, isMacOs, isMobile, isNodeEditing, isNodeEvent, isNodeVisible, isPointInRect, isPointVisible, isPortEvent, isRectVisible, isSelected, isSupported, isViewportComplete, isViewportEmpty, isWithinRect, isWithinThreshold, line, markCriticalPath, markEdgeDirty, memoize, minimapPan, nodeSelection, notSelected, pan, previewMode, pushHistory, rect, redo, resetConnectStatus, resetNodePortsState, resetUndoStack, resolveValueOrCallback, reverseTransformPoint, scrollIntoView, setData, stopPropagation, transformPoint, unSelectAllEntity, undo, updateData, updateStatus, useAlignmentLines, useBackgroundRect, useConnectingState, useContainerRect, useContextMenuConfigContext, useDeferredValue, useGetMouseDownOnAnchor, useGraphConfig, useGraphController, useGraphData, useGraphReducer, useGraphState, useGraphTouchHandler, useMinimapRect, useRenderedArea, useSafariScale, useSelectBox, useThrottle, useUpdateViewportCallback, useViewport, useVirtualization, useWheelHandler, zoom, zoomTo };
