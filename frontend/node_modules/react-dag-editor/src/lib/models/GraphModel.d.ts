import { HashMap, OrderedMap } from "../collections";
import { ICanvasData, ICanvasGroup } from "./canvas";
import { ICanvasEdge } from "./edge";
import { EdgeModel } from "./EdgeModel";
import { ICanvasNode } from "./node";
import { NodeModel } from "./NodeModel";
import { ICanvasPort } from "./port";
export interface IDeleteItemPredicates<NodeData = unknown, EdgeData = unknown, PortData = unknown> {
    node?(node: ICanvasNode<NodeData, PortData>): boolean;
    edge?(edge: ICanvasEdge<EdgeData>): boolean;
}
type EdgesByPort = HashMap<string, ReadonlyMap<string, ReadonlySet<string>>>;
/**
 * @internal
 */
export interface INodeGeometryDelta {
    dx: number;
    dy: number;
    dWidth: number;
    dHeight: number;
}
interface IGraphModel<NodeData = unknown, EdgeData = unknown, PortData = unknown> {
    readonly nodes: OrderedMap<string, NodeModel<NodeData, PortData>>;
    readonly edges: HashMap<string, EdgeModel<EdgeData>>;
    readonly groups: ICanvasGroup[];
    readonly head: string | undefined;
    readonly tail: string | undefined;
    readonly edgesBySource: EdgesByPort;
    readonly edgesByTarget: EdgesByPort;
    readonly selectedNodes: ReadonlySet<string>;
}
/**
 * Things preferred to be implemented as methods here:
 * * widely shared functions, eg. `updateNode`
 * * including multiple operations that must happen atomically
 * * improve performance by internal mutability
 */
export declare class GraphModel<NodeData = unknown, EdgeData = unknown, PortData = unknown> implements IGraphModel<NodeData, EdgeData, PortData> {
    readonly nodes: OrderedMap<string, NodeModel<NodeData, PortData>>;
    readonly edges: HashMap<string, EdgeModel<EdgeData>>;
    readonly groups: ICanvasGroup[];
    readonly head: string | undefined;
    readonly tail: string | undefined;
    readonly edgesBySource: EdgesByPort;
    readonly edgesByTarget: EdgesByPort;
    readonly selectedNodes: ReadonlySet<string>;
    private constructor();
    static empty<N, E, P>(): GraphModel<N, E, P>;
    static fromJSON<N, E, P>(init: ICanvasData<N, E, P>): GraphModel<N, E, P>;
    getNavigationFirstNode(): NodeModel<NodeData, PortData> | undefined;
    updateNode(id: string, f: (node: ICanvasNode<NodeData, PortData>) => ICanvasNode<NodeData, PortData>): GraphModel<NodeData, EdgeData, PortData>;
    updateNodeData(id: string, f: (data: NodeData) => NodeData): GraphModel<NodeData, EdgeData, PortData>;
    updatePort(nodeId: string, portId: string, f: (port: ICanvasPort<PortData>) => ICanvasPort<PortData>): GraphModel<NodeData, EdgeData, PortData>;
    insertNode(node: ICanvasNode<NodeData, PortData>): GraphModel<NodeData, EdgeData, PortData>;
    deleteItems(predicate: IDeleteItemPredicates<NodeData, EdgeData, PortData>): GraphModel<NodeData, EdgeData, PortData>;
    insertEdge(edge: ICanvasEdge<EdgeData>): GraphModel<NodeData, EdgeData, PortData>;
    updateEdge(id: string, f: (edge: ICanvasEdge<EdgeData>) => ICanvasEdge<EdgeData>): GraphModel<NodeData, EdgeData, PortData>;
    deleteEdge(id: string): GraphModel<NodeData, EdgeData, PortData>;
    /**
     * @internal
     */
    updateNodesPositionAndSize(dummies: readonly ICanvasNode[]): GraphModel<NodeData, EdgeData, PortData>;
    mapNodes(f: (node: NodeModel<NodeData, PortData>) => NodeModel<NodeData, PortData>): GraphModel<NodeData, EdgeData, PortData>;
    mapEdges(f: (node: EdgeModel<EdgeData>) => EdgeModel<EdgeData>): GraphModel<NodeData, EdgeData, PortData>;
    selectNodes(predicate: (node: ICanvasNode<NodeData, PortData>) => boolean, topNode?: string): GraphModel<NodeData, EdgeData, PortData>;
    getEdgesBySource(nodeId: string, portId: string): ReadonlySet<string> | undefined;
    getEdgesByTarget(nodeId: string, portId: string): ReadonlySet<string> | undefined;
    isPortConnectedAsSource(nodeId: string, portId: string): boolean;
    isPortConnectedAsTarget(nodeId: string, portId: string): boolean;
    shallow(): GraphModel<NodeData, EdgeData, PortData>;
    toJSON(): ICanvasData<NodeData, EdgeData, PortData>;
    isEdgeExist(source: string, sourcePortId: string, target: string, targetPortId: string): boolean;
    private merge;
}
export {};
