import { IDispatch } from "../contexts";
import { GraphFeatures } from "../Features";
import { IPoint } from "../models/geometry";
import { GraphModel } from "../models/GraphModel";
import { NodeModel } from "../models/NodeModel";
import { GraphBehavior, IGraphState } from "../models/state";
import { EventChannel } from "../utils/eventChannel";
/**
 * event handlers must get/set GraphBehavior immediately
 * to determine how to treat event objects (eg. preventDefault)
 * but dispatch/setState can be asynchronous
 * thus GraphBehavior is mirrored here
 */
export declare class GraphController {
    /**
     * since we don't have a detailed specification for touch handling
     * temporarily store the pointerId here for most single point events
     */
    pointerId: number | null;
    /**
     * simulate canvas click event once
     */
    canvasClickOnce: boolean;
    nodeClickOnce: NodeModel | null;
    readonly eventChannel: EventChannel;
    state: IGraphState;
    UNSAFE_latestState: IGraphState;
    dispatchDelegate: IDispatch;
    getGlobalEventTargetDelegate?: () => Window | HTMLElement | null | undefined;
    private mouseClientPoint?;
    private behavior;
    constructor(state: IGraphState, dispatch: IDispatch);
    readonly dispatch: IDispatch;
    setMouseClientPosition(pos: IPoint): void;
    unsetMouseClientPosition(): void;
    getMouseClientPosition(): IPoint | undefined;
    getEnabledFeatures(): ReadonlySet<GraphFeatures>;
    getBehavior(): GraphBehavior;
    setBehavior(value: GraphBehavior): void;
    getData(): GraphModel;
    getGlobalEventTarget(): HTMLElement | Window;
}
