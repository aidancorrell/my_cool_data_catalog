/**
 * Compressed Hash-Array Mapped Prefix-tree
 * This file contains a CHAMP implementation from scala's stdlib with modifications
 * CHAMP is an optimized HAMT
 * See paper https://michael.steindorfer.name/publications/oopsla15.pdf for more details.
 */
import { Owner } from "./common";
export declare enum NodeType {
    Bitmap = 0,
    Collision = 1
}
interface INodeBase<K, V, Type extends NodeType = NodeType> {
    type: Type;
    size: number;
    getKey(index: number): K;
    getValue(index: number): V;
    getHash(index: number): number;
    get(key: K, hash: number, shift: number): V | undefined;
    contains(key: K, hash: number, shift: number): boolean;
    insert(owner: Owner, key: K, value: V, keyHash: number, shift: number): INode<K, V>;
    update(owner: Owner, key: K, updater: (prev: V) => V, keyHash: number, shift: number): INode<K, V>;
    remove(owner: Owner, key: K, hash: number, shift: number): [INode<K, V>, V] | undefined;
    iter(): IterableIterator<[K, V]>;
    map<T>(owner: Owner, f: (value: V, key: K) => T): INode<K, T>;
    forEach(f: (value: V, key: K) => void): void;
    find(predicate: (value: V) => boolean): V | undefined;
}
type INode<K, V> = BitmapIndexedNode<K, V> | HashCollisionNode<K, V>;
/**
 * @param mask
 */
export declare function bitPosFrom(mask: number): number;
/**
 * @param bitmap
 * @param mask
 * @param bitPos
 */
export declare function indexFrom(bitmap: number, mask: number, bitPos: number): number;
/**
 * @param hash
 * @param shift
 */
export declare function maskFrom(hash: number, shift: number): number;
/**
 * https://jsperf.com/hamming-weight/19
 *
 * @param x uint32
 */
export declare function bitCount(x: number): number;
export declare class BitmapIndexedNode<K, V> implements INodeBase<K, V, NodeType.Bitmap> {
    readonly type = NodeType.Bitmap;
    dataMap: number;
    nodeMap: number;
    size: number;
    private readonly keys;
    private readonly values;
    private readonly children;
    private readonly owner;
    private readonly hashes;
    get valueCount(): number;
    get nodeCount(): number;
    constructor(owner: Owner, dataMap: number, nodeMap: number, keys: K[], values: V[], children: Array<INode<K, V>>, hashes: number[], size: number);
    static empty<TK, TV>(owner: Owner): BitmapIndexedNode<TK, TV>;
    getKey(index: number): K;
    getValue(index: number): V;
    getHash(index: number): number;
    getNode(index: number): INode<K, V>;
    contains(key: K, keyHash: number, shift: number): boolean;
    get(key: K, keyHash: number, shift: number): V | undefined;
    insert(owner: Owner, key: K, value: V, hash: number, shift: number): BitmapIndexedNode<K, V>;
    update(owner: Owner, key: K, updater: (prev: V) => V, hash: number, shift: number): BitmapIndexedNode<K, V>;
    remove(owner: Owner, key: K, keyHash: number, shift: number): [BitmapIndexedNode<K, V>, V] | undefined;
    toOwned(owner: Owner): BitmapIndexedNode<K, V>;
    iter(): IterableIterator<[K, V]>;
    map<T>(owner: Owner, f: (value: V, key: K) => T): BitmapIndexedNode<K, T>;
    forEach(f: (value: V, key: K) => void): void;
    find(predicate: (value: V) => boolean): V | undefined;
    private dataIndex;
    private nodeIndex;
    private setValue;
    private insertValue;
    private migrateInlineToNode;
    private migrateNodeToInline;
    private setNode;
    private removeValue;
}
export declare class HashCollisionNode<K, V> implements INodeBase<K, V, NodeType.Collision> {
    readonly type = NodeType.Collision;
    readonly owner: Owner;
    hash: number;
    keys: K[];
    values: V[];
    get size(): number;
    constructor(owner: Owner, hash: number, keys: K[], values: V[]);
    toOwned(owner: Owner): HashCollisionNode<K, V>;
    contains(key: K): boolean;
    get(key: K): V | undefined;
    insert(owner: Owner, key: K, value: V): INode<K, V>;
    update(owner: Owner, key: K, updater: (prev: V) => V): INode<K, V>;
    remove(owner: Owner, key: K): [HashCollisionNode<K, V>, V] | undefined;
    getKey(index: number): K;
    getValue(index: number): V;
    getHash(): number;
    iter(): IterableIterator<[K, V]>;
    map<T>(owner: Owner, f: (value: V, key: K) => T): HashCollisionNode<K, T>;
    forEach(f: (value: V, key: K) => void): void;
    find(predicate: (value: V) => boolean): V | undefined;
}
export declare class BitmapIndexedNodeIterator<K, V> implements IterableIterator<[K, V]> {
    private readonly valueCount;
    private readonly nodeCount;
    private readonly size;
    private index;
    private delegate;
    private done;
    private readonly node;
    constructor(node: BitmapIndexedNode<K, V>);
    [Symbol.iterator](): IterableIterator<[K, V]>;
    next(): IteratorResult<[K, V], undefined>;
    clone(): BitmapIndexedNodeIterator<K, V>;
}
export declare class HashCollisionNodeIterator<K, V> implements IterableIterator<[K, V]> {
    private index;
    private readonly node;
    constructor(node: HashCollisionNode<K, V>);
    [Symbol.iterator](): IterableIterator<[K, V]>;
    next(): IteratorResult<[K, V], undefined>;
    clone(): HashCollisionNodeIterator<K, V>;
}
export {};
