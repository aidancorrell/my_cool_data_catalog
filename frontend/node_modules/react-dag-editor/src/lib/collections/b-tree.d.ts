import { Owner } from "./common";
export declare enum NodeType {
    Internal = 0,
    Leaf = 1
}
type Insert<K, V> = [INode<K, V>] | [INode<K, V>, INode<K, V>, K, V];
interface INodeBase<K, V, T extends NodeType = NodeType> {
    type: T;
    size: number;
    selfSize: number;
    keys: K[];
    values: V[];
    getKey(index: number): K;
    getValue(index: number): V;
    get(key: K): V | undefined;
    contains(key: K): boolean;
    insert(owner: Owner, key: K, value: V): Insert<K, V>;
    update(owner: Owner, key: K, updater: (prev: V) => V): INode<K, V>;
    remove(owner: Owner, key: K): INode<K, V>;
    removeMostRight(owner: Owner): [K, V, INode<K, V>];
    map<U>(owner: Owner, f: (value: V, key: K) => U): INode<K, U>;
    toOwned(owner: Owner): INode<K, V>;
    forEach(f: (value: V, key: K) => void): void;
    find(predicate: (value: V) => boolean): V | undefined;
}
export type INode<K, V> = InternalNode<K, V> | LeafNode<K, V>;
/**
 * @param list
 * @param key
 */
export declare function binaryFind<T>(list: T[], key: T): number;
export declare class InternalNode<K, V> implements INodeBase<K, V, NodeType.Internal> {
    readonly type = NodeType.Internal;
    keys: K[];
    values: V[];
    size: number;
    readonly children: Array<INode<K, V>>;
    get selfSize(): number;
    private readonly owner;
    constructor(owner: Owner, keys: K[], values: V[], children: Array<INode<K, V>>, size: number);
    iter(): Iterator<[K, V]>;
    toOwned(owner: Owner): InternalNode<K, V>;
    getKey(index: number): K;
    getValue(index: number): V;
    getChild(index: number): INode<K, V>;
    get(key: K): V | undefined;
    contains(key: K): boolean;
    insert(owner: Owner, key: K, value: V): Insert<K, V>;
    update(owner: Owner, key: K, updater: (prev: V) => V): InternalNode<K, V>;
    remove(owner: Owner, key: K): INode<K, V>;
    removeMostRight(owner: Owner): [K, V, INode<K, V>];
    map<T>(owner: Owner, f: (value: V, key: K) => T): INode<K, T>;
    forEach(f: (value: V, key: K) => void): void;
    find(predicate: (value: V) => boolean): V | undefined;
    private balanceChild;
    private rotateLeft;
    private rotateRight;
    private balanceTail;
    private balanceHead;
    private updateWithSplit;
    private updateSize;
}
export declare class LeafNode<K, V> implements INodeBase<K, V, NodeType.Leaf> {
    readonly type = NodeType.Leaf;
    keys: K[];
    values: V[];
    private readonly owner;
    get size(): number;
    get selfSize(): number;
    constructor(owner: Owner, keys: K[], values: V[]);
    toOwned(owner: Owner): LeafNode<K, V>;
    getKey(index: number): K;
    getValue(index: number): V;
    get(key: K): V | undefined;
    contains(key: K): boolean;
    insert(owner: Owner, key: K, value: V): Insert<K, V>;
    update(owner: Owner, key: K, updater: (prev: V) => V): INode<K, V>;
    remove(owner: Owner, key: K): INode<K, V>;
    removeMostRight(owner: Owner): [K, V, INode<K, V>];
    map<T>(owner: Owner, f: (value: V, key: K) => T): INode<K, T>;
    forEach(f: (value: V, key: K) => void): void;
    find(predicate: (value: V) => boolean): V | undefined;
    private updateWithSplit;
    private removeIndex;
}
/**
 * @param owner
 */
export declare function emptyRoot<K, V>(owner: Owner): INode<K, V>;
/**
 * @param owner
 * @param root
 * @param key
 * @param value
 */
export declare function rootInsert<K, V>(owner: Owner, root: INode<K, V>, key: K, value: V): INode<K, V>;
/**
 * @param owner
 * @param root
 * @param key
 */
export declare function rootRemove<K, V>(owner: Owner, root: INode<K, V>, key: K): INode<K, V>;
export declare class BTreeIterator<K, V> implements IterableIterator<[K, V]> {
    private delegate;
    private index;
    private done;
    private readonly node;
    constructor(node: INode<K, V>);
    [Symbol.iterator](): IterableIterator<[K, V]>;
    next(): IteratorResult<[K, V], undefined>;
    clone(): BTreeIterator<K, V>;
    private setDelegate;
    private yieldValue;
}
export {};
