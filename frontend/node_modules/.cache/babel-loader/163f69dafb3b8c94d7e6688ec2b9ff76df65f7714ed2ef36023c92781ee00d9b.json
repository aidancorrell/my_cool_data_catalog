{"ast":null,"code":"/**\n * Topological sorting function\n *\n * @param {Array} edges\n * @returns {Array}\n */\n\nmodule.exports = function (edges) {\n  return toposort(uniqueNodes(edges), edges);\n};\nmodule.exports.array = toposort;\nfunction toposort(nodes, edges) {\n  var cursor = nodes.length,\n    sorted = new Array(cursor),\n    visited = {},\n    i = cursor;\n  while (i--) {\n    if (!visited[i]) visit(nodes[i], i, []);\n  }\n  return sorted;\n  function visit(node, i, predecessors) {\n    if (predecessors.indexOf(node) >= 0) {\n      var nodeRep;\n      try {\n        nodeRep = \", node was:\" + JSON.stringify(node);\n      } catch (e) {\n        nodeRep = \"\";\n      }\n      throw new Error('Cyclic dependency' + nodeRep);\n    }\n    if (!~nodes.indexOf(node)) {\n      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: ' + JSON.stringify(node));\n    }\n    if (visited[i]) return;\n    visited[i] = true;\n\n    // outgoing edges\n    var outgoing = edges.filter(function (edge) {\n      return edge[0] === node;\n    });\n    if (i = outgoing.length) {\n      var preds = predecessors.concat(node);\n      do {\n        var child = outgoing[--i][1];\n        visit(child, nodes.indexOf(child), preds);\n      } while (i);\n    }\n    sorted[--cursor] = node;\n  }\n}\nfunction uniqueNodes(arr) {\n  var res = [];\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i];\n    if (res.indexOf(edge[0]) < 0) res.push(edge[0]);\n    if (res.indexOf(edge[1]) < 0) res.push(edge[1]);\n  }\n  return res;\n}","map":{"version":3,"names":["module","exports","edges","toposort","uniqueNodes","array","nodes","cursor","length","sorted","Array","visited","i","visit","node","predecessors","indexOf","nodeRep","JSON","stringify","e","Error","outgoing","filter","edge","preds","concat","child","arr","res","len","push"],"sources":["/Users/aidancorrell/repos/data_catalog/frontend/node_modules/toposort/index.js"],"sourcesContent":["\n/**\n * Topological sorting function\n *\n * @param {Array} edges\n * @returns {Array}\n */\n\nmodule.exports = function(edges){\n  return toposort(uniqueNodes(edges), edges)\n}\n\nmodule.exports.array = toposort\n\nfunction toposort(nodes, edges) {\n  var cursor = nodes.length\n    , sorted = new Array(cursor)\n    , visited = {}\n    , i = cursor\n\n  while (i--) {\n    if (!visited[i]) visit(nodes[i], i, [])\n  }\n\n  return sorted\n\n  function visit(node, i, predecessors) {\n    if(predecessors.indexOf(node) >= 0) {\n      var nodeRep \n      try {\n        nodeRep = \", node was:\" + JSON.stringify(node)\n      } catch(e) {\n        nodeRep = \"\"\n      }\n      throw new Error('Cyclic dependency' + nodeRep)\n    }\n\n    if (!~nodes.indexOf(node)) {\n      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: '+JSON.stringify(node))\n    }\n\n    if (visited[i]) return;\n    visited[i] = true\n\n    // outgoing edges\n    var outgoing = edges.filter(function(edge){\n      return edge[0] === node\n    })\n    if (i = outgoing.length) {\n      var preds = predecessors.concat(node)\n      do {\n        var child = outgoing[--i][1]\n        visit(child, nodes.indexOf(child), preds)\n      } while (i)\n    }\n\n    sorted[--cursor] = node\n  }\n}\n\nfunction uniqueNodes(arr){\n  var res = []\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i]\n    if (res.indexOf(edge[0]) < 0) res.push(edge[0])\n    if (res.indexOf(edge[1]) < 0) res.push(edge[1])\n  }\n  return res\n}\n"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAO,GAAG,UAASC,KAAK,EAAC;EAC9B,OAAOC,QAAQ,CAACC,WAAW,CAACF,KAAK,CAAC,EAAEA,KAAK,CAAC;AAC5C,CAAC;AAEDF,MAAM,CAACC,OAAO,CAACI,KAAK,GAAGF,QAAQ;AAE/B,SAASA,QAAQA,CAACG,KAAK,EAAEJ,KAAK,EAAE;EAC9B,IAAIK,MAAM,GAAGD,KAAK,CAACE,MAAM;IACrBC,MAAM,GAAG,IAAIC,KAAK,CAACH,MAAM,CAAC;IAC1BI,OAAO,GAAG,CAAC,CAAC;IACZC,CAAC,GAAGL,MAAM;EAEd,OAAOK,CAAC,EAAE,EAAE;IACV,IAAI,CAACD,OAAO,CAACC,CAAC,CAAC,EAAEC,KAAK,CAACP,KAAK,CAACM,CAAC,CAAC,EAAEA,CAAC,EAAE,EAAE,CAAC;EACzC;EAEA,OAAOH,MAAM;EAEb,SAASI,KAAKA,CAACC,IAAI,EAAEF,CAAC,EAAEG,YAAY,EAAE;IACpC,IAAGA,YAAY,CAACC,OAAO,CAACF,IAAI,CAAC,IAAI,CAAC,EAAE;MAClC,IAAIG,OAAO;MACX,IAAI;QACFA,OAAO,GAAG,aAAa,GAAGC,IAAI,CAACC,SAAS,CAACL,IAAI,CAAC;MAChD,CAAC,CAAC,OAAMM,CAAC,EAAE;QACTH,OAAO,GAAG,EAAE;MACd;MACA,MAAM,IAAII,KAAK,CAAC,mBAAmB,GAAGJ,OAAO,CAAC;IAChD;IAEA,IAAI,CAAC,CAACX,KAAK,CAACU,OAAO,CAACF,IAAI,CAAC,EAAE;MACzB,MAAM,IAAIO,KAAK,CAAC,8EAA8E,GAACH,IAAI,CAACC,SAAS,CAACL,IAAI,CAAC,CAAC;IACtH;IAEA,IAAIH,OAAO,CAACC,CAAC,CAAC,EAAE;IAChBD,OAAO,CAACC,CAAC,CAAC,GAAG,IAAI;;IAEjB;IACA,IAAIU,QAAQ,GAAGpB,KAAK,CAACqB,MAAM,CAAC,UAASC,IAAI,EAAC;MACxC,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAKV,IAAI;IACzB,CAAC,CAAC;IACF,IAAIF,CAAC,GAAGU,QAAQ,CAACd,MAAM,EAAE;MACvB,IAAIiB,KAAK,GAAGV,YAAY,CAACW,MAAM,CAACZ,IAAI,CAAC;MACrC,GAAG;QACD,IAAIa,KAAK,GAAGL,QAAQ,CAAC,EAAEV,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5BC,KAAK,CAACc,KAAK,EAAErB,KAAK,CAACU,OAAO,CAACW,KAAK,CAAC,EAAEF,KAAK,CAAC;MAC3C,CAAC,QAAQb,CAAC;IACZ;IAEAH,MAAM,CAAC,EAAEF,MAAM,CAAC,GAAGO,IAAI;EACzB;AACF;AAEA,SAASV,WAAWA,CAACwB,GAAG,EAAC;EACvB,IAAIC,GAAG,GAAG,EAAE;EACZ,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEkB,GAAG,GAAGF,GAAG,CAACpB,MAAM,EAAEI,CAAC,GAAGkB,GAAG,EAAElB,CAAC,EAAE,EAAE;IAC9C,IAAIY,IAAI,GAAGI,GAAG,CAAChB,CAAC,CAAC;IACjB,IAAIiB,GAAG,CAACb,OAAO,CAACQ,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEK,GAAG,CAACE,IAAI,CAACP,IAAI,CAAC,CAAC,CAAC,CAAC;IAC/C,IAAIK,GAAG,CAACb,OAAO,CAACQ,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAEK,GAAG,CAACE,IAAI,CAACP,IAAI,CAAC,CAAC,CAAC,CAAC;EACjD;EACA,OAAOK,GAAG;AACZ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}